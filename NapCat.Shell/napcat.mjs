import log4js from 'log4js';
import path$1, { join, resolve as resolve$3 } from 'node:path';
import * as fs$2 from 'fs';
import fs__default, { promises } from 'fs';
import os$1, { constants } from 'node:os';
import process$2 from 'node:process';
import tty from 'node:tty';
import path$2, { dirname } from 'path';
import fsPromise from 'fs/promises';
import require$$1 from 'events';
import https$1 from 'node:https';
import * as http$1 from 'node:http';
import http__default from 'node:http';
import * as fs$3 from 'node:fs';
import fs__default$1, { readFileSync, unlink, existsSync, writeFileSync } from 'node:fs';
import * as crypto$1 from 'crypto';
import crypto__default, { randomUUID, createHash, createHmac } from 'crypto';
import 'util';
import ffmpeg from 'fluent-ffmpeg';
import require$$1$1, { spawn } from 'node:child_process';
import { isSilk, isWav, encode, getDuration, getWavFileInfo, decode } from 'silk-wasm';
import * as os from 'os';
import os__default from 'os';
import WebSocket, { WebSocket as WebSocket$1, WebSocketServer } from 'ws';
import * as net from 'node:net';
import * as crypto from 'node:crypto';
import * as stream from 'node:stream';
import { Readable, PassThrough, pipeline } from 'node:stream';
import assert$1 from 'node:assert';
import * as zlib from 'node:zlib';
import urlParse, { fileURLToPath } from 'url';
import { ReadableStream } from 'node:stream/web';
import fsPromise$1, { open, stat } from 'node:fs/promises';
import require$$0 from 'node:events';
import qrcode from 'qrcode-terminal';
import express, { Router } from 'express';
import http$2 from 'http';
import { pathToFileURL } from 'node:url';
import { dlopen } from 'process';

async function solveProblem(func, ...args) {
  return new Promise((resolve) => {
    try {
      const result = func(...args);
      resolve(result);
    } catch (e) {
      resolve(void 0);
    }
  });
}
async function solveAsyncProblem(func, ...args) {
  return new Promise((resolve) => {
    func(...args).then((result) => {
      resolve(result);
    }).catch(() => {
      resolve(void 0);
    });
  });
}
class FileNapCatOneBotUUID {
  static encodeModelId(peer, modelId, fileId, fileUUID = "", endString = "") {
    const data = `NapCatOneBot|ModelIdFile|${peer.chatType}|${peer.peerUid}|${modelId}|${fileId}|${fileUUID}`;
    const length = Buffer.alloc(4 + data.length);
    length.writeUInt32BE(data.length * 2, 0);
    length.write(data, 4);
    return length.toString("hex") + endString;
  }
  static decodeModelId(uuid) {
    const length = Buffer.from(uuid.slice(0, 8), "hex").readUInt32BE(0);
    const dataId = uuid.slice(8, 8 + length);
    const realData = Buffer.from(dataId, "hex").toString();
    if (!realData.startsWith("NapCatOneBot|ModelIdFile|")) return void 0;
    const data = realData.split("|");
    if (data.length < 6) return void 0;
    const [, , chatType, peerUid, modelId, fileId, fileUUID = void 0] = data;
    return {
      peer: {
        chatType,
        peerUid
      },
      modelId,
      fileId,
      fileUUID
    };
  }
  static encode(peer, msgId, elementId, fileUUID = "", endString = "") {
    const data = `NapCatOneBot|MsgFile|${peer.chatType}|${peer.peerUid}|${msgId}|${elementId}|${fileUUID}`;
    const length = Buffer.alloc(4 + data.length);
    length.writeUInt32BE(data.length * 2, 0);
    length.write(data, 4);
    return length.toString("hex") + endString;
  }
  static decode(uuid) {
    const length = Buffer.from(uuid.slice(0, 8), "hex").readUInt32BE(0);
    const dataId = uuid.slice(8, 8 + length);
    const realData = Buffer.from(dataId, "hex").toString();
    if (!realData.startsWith("NapCatOneBot|MsgFile|")) return void 0;
    const data = realData.split("|");
    if (data.length < 6) return void 0;
    const [, , chatType, peerUid, msgId, elementId, fileUUID = void 0] = data;
    return {
      peer: {
        chatType,
        peerUid
      },
      msgId,
      elementId,
      fileUUID
    };
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function isNull(value) {
  return value === void 0 || value === null;
}
function isNumeric(str) {
  return /^\d+$/.test(str);
}
function truncateString(obj, maxLength = 500) {
  if (obj !== null && typeof obj === "object") {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] === "string") {
        if (obj[key].length > maxLength) {
          obj[key] = obj[key].substring(0, maxLength) + "...";
        }
      } else if (typeof obj[key] === "object") {
        truncateString(obj[key], maxLength);
      }
    });
  }
  return obj;
}
function getDefaultQQVersionConfigInfo() {
  if (os$1.platform() === "linux") {
    return {
      baseVersion: "3.2.12.28060",
      curVersion: "3.2.12.28060",
      prevVersion: "",
      onErrorVersions: [],
      buildId: "27254"
    };
  }
  if (os$1.platform() === "darwin") {
    return {
      baseVersion: "6.9.53.28060",
      curVersion: "6.9.53.28060",
      prevVersion: "",
      onErrorVersions: [],
      buildId: "28060"
    };
  }
  return {
    baseVersion: "9.9.15-28131",
    curVersion: "9.9.15-28131",
    prevVersion: "",
    onErrorVersions: [],
    buildId: "28131"
  };
}
function getQQPackageInfoPath(exePath = "", version) {
  let packagePath;
  if (os$1.platform() === "darwin") {
    packagePath = path$1.join(path$1.dirname(exePath), "..", "Resources", "app", "package.json");
  } else if (os$1.platform() === "linux") {
    packagePath = path$1.join(path$1.dirname(exePath), "./resources/app/package.json");
  } else {
    packagePath = path$1.join(path$1.dirname(exePath), "./versions/" + version + "/resources/app/package.json");
  }
  if (!fs__default.existsSync(packagePath)) {
    packagePath = path$1.join(path$1.dirname(exePath), "./resources/app/versions/" + version + "/package.json");
  }
  return packagePath;
}
function getQQVersionConfigPath(exePath = "") {
  let configVersionInfoPath;
  if (os$1.platform() === "win32") {
    configVersionInfoPath = path$1.join(path$1.dirname(exePath), "versions", "config.json");
  } else if (os$1.platform() === "darwin") {
    const userPath = os$1.homedir();
    const appDataPath = path$1.resolve(userPath, "./Library/Application Support/QQ");
    configVersionInfoPath = path$1.resolve(appDataPath, "./versions/config.json");
  } else {
    const userPath = os$1.homedir();
    const appDataPath = path$1.resolve(userPath, "./.config/QQ");
    configVersionInfoPath = path$1.resolve(appDataPath, "./versions/config.json");
  }
  if (typeof configVersionInfoPath !== "string") {
    return void 0;
  }
  if (!fs__default.existsSync(configVersionInfoPath)) {
    configVersionInfoPath = path$1.join(path$1.dirname(exePath), "./resources/app/versions/config.json");
  }
  if (!fs__default.existsSync(configVersionInfoPath)) {
    return void 0;
  }
  return configVersionInfoPath;
}
function calcQQLevel(level) {
  if (!level) return 0;
  const { crownNum, sunNum, moonNum, starNum } = level;
  return crownNum * 64 + sunNum * 16 + moonNum * 4 + starNum;
}
function stringifyWithBigInt(obj) {
  return JSON.stringify(
    obj,
    (key, value) => typeof value === "bigint" ? value.toString() : value
  );
}

const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles$1 = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles$1[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles$1, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles$1.color.close = '\u001B[39m';
	styles$1.bgColor.close = '\u001B[49m';

	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles$1;
}

const ansiStyles = assembleStyles();

// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process$2.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = process$2;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process$2.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os$1.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: tty.isatty(1)}),
	stderr: createSupportsColor({isTTY: tty.isatty(2)}),
};

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansiStyles[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
		}

		return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansiStyles.hexToRgb(...arguments_));
	}

	return ansiStyles[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

const chalk = createChalk();
createChalk({level: stderrColor ? stderrColor.level : 0});

var Sex = /* @__PURE__ */ ((Sex2) => {
  Sex2[Sex2["male"] = 1] = "male";
  Sex2[Sex2["female"] = 2] = "female";
  Sex2[Sex2["unknown"] = 255] = "unknown";
  return Sex2;
})(Sex || {});
var BuddyListReqType = /* @__PURE__ */ ((BuddyListReqType2) => {
  BuddyListReqType2[BuddyListReqType2["KNOMAL"] = 0] = "KNOMAL";
  BuddyListReqType2[BuddyListReqType2["KLETTER"] = 1] = "KLETTER";
  return BuddyListReqType2;
})(BuddyListReqType || {});
var UserDetailSource = /* @__PURE__ */ ((UserDetailSource2) => {
  UserDetailSource2[UserDetailSource2["KDB"] = 0] = "KDB";
  UserDetailSource2[UserDetailSource2["KSERVER"] = 1] = "KSERVER";
  return UserDetailSource2;
})(UserDetailSource || {});
var ProfileBizType = /* @__PURE__ */ ((ProfileBizType2) => {
  ProfileBizType2[ProfileBizType2["KALL"] = 0] = "KALL";
  ProfileBizType2[ProfileBizType2["KBASEEXTEND"] = 1] = "KBASEEXTEND";
  ProfileBizType2[ProfileBizType2["KVAS"] = 2] = "KVAS";
  ProfileBizType2[ProfileBizType2["KQZONE"] = 3] = "KQZONE";
  ProfileBizType2[ProfileBizType2["KOTHER"] = 4] = "KOTHER";
  return ProfileBizType2;
})(ProfileBizType || {});

var DataSource = /* @__PURE__ */ ((DataSource2) => {
  DataSource2[DataSource2["LOCAL"] = 0] = "LOCAL";
  DataSource2[DataSource2["REMOTE"] = 1] = "REMOTE";
  return DataSource2;
})(DataSource || {});
var GroupMemberRole = /* @__PURE__ */ ((GroupMemberRole2) => {
  GroupMemberRole2[GroupMemberRole2["normal"] = 2] = "normal";
  GroupMemberRole2[GroupMemberRole2["admin"] = 3] = "admin";
  GroupMemberRole2[GroupMemberRole2["owner"] = 4] = "owner";
  return GroupMemberRole2;
})(GroupMemberRole || {});

var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2[ElementType2["UNKNOWN"] = 0] = "UNKNOWN";
  ElementType2[ElementType2["TEXT"] = 1] = "TEXT";
  ElementType2[ElementType2["PIC"] = 2] = "PIC";
  ElementType2[ElementType2["FILE"] = 3] = "FILE";
  ElementType2[ElementType2["PTT"] = 4] = "PTT";
  ElementType2[ElementType2["VIDEO"] = 5] = "VIDEO";
  ElementType2[ElementType2["FACE"] = 6] = "FACE";
  ElementType2[ElementType2["REPLY"] = 7] = "REPLY";
  ElementType2[ElementType2["GreyTip"] = 8] = "GreyTip";
  ElementType2[ElementType2["WALLET"] = 9] = "WALLET";
  ElementType2[ElementType2["ARK"] = 10] = "ARK";
  ElementType2[ElementType2["MFACE"] = 11] = "MFACE";
  ElementType2[ElementType2["LIVEGIFT"] = 12] = "LIVEGIFT";
  ElementType2[ElementType2["STRUCTLONGMSG"] = 13] = "STRUCTLONGMSG";
  ElementType2[ElementType2["MARKDOWN"] = 14] = "MARKDOWN";
  ElementType2[ElementType2["GIPHY"] = 15] = "GIPHY";
  ElementType2[ElementType2["MULTIFORWARD"] = 16] = "MULTIFORWARD";
  ElementType2[ElementType2["INLINEKEYBOARD"] = 17] = "INLINEKEYBOARD";
  ElementType2[ElementType2["INTEXTGIFT"] = 18] = "INTEXTGIFT";
  ElementType2[ElementType2["CALENDAR"] = 19] = "CALENDAR";
  ElementType2[ElementType2["YOLOGAMERESULT"] = 20] = "YOLOGAMERESULT";
  ElementType2[ElementType2["AVRECORD"] = 21] = "AVRECORD";
  ElementType2[ElementType2["FEED"] = 22] = "FEED";
  ElementType2[ElementType2["TOFURECORD"] = 23] = "TOFURECORD";
  ElementType2[ElementType2["ACEBUBBLE"] = 24] = "ACEBUBBLE";
  ElementType2[ElementType2["ACTIVITY"] = 25] = "ACTIVITY";
  ElementType2[ElementType2["TOFU"] = 26] = "TOFU";
  ElementType2[ElementType2["FACEBUBBLE"] = 27] = "FACEBUBBLE";
  ElementType2[ElementType2["SHARELOCATION"] = 28] = "SHARELOCATION";
  ElementType2[ElementType2["TASKTOPMSG"] = 29] = "TASKTOPMSG";
  ElementType2[ElementType2["RECOMMENDEDMSG"] = 43] = "RECOMMENDEDMSG";
  ElementType2[ElementType2["ACTIONBAR"] = 44] = "ACTIONBAR";
  return ElementType2;
})(ElementType || {});
var PicType = /* @__PURE__ */ ((PicType2) => {
  PicType2[PicType2["gif"] = 2e3] = "gif";
  PicType2[PicType2["jpg"] = 1e3] = "jpg";
  return PicType2;
})(PicType || {});
var AtType = /* @__PURE__ */ ((AtType2) => {
  AtType2[AtType2["notAt"] = 0] = "notAt";
  AtType2[AtType2["atAll"] = 1] = "atAll";
  AtType2[AtType2["atUser"] = 2] = "atUser";
  return AtType2;
})(AtType || {});
var ChatType = /* @__PURE__ */ ((ChatType2) => {
  ChatType2[ChatType2["KCHATTYPEADELIE"] = 42] = "KCHATTYPEADELIE";
  ChatType2[ChatType2["KCHATTYPEBUDDYNOTIFY"] = 5] = "KCHATTYPEBUDDYNOTIFY";
  ChatType2[ChatType2["KCHATTYPEC2C"] = 1] = "KCHATTYPEC2C";
  ChatType2[ChatType2["KCHATTYPECIRCLE"] = 113] = "KCHATTYPECIRCLE";
  ChatType2[ChatType2["KCHATTYPEDATALINE"] = 8] = "KCHATTYPEDATALINE";
  ChatType2[ChatType2["KCHATTYPEDATALINEMQQ"] = 134] = "KCHATTYPEDATALINEMQQ";
  ChatType2[ChatType2["KCHATTYPEDISC"] = 3] = "KCHATTYPEDISC";
  ChatType2[ChatType2["KCHATTYPEFAV"] = 41] = "KCHATTYPEFAV";
  ChatType2[ChatType2["KCHATTYPEGAMEMESSAGE"] = 105] = "KCHATTYPEGAMEMESSAGE";
  ChatType2[ChatType2["KCHATTYPEGAMEMESSAGEFOLDER"] = 116] = "KCHATTYPEGAMEMESSAGEFOLDER";
  ChatType2[ChatType2["KCHATTYPEGROUP"] = 2] = "KCHATTYPEGROUP";
  ChatType2[ChatType2["KCHATTYPEGROUPBLESS"] = 133] = "KCHATTYPEGROUPBLESS";
  ChatType2[ChatType2["KCHATTYPEGROUPGUILD"] = 9] = "KCHATTYPEGROUPGUILD";
  ChatType2[ChatType2["KCHATTYPEGROUPHELPER"] = 7] = "KCHATTYPEGROUPHELPER";
  ChatType2[ChatType2["KCHATTYPEGROUPNOTIFY"] = 6] = "KCHATTYPEGROUPNOTIFY";
  ChatType2[ChatType2["KCHATTYPEGUILD"] = 4] = "KCHATTYPEGUILD";
  ChatType2[ChatType2["KCHATTYPEGUILDMETA"] = 16] = "KCHATTYPEGUILDMETA";
  ChatType2[ChatType2["KCHATTYPEMATCHFRIEND"] = 104] = "KCHATTYPEMATCHFRIEND";
  ChatType2[ChatType2["KCHATTYPEMATCHFRIENDFOLDER"] = 109] = "KCHATTYPEMATCHFRIENDFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBY"] = 106] = "KCHATTYPENEARBY";
  ChatType2[ChatType2["KCHATTYPENEARBYASSISTANT"] = 107] = "KCHATTYPENEARBYASSISTANT";
  ChatType2[ChatType2["KCHATTYPENEARBYFOLDER"] = 110] = "KCHATTYPENEARBYFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBYHELLOFOLDER"] = 112] = "KCHATTYPENEARBYHELLOFOLDER";
  ChatType2[ChatType2["KCHATTYPENEARBYINTERACT"] = 108] = "KCHATTYPENEARBYINTERACT";
  ChatType2[ChatType2["KCHATTYPEQQNOTIFY"] = 132] = "KCHATTYPEQQNOTIFY";
  ChatType2[ChatType2["KCHATTYPERELATEACCOUNT"] = 131] = "KCHATTYPERELATEACCOUNT";
  ChatType2[ChatType2["KCHATTYPESERVICEASSISTANT"] = 118] = "KCHATTYPESERVICEASSISTANT";
  ChatType2[ChatType2["KCHATTYPESERVICEASSISTANTSUB"] = 201] = "KCHATTYPESERVICEASSISTANTSUB";
  ChatType2[ChatType2["KCHATTYPESQUAREPUBLIC"] = 115] = "KCHATTYPESQUAREPUBLIC";
  ChatType2[ChatType2["KCHATTYPESUBSCRIBEFOLDER"] = 30] = "KCHATTYPESUBSCRIBEFOLDER";
  ChatType2[ChatType2["KCHATTYPETEMPADDRESSBOOK"] = 111] = "KCHATTYPETEMPADDRESSBOOK";
  ChatType2[ChatType2["KCHATTYPETEMPBUSSINESSCRM"] = 102] = "KCHATTYPETEMPBUSSINESSCRM";
  ChatType2[ChatType2["KCHATTYPETEMPC2CFROMGROUP"] = 100] = "KCHATTYPETEMPC2CFROMGROUP";
  ChatType2[ChatType2["KCHATTYPETEMPC2CFROMUNKNOWN"] = 99] = "KCHATTYPETEMPC2CFROMUNKNOWN";
  ChatType2[ChatType2["KCHATTYPETEMPFRIENDVERIFY"] = 101] = "KCHATTYPETEMPFRIENDVERIFY";
  ChatType2[ChatType2["KCHATTYPETEMPNEARBYPRO"] = 119] = "KCHATTYPETEMPNEARBYPRO";
  ChatType2[ChatType2["KCHATTYPETEMPPUBLICACCOUNT"] = 103] = "KCHATTYPETEMPPUBLICACCOUNT";
  ChatType2[ChatType2["KCHATTYPETEMPWPA"] = 117] = "KCHATTYPETEMPWPA";
  ChatType2[ChatType2["KCHATTYPEUNKNOWN"] = 0] = "KCHATTYPEUNKNOWN";
  ChatType2[ChatType2["KCHATTYPEWEIYUN"] = 40] = "KCHATTYPEWEIYUN";
  return ChatType2;
})(ChatType || {});
const IMAGE_HTTP_HOST = "https://gchat.qpic.cn";
const IMAGE_HTTP_HOST_NT = "https://multimedia.nt.qq.com.cn";
var NTGrayTipElementSubTypeV2 = /* @__PURE__ */ ((NTGrayTipElementSubTypeV22) => {
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_AIOOP"] = 15] = "GRAYTIP_ELEMENT_SUBTYPE_AIOOP";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BLOCK"] = 14] = "GRAYTIP_ELEMENT_SUBTYPE_BLOCK";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BUDDY"] = 5] = "GRAYTIP_ELEMENT_SUBTYPE_BUDDY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_BUDDYNOTIFY"] = 9] = "GRAYTIP_ELEMENT_SUBTYPE_BUDDYNOTIFY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_EMOJIREPLY"] = 3] = "GRAYTIP_ELEMENT_SUBTYPE_EMOJIREPLY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_ESSENCE"] = 7] = "GRAYTIP_ELEMENT_SUBTYPE_ESSENCE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FEED"] = 6] = "GRAYTIP_ELEMENT_SUBTYPE_FEED";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FEEDCHANNELMSG"] = 11] = "GRAYTIP_ELEMENT_SUBTYPE_FEEDCHANNELMSG";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_FILE"] = 10] = "GRAYTIP_ELEMENT_SUBTYPE_FILE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_GROUP"] = 4] = "GRAYTIP_ELEMENT_SUBTYPE_GROUP";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_GROUPNOTIFY"] = 8] = "GRAYTIP_ELEMENT_SUBTYPE_GROUPNOTIFY";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_JSON"] = 17] = "GRAYTIP_ELEMENT_SUBTYPE_JSON";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_LOCALMSG"] = 13] = "GRAYTIP_ELEMENT_SUBTYPE_LOCALMSG";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_PROCLAMATION"] = 2] = "GRAYTIP_ELEMENT_SUBTYPE_PROCLAMATION";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_REVOKE"] = 1] = "GRAYTIP_ELEMENT_SUBTYPE_REVOKE";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_UNKNOWN"] = 0] = "GRAYTIP_ELEMENT_SUBTYPE_UNKNOWN";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_WALLET"] = 16] = "GRAYTIP_ELEMENT_SUBTYPE_WALLET";
  NTGrayTipElementSubTypeV22[NTGrayTipElementSubTypeV22["GRAYTIP_ELEMENT_SUBTYPE_XMLMSG"] = 12] = "GRAYTIP_ELEMENT_SUBTYPE_XMLMSG";
  return NTGrayTipElementSubTypeV22;
})(NTGrayTipElementSubTypeV2 || {});
var FaceType = /* @__PURE__ */ ((FaceType2) => {
  FaceType2[FaceType2["normal"] = 1] = "normal";
  FaceType2[FaceType2["normal2"] = 2] = "normal2";
  FaceType2[FaceType2["dice"] = 3] = "dice";
  FaceType2[FaceType2["poke"] = 5] = "poke";
  return FaceType2;
})(FaceType || {});
var FaceIndex = /* @__PURE__ */ ((FaceIndex2) => {
  FaceIndex2[FaceIndex2["dice"] = 358] = "dice";
  FaceIndex2[FaceIndex2["RPS"] = 359] = "RPS";
  return FaceIndex2;
})(FaceIndex || {});
var TipGroupElementType = /* @__PURE__ */ ((TipGroupElementType2) => {
  TipGroupElementType2[TipGroupElementType2["memberIncrease"] = 1] = "memberIncrease";
  TipGroupElementType2[TipGroupElementType2["kicked"] = 3] = "kicked";
  TipGroupElementType2[TipGroupElementType2["ban"] = 8] = "ban";
  return TipGroupElementType2;
})(TipGroupElementType || {});
var SendStatusType = /* @__PURE__ */ ((SendStatusType2) => {
  SendStatusType2[SendStatusType2["KSEND_STATUS_FAILED"] = 0] = "KSEND_STATUS_FAILED";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SENDING"] = 1] = "KSEND_STATUS_SENDING";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SUCCESS"] = 2] = "KSEND_STATUS_SUCCESS";
  SendStatusType2[SendStatusType2["KSEND_STATUS_SUCCESS_NOSEQ"] = 3] = "KSEND_STATUS_SUCCESS_NOSEQ";
  return SendStatusType2;
})(SendStatusType || {});

var GroupNotifyMsgType = /* @__PURE__ */ ((GroupNotifyMsgType2) => {
  GroupNotifyMsgType2[GroupNotifyMsgType2["UN_SPECIFIED"] = 0] = "UN_SPECIFIED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["INVITED_BY_MEMBER"] = 1] = "INVITED_BY_MEMBER";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REFUSE_INVITED"] = 2] = "REFUSE_INVITED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REFUSED_BY_ADMINI_STRATOR"] = 3] = "REFUSED_BY_ADMINI_STRATOR";
  GroupNotifyMsgType2[GroupNotifyMsgType2["AGREED_TOJOIN_DIRECT"] = 4] = "AGREED_TOJOIN_DIRECT";
  GroupNotifyMsgType2[GroupNotifyMsgType2["INVITED_NEED_ADMINI_STRATOR_PASS"] = 5] = "INVITED_NEED_ADMINI_STRATOR_PASS";
  GroupNotifyMsgType2[GroupNotifyMsgType2["AGREED_TO_JOIN_BY_ADMINI_STRATOR"] = 6] = "AGREED_TO_JOIN_BY_ADMINI_STRATOR";
  GroupNotifyMsgType2[GroupNotifyMsgType2["REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS"] = 7] = "REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS";
  GroupNotifyMsgType2[GroupNotifyMsgType2["SET_ADMIN"] = 8] = "SET_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["KICK_MEMBER_NOTIFY_ADMIN"] = 9] = "KICK_MEMBER_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["KICK_MEMBER_NOTIFY_KICKED"] = 10] = "KICK_MEMBER_NOTIFY_KICKED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["MEMBER_LEAVE_NOTIFY_ADMIN"] = 11] = "MEMBER_LEAVE_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["CANCEL_ADMIN_NOTIFY_CANCELED"] = 12] = "CANCEL_ADMIN_NOTIFY_CANCELED";
  GroupNotifyMsgType2[GroupNotifyMsgType2["CANCEL_ADMIN_NOTIFY_ADMIN"] = 13] = "CANCEL_ADMIN_NOTIFY_ADMIN";
  GroupNotifyMsgType2[GroupNotifyMsgType2["TRANSFER_GROUP_NOTIFY_OLDOWNER"] = 14] = "TRANSFER_GROUP_NOTIFY_OLDOWNER";
  GroupNotifyMsgType2[GroupNotifyMsgType2["TRANSFER_GROUP_NOTIFY_ADMIN"] = 15] = "TRANSFER_GROUP_NOTIFY_ADMIN";
  return GroupNotifyMsgType2;
})(GroupNotifyMsgType || {});
var GroupNotifyMsgStatus = /* @__PURE__ */ ((GroupNotifyMsgStatus2) => {
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KINIT"] = 0] = "KINIT";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KUNHANDLE"] = 1] = "KUNHANDLE";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KAGREED"] = 2] = "KAGREED";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KREFUSED"] = 3] = "KREFUSED";
  GroupNotifyMsgStatus2[GroupNotifyMsgStatus2["KIGNORED"] = 4] = "KIGNORED";
  return GroupNotifyMsgStatus2;
})(GroupNotifyMsgStatus || {});
var GroupRequestOperateTypes = /* @__PURE__ */ ((GroupRequestOperateTypes2) => {
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["approve"] = 1] = "approve";
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["reject"] = 2] = "reject";
  return GroupRequestOperateTypes2;
})(GroupRequestOperateTypes || {});
var BuddyReqType = /* @__PURE__ */ ((BuddyReqType2) => {
  BuddyReqType2[BuddyReqType2["KMEINITIATOR"] = 0] = "KMEINITIATOR";
  BuddyReqType2[BuddyReqType2["KPEERINITIATOR"] = 1] = "KPEERINITIATOR";
  BuddyReqType2[BuddyReqType2["KMEAGREED"] = 2] = "KMEAGREED";
  BuddyReqType2[BuddyReqType2["KMEAGREEDANDADDED"] = 3] = "KMEAGREEDANDADDED";
  BuddyReqType2[BuddyReqType2["KPEERAGREED"] = 4] = "KPEERAGREED";
  BuddyReqType2[BuddyReqType2["KPEERAGREEDANDADDED"] = 5] = "KPEERAGREEDANDADDED";
  BuddyReqType2[BuddyReqType2["KPEERREFUSED"] = 6] = "KPEERREFUSED";
  BuddyReqType2[BuddyReqType2["KMEREFUSED"] = 7] = "KMEREFUSED";
  BuddyReqType2[BuddyReqType2["KMEIGNORED"] = 8] = "KMEIGNORED";
  BuddyReqType2[BuddyReqType2["KMEAGREEANYONE"] = 9] = "KMEAGREEANYONE";
  BuddyReqType2[BuddyReqType2["KMESETQUESTION"] = 10] = "KMESETQUESTION";
  BuddyReqType2[BuddyReqType2["KMEAGREEANDADDFAILED"] = 11] = "KMEAGREEANDADDFAILED";
  BuddyReqType2[BuddyReqType2["KMSGINFO"] = 12] = "KMSGINFO";
  BuddyReqType2[BuddyReqType2["KMEINITIATORWAITPEERCONFIRM"] = 13] = "KMEINITIATORWAITPEERCONFIRM";
  return BuddyReqType2;
})(BuddyReqType || {});
var MemberExtSourceType = /* @__PURE__ */ ((MemberExtSourceType2) => {
  MemberExtSourceType2[MemberExtSourceType2["DEFAULTTYPE"] = 0] = "DEFAULTTYPE";
  MemberExtSourceType2[MemberExtSourceType2["TITLETYPE"] = 1] = "TITLETYPE";
  MemberExtSourceType2[MemberExtSourceType2["NEWGROUPTYPE"] = 2] = "NEWGROUPTYPE";
  return MemberExtSourceType2;
})(MemberExtSourceType || {});

var WebHonorType = /* @__PURE__ */ ((WebHonorType2) => {
  WebHonorType2["ALL"] = "all";
  WebHonorType2["TALKATIVE"] = "talkative";
  WebHonorType2["PERFORMER"] = "performer";
  WebHonorType2["LEGEND"] = "legend";
  WebHonorType2["STRONG_NEWBIE"] = "strong_newbie";
  WebHonorType2["EMOTION"] = "emotion";
  return WebHonorType2;
})(WebHonorType || {});

const defaultMessages = 'End-Of-Stream';
/**
 * Thrown on read operation of the end of file or stream has been reached
 */
class EndOfStreamError extends Error {
    constructor() {
        super(defaultMessages);
    }
}

class Deferred {
    constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve, reject) => {
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}

class AbstractStreamReader {
    constructor() {
        /**
         * Maximum request length on read-stream operation
         */
        this.maxStreamReadSize = 1 * 1024 * 1024;
        this.endOfStream = false;
        /**
         * Store peeked data
         * @type {Array}
         */
        this.peekQueue = [];
    }
    async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer
        return bytesRead;
    }
    async read(buffer, offset, length) {
        if (length === 0) {
            return 0;
        }
        let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
        bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
        if (bytesRead === 0) {
            throw new EndOfStreamError();
        }
        return bytesRead;
    }
    /**
     * Read chunk from stream
     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset - Offset target
     * @param length - Number of bytes to read
     * @returns Number of bytes read
     */
    readFromPeekBuffer(buffer, offset, length) {
        let remaining = length;
        let bytesRead = 0;
        // consume peeked data first
        while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop(); // Front of queue
            if (!peekData)
                throw new Error('peekData should be defined');
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
                // remainder back to queue
                this.peekQueue.push(peekData.subarray(lenCopy));
            }
        }
        return bytesRead;
    }
    async readRemainderFromStream(buffer, offset, initialRemaining) {
        let remaining = initialRemaining;
        let bytesRead = 0;
        // Continue reading from stream if required
        while (remaining > 0 && !this.endOfStream) {
            const reqLen = Math.min(remaining, this.maxStreamReadSize);
            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
            if (chunkLen === 0)
                break;
            bytesRead += chunkLen;
            remaining -= chunkLen;
        }
        return bytesRead;
    }
}

/**
 * Node.js Readable Stream Reader
 * Ref: https://nodejs.org/api/stream.html#readable-streams
 */
class StreamReader extends AbstractStreamReader {
    constructor(s) {
        super();
        this.s = s;
        /**
         * Deferred used for postponed read request (as not data is yet available to read)
         */
        this.deferred = null;
        if (!s.read || !s.once) {
            throw new Error('Expected an instance of stream.Readable');
        }
        this.s.once('end', () => this.reject(new EndOfStreamError()));
        this.s.once('error', err => this.reject(err));
        this.s.once('close', () => this.reject(new Error('Stream closed')));
    }
    /**
     * Read chunk from stream
     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
     * @param offset Offset target
     * @param length Number of bytes to read
     * @returns Number of bytes read
     */
    async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            return 0;
        }
        const readBuffer = this.s.read(length);
        if (readBuffer) {
            buffer.set(readBuffer, offset);
            return readBuffer.length;
        }
        const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred()
        };
        this.deferred = request.deferred;
        this.s.once('readable', () => {
            this.readDeferred(request);
        });
        return request.deferred.promise;
    }
    /**
     * Process deferred read request
     * @param request Deferred read request
     */
    readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
            request.buffer.set(readBuffer, request.offset);
            request.deferred.resolve(readBuffer.length);
            this.deferred = null;
        }
        else {
            this.s.once('readable', () => {
                this.readDeferred(request);
            });
        }
    }
    reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
            this.deferred.reject(err);
            this.deferred = null;
        }
    }
    async abort() {
        this.s.destroy();
    }
}

/**
 * Read from a WebStream
 * Reference: https://nodejs.org/api/webstreams.html#class-readablestreambyobreader
 */
class WebStreamReader extends AbstractStreamReader {
    constructor(stream) {
        super();
        this.reader = stream.getReader({ mode: 'byob' });
    }
    async readFromStream(buffer, offset, length) {
        if (this.endOfStream) {
            throw new EndOfStreamError();
        }
        const result = await this.reader.read(new Uint8Array(length));
        if (result.done) {
            this.endOfStream = result.done;
        }
        if (result.value) {
            buffer.set(result.value, offset);
            return result.value.byteLength;
        }
        return 0;
    }
    async abort() {
        await this.reader.cancel(); // Signals a loss of interest in the stream by a consumer
        this.reader.releaseLock();
    }
}

/**
 * Core tokenizer
 */
class AbstractTokenizer {
    /**
     * Constructor
     * @param options Tokenizer options
     * @protected
     */
    constructor(options) {
        /**
         * Tokenizer-stream position
         */
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = options?.fileInfo ?? {};
        this.onClose = options?.onClose;
        if (options?.abortSignal) {
            options.abortSignal.addEventListener('abort', () => {
                this.abort();
            });
        }
    }
    /**
     * Read a token from the tokenizer-stream
     * @param token - The token to read
     * @param position - If provided, the desired position in the tokenizer-stream
     * @returns Promise with token data
     */
    async readToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(uint8Array, 0);
    }
    /**
     * Peek a token from the tokenizer-stream.
     * @param token - Token to peek from the tokenizer-stream.
     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
     * @returns Promise with token data
     */
    async peekToken(token, position = this.position) {
        const uint8Array = new Uint8Array(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(uint8Array, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Read a numeric token from the stream
     * @param token - Numeric token
     * @returns Promise with number
     */
    async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
            throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
    }
    /**
     * Ignore number of bytes, advances the pointer in under tokenizer-stream.
     * @param length - Number of bytes to ignore
     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
     */
    async ignore(length) {
        if (this.fileInfo.size !== undefined) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
                this.position += bytesLeft;
                return bytesLeft;
            }
        }
        this.position += length;
        return length;
    }
    async close() {
        await this.abort();
        await this.onClose?.();
    }
    normalizeOptions(uint8Array, options) {
        if (options && options.position !== undefined && options.position < this.position) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (options) {
            return {
                mayBeLess: options.mayBeLess === true,
                offset: options.offset ? options.offset : 0,
                length: options.length ? options.length : (uint8Array.length - (options.offset ? options.offset : 0)),
                position: options.position ? options.position : this.position
            };
        }
        return {
            mayBeLess: false,
            offset: 0,
            length: uint8Array.length,
            position: this.position
        };
    }
    abort() {
        return Promise.resolve(); // Ignore abort signal
    }
}

const maxBufferSize = 256000;
class ReadStreamTokenizer extends AbstractTokenizer {
    /**
     * Constructor
     * @param streamReader stream-reader to read from
     * @param options Tokenizer options
     */
    constructor(streamReader, options) {
        super(options);
        this.streamReader = streamReader;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
     * @param options - Read behaviour options
     * @returns Promise with number of bytes read
     */
    async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
        }
        if (skipBytes < 0) {
            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
        }
        if (normOptions.length === 0) {
            return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
        }
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise with number of bytes peeked
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
                return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
                throw new Error('Cannot peek from a negative offset in a stream');
            }
        }
        if (normOptions.length > 0) {
            try {
                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            }
            catch (err) {
                if (options?.mayBeLess && err instanceof EndOfStreamError) {
                    return 0;
                }
                throw err;
            }
            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
                throw new EndOfStreamError();
            }
        }
        return bytesRead;
    }
    async ignore(length) {
        // debug(`ignore ${this.position}...${this.position + length - 1}`);
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
                return bytesRead;
            }
            totBytesRead += bytesRead;
        }
        return totBytesRead;
    }
    abort() {
        return this.streamReader.abort();
    }
}

class BufferTokenizer extends AbstractTokenizer {
    /**
     * Construct BufferTokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options Tokenizer options
     */
    constructor(uint8Array, options) {
        super(options);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
    }
    /**
     * Read buffer from tokenizer
     * @param uint8Array - Uint8Array to tokenize
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async readBuffer(uint8Array, options) {
        if (options?.position) {
            if (options.position < this.position) {
                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');
            }
            this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
    }
    /**
     * Peek (read ahead) buffer from tokenizer
     * @param uint8Array
     * @param options - Read behaviour options
     * @returns {Promise<number>}
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
        }
        uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
        return bytes2read;
    }
    close() {
        return super.close();
    }
}

/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param stream - Read from Node.js Stream.Readable
 * @param options - Tokenizer options
 * @returns ReadStreamTokenizer
 */
function fromStream$1(stream, options) {
    return new ReadStreamTokenizer(new StreamReader(stream), options);
}
/**
 * Construct ReadStreamTokenizer from given ReadableStream (WebStream API).
 * Will set fileSize, if provided given Stream has set the .path property/
 * @param webStream - Read from Node.js Stream.Readable (must be a byte stream)
 * @param options - Tokenizer options
 * @returns ReadStreamTokenizer
 */
function fromWebStream(webStream, options) {
    return new ReadStreamTokenizer(new WebStreamReader(webStream), options);
}
/**
 * Construct ReadStreamTokenizer from given Buffer.
 * @param uint8Array - Uint8Array to tokenize
 * @param options - Tokenizer options
 * @returns BufferTokenizer
 */
function fromBuffer(uint8Array, options) {
    return new BufferTokenizer(uint8Array, options);
}

class FileTokenizer extends AbstractTokenizer {
    constructor(fileHandle, options) {
        super(options);
        this.fileHandle = fileHandle;
    }
    /**
     * Read buffer from file
     * @param uint8Array - Uint8Array to write result to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */
    async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        if (normOptions.length === 0)
            return 0;
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
            throw new EndOfStreamError();
        }
        return res.bytesRead;
    }
    /**
     * Peek buffer from file
     * @param uint8Array - Uint8Array (or Buffer) to write data to
     * @param options - Read behaviour options
     * @returns Promise number of bytes read
     */
    async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await this.fileHandle.read(uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if ((!normOptions.mayBeLess) && res.bytesRead < normOptions.length) {
            throw new EndOfStreamError();
        }
        return res.bytesRead;
    }
    async close() {
        await this.fileHandle.close();
        return super.close();
    }
}
async function fromFile(sourceFilePath) {
    const fileHandle = await open(sourceFilePath, 'r');
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
}

/**
 * Construct ReadStreamTokenizer from given Stream.
 * Will set fileSize, if provided given Stream has set the .path property.
 * @param stream - Node.js Stream.Readable
 * @param options - Pass additional file information to the tokenizer
 * @returns Tokenizer
 */
async function fromStream(stream, options) {
    const augmentedOptions = options ?? {};
    augmentedOptions.fileInfo = augmentedOptions.fileInfo ?? {};
    if (stream.path) {
        const stat$1 = await stat(stream.path);
        augmentedOptions.fileInfo.path = stream.path;
        augmentedOptions.fileInfo.size = stat$1.size;
    }
    return fromStream$1(stream, augmentedOptions);
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

// Primitive types
function dv(array) {
    return new DataView(array.buffer, array.byteOffset);
}
/**
 * 8-bit unsigned integer
 */
const UINT8 = {
    len: 1,
    get(array, offset) {
        return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
    }
};
/**
 * 16-bit unsigned integer, Little Endian byte order
 */
const UINT16_LE = {
    len: 2,
    get(array, offset) {
        return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
    }
};
/**
 * 16-bit unsigned integer, Big Endian byte order
 */
const UINT16_BE = {
    len: 2,
    get(array, offset) {
        return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
    }
};
/**
 * 32-bit unsigned integer, Little Endian byte order
 */
const UINT32_LE = {
    len: 4,
    get(array, offset) {
        return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
    }
};
/**
 * 32-bit unsigned integer, Big Endian byte order
 */
const UINT32_BE = {
    len: 4,
    get(array, offset) {
        return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
    }
};
/**
 * 32-bit signed integer, Big Endian byte order
 */
const INT32_BE = {
    len: 4,
    get(array, offset) {
        return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
    }
};
/**
 * 64-bit unsigned integer, Little Endian byte order
 */
const UINT64_LE = {
    len: 8,
    get(array, offset) {
        return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
    }
};
/**
 * Consume a fixed number of bytes from the stream and return a string with a specified encoding.
 */
class StringType {
    constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
        this.textDecoder = new TextDecoder(encoding);
    }
    get(uint8Array, offset) {
        return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
    }
}

({
	utf8: new globalThis.TextDecoder('utf8'),
});

new globalThis.TextEncoder();

Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));

/**
@param {DataView} view
@returns {number}
*/
function getUintBE(view) {
	const {byteLength} = view;

	if (byteLength === 6) {
		return (view.getUint16(0) * (2 ** 32)) + view.getUint32(2);
	}

	if (byteLength === 5) {
		return (view.getUint8(0) * (2 ** 32)) + view.getUint32(1);
	}

	if (byteLength === 4) {
		return view.getUint32(0);
	}

	if (byteLength === 3) {
		return (view.getUint8(0) * (2 ** 16)) + view.getUint16(1);
	}

	if (byteLength === 2) {
		return view.getUint16(0);
	}

	if (byteLength === 1) {
		return view.getUint8(0);
	}
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {number}
*/
function indexOf(array, value) {
	const arrayLength = array.length;
	const valueLength = value.length;

	if (valueLength === 0) {
		return -1;
	}

	if (valueLength > arrayLength) {
		return -1;
	}

	const validOffsetLength = arrayLength - valueLength;

	for (let index = 0; index <= validOffsetLength; index++) {
		let isMatch = true;
		for (let index2 = 0; index2 < valueLength; index2++) {
			if (array[index + index2] !== value[index2]) {
				isMatch = false;
				break;
			}
		}

		if (isMatch) {
			return index;
		}
	}

	return -1;
}

/**
@param {Uint8Array} array
@param {Uint8Array} value
@returns {boolean}
*/
function includes(array, value) {
	return indexOf(array, value) !== -1;
}

function stringToBytes(string) {
	return [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point
}

/**
Checks whether the TAR checksum is valid.

@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.
@param {number} offset - TAR header offset.
@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.
*/
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
	const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, '').trim(), 8); // Read sum in header
	if (Number.isNaN(readSum)) {
		return false;
	}

	let sum = 8 * 0x20; // Initialize signed bit sum

	for (let index = offset; index < offset + 148; index++) {
		sum += arrayBuffer[index];
	}

	for (let index = offset + 156; index < offset + 512; index++) {
		sum += arrayBuffer[index];
	}

	return readSum === sum;
}

/**
ID3 UINT32 sync-safe tokenizer token.
28 bits (representing up to 256MB) integer, the msb is 0 to avoid "false syncsignals".
*/
const uint32SyncSafeToken = {
	get: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),
	len: 4,
};

const extensions = [
	'jpg',
	'png',
	'apng',
	'gif',
	'webp',
	'flif',
	'xcf',
	'cr2',
	'cr3',
	'orf',
	'arw',
	'dng',
	'nef',
	'rw2',
	'raf',
	'tif',
	'bmp',
	'icns',
	'jxr',
	'psd',
	'indd',
	'zip',
	'tar',
	'rar',
	'gz',
	'bz2',
	'7z',
	'dmg',
	'mp4',
	'mid',
	'mkv',
	'webm',
	'mov',
	'avi',
	'mpg',
	'mp2',
	'mp3',
	'm4a',
	'oga',
	'ogg',
	'ogv',
	'opus',
	'flac',
	'wav',
	'spx',
	'amr',
	'pdf',
	'epub',
	'elf',
	'macho',
	'exe',
	'swf',
	'rtf',
	'wasm',
	'woff',
	'woff2',
	'eot',
	'ttf',
	'otf',
	'ico',
	'flv',
	'ps',
	'xz',
	'sqlite',
	'nes',
	'crx',
	'xpi',
	'cab',
	'deb',
	'ar',
	'rpm',
	'Z',
	'lz',
	'cfb',
	'mxf',
	'mts',
	'blend',
	'bpg',
	'docx',
	'pptx',
	'xlsx',
	'3gp',
	'3g2',
	'j2c',
	'jp2',
	'jpm',
	'jpx',
	'mj2',
	'aif',
	'qcp',
	'odt',
	'ods',
	'odp',
	'xml',
	'mobi',
	'heic',
	'cur',
	'ktx',
	'ape',
	'wv',
	'dcm',
	'ics',
	'glb',
	'pcap',
	'dsf',
	'lnk',
	'alias',
	'voc',
	'ac3',
	'm4v',
	'm4p',
	'm4b',
	'f4v',
	'f4p',
	'f4b',
	'f4a',
	'mie',
	'asf',
	'ogm',
	'ogx',
	'mpc',
	'arrow',
	'shp',
	'aac',
	'mp1',
	'it',
	's3m',
	'xm',
	'ai',
	'skp',
	'avif',
	'eps',
	'lzh',
	'pgp',
	'asar',
	'stl',
	'chm',
	'3mf',
	'zst',
	'jxl',
	'vcf',
	'jls',
	'pst',
	'dwg',
	'parquet',
	'class',
	'arj',
	'cpio',
	'ace',
	'avro',
	'icc',
	'fbx',
	'vsdx',
	'vtt',
	'apk',
];

const mimeTypes = [
	'image/jpeg',
	'image/png',
	'image/gif',
	'image/webp',
	'image/flif',
	'image/x-xcf',
	'image/x-canon-cr2',
	'image/x-canon-cr3',
	'image/tiff',
	'image/bmp',
	'image/vnd.ms-photo',
	'image/vnd.adobe.photoshop',
	'application/x-indesign',
	'application/epub+zip',
	'application/x-xpinstall',
	'application/vnd.oasis.opendocument.text',
	'application/vnd.oasis.opendocument.spreadsheet',
	'application/vnd.oasis.opendocument.presentation',
	'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
	'application/vnd.openxmlformats-officedocument.presentationml.presentation',
	'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
	'application/zip',
	'application/x-tar',
	'application/x-rar-compressed',
	'application/gzip',
	'application/x-bzip2',
	'application/x-7z-compressed',
	'application/x-apple-diskimage',
	'application/x-apache-arrow',
	'video/mp4',
	'audio/midi',
	'video/x-matroska',
	'video/webm',
	'video/quicktime',
	'video/vnd.avi',
	'audio/wav',
	'audio/qcelp',
	'audio/x-ms-asf',
	'video/x-ms-asf',
	'application/vnd.ms-asf',
	'video/mpeg',
	'video/3gpp',
	'audio/mpeg',
	'audio/mp4', // RFC 4337
	'video/ogg',
	'audio/ogg',
	'audio/ogg; codecs=opus',
	'application/ogg',
	'audio/x-flac',
	'audio/ape',
	'audio/wavpack',
	'audio/amr',
	'application/pdf',
	'application/x-elf',
	'application/x-mach-binary',
	'application/x-msdownload',
	'application/x-shockwave-flash',
	'application/rtf',
	'application/wasm',
	'font/woff',
	'font/woff2',
	'application/vnd.ms-fontobject',
	'font/ttf',
	'font/otf',
	'image/x-icon',
	'video/x-flv',
	'application/postscript',
	'application/eps',
	'application/x-xz',
	'application/x-sqlite3',
	'application/x-nintendo-nes-rom',
	'application/x-google-chrome-extension',
	'application/vnd.ms-cab-compressed',
	'application/x-deb',
	'application/x-unix-archive',
	'application/x-rpm',
	'application/x-compress',
	'application/x-lzip',
	'application/x-cfb',
	'application/x-mie',
	'application/mxf',
	'video/mp2t',
	'application/x-blender',
	'image/bpg',
	'image/j2c',
	'image/jp2',
	'image/jpx',
	'image/jpm',
	'image/mj2',
	'audio/aiff',
	'application/xml',
	'application/x-mobipocket-ebook',
	'image/heif',
	'image/heif-sequence',
	'image/heic',
	'image/heic-sequence',
	'image/icns',
	'image/ktx',
	'application/dicom',
	'audio/x-musepack',
	'text/calendar',
	'text/vcard',
	'text/vtt',
	'model/gltf-binary',
	'application/vnd.tcpdump.pcap',
	'audio/x-dsf', // Non-standard
	'application/x.ms.shortcut', // Invented by us
	'application/x.apple.alias', // Invented by us
	'audio/x-voc',
	'audio/vnd.dolby.dd-raw',
	'audio/x-m4a',
	'image/apng',
	'image/x-olympus-orf',
	'image/x-sony-arw',
	'image/x-adobe-dng',
	'image/x-nikon-nef',
	'image/x-panasonic-rw2',
	'image/x-fujifilm-raf',
	'video/x-m4v',
	'video/3gpp2',
	'application/x-esri-shape',
	'audio/aac',
	'audio/x-it',
	'audio/x-s3m',
	'audio/x-xm',
	'video/MP1S',
	'video/MP2P',
	'application/vnd.sketchup.skp',
	'image/avif',
	'application/x-lzh-compressed',
	'application/pgp-encrypted',
	'application/x-asar',
	'model/stl',
	'application/vnd.ms-htmlhelp',
	'model/3mf',
	'image/jxl',
	'application/zstd',
	'image/jls',
	'application/vnd.ms-outlook',
	'image/vnd.dwg',
	'application/x-parquet',
	'application/java-vm',
	'application/x-arj',
	'application/x-cpio',
	'application/x-ace-compressed',
	'application/avro',
	'application/vnd.iccprofile',
	'application/x.autodesk.fbx', // Invented by us
	'application/vnd.visio',
	'application/vnd.android.package-archive',
];

/**
Primary entry point, Node.js specific entry point is index.js
*/


const reasonableDetectionSizeInBytes = 4100; // A fair amount of file-types are detectable within this range.

function _check(buffer, headers, options) {
	options = {
		offset: 0,
		...options,
	};

	for (const [index, header] of headers.entries()) {
		// If a bitmask is set
		if (options.mask) {
			// If header doesn't equal `buf` with bits masked off
			if (header !== (options.mask[index] & buffer[index + options.offset])) {
				return false;
			}
		} else if (header !== buffer[index + options.offset]) {
			return false;
		}
	}

	return true;
}

class FileTypeParser {
	constructor(options) {
		this.detectors = options?.customDetectors;
		this.tokenizerOptions = {
			abortSignal: options?.signal,
		};
		this.fromTokenizer = this.fromTokenizer.bind(this);
		this.fromBuffer = this.fromBuffer.bind(this);
		this.parse = this.parse.bind(this);
	}

	async fromTokenizer(tokenizer) {
		const initialPosition = tokenizer.position;

		for (const detector of this.detectors || []) {
			const fileType = await detector(tokenizer);
			if (fileType) {
				return fileType;
			}

			if (initialPosition !== tokenizer.position) {
				return undefined; // Cannot proceed scanning of the tokenizer is at an arbitrary position
			}
		}

		return this.parse(tokenizer);
	}

	async fromBuffer(input) {
		if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
			throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
		}

		const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);

		if (!(buffer?.length > 1)) {
			return;
		}

		return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
	}

	async fromBlob(blob) {
		return this.fromStream(blob.stream());
	}

	async fromStream(stream) {
		const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
		try {
			return await this.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async toDetectionStream(stream, options) {
		const {sampleSize = reasonableDetectionSizeInBytes} = options;
		let detectedFileType;
		let firstChunk;

		const reader = stream.getReader({mode: 'byob'});
		try {
			// Read the first chunk from the stream
			const {value: chunk, done} = await reader.read(new Uint8Array(sampleSize));
			firstChunk = chunk;
			if (!done && chunk) {
				try {
					// Attempt to detect the file type from the chunk
					detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
				} catch (error) {
					if (!(error instanceof EndOfStreamError)) {
						throw error; // Re-throw non-EndOfStreamError
					}

					detectedFileType = undefined;
				}
			}

			firstChunk = chunk;
		} finally {
			reader.releaseLock(); // Ensure the reader is released
		}

		// Create a new ReadableStream to manage locking issues
		const transformStream = new TransformStream({
			async start(controller) {
				controller.enqueue(firstChunk); // Enqueue the initial chunk
			},
			transform(chunk, controller) {
				// Pass through the chunks without modification
				controller.enqueue(chunk);
			},
		});

		const newStream = stream.pipeThrough(transformStream);
		newStream.fileType = detectedFileType;

		return newStream;
	}

	check(header, options) {
		return _check(this.buffer, header, options);
	}

	checkString(header, options) {
		return this.check(stringToBytes(header), options);
	}

	async parse(tokenizer) {
		this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);

		// Keep reading until EOF if the file size is unknown.
		if (tokenizer.fileInfo.size === undefined) {
			tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
		}

		this.tokenizer = tokenizer;

		await tokenizer.peekBuffer(this.buffer, {length: 12, mayBeLess: true});

		// -- 2-byte signatures --

		if (this.check([0x42, 0x4D])) {
			return {
				ext: 'bmp',
				mime: 'image/bmp',
			};
		}

		if (this.check([0x0B, 0x77])) {
			return {
				ext: 'ac3',
				mime: 'audio/vnd.dolby.dd-raw',
			};
		}

		if (this.check([0x78, 0x01])) {
			return {
				ext: 'dmg',
				mime: 'application/x-apple-diskimage',
			};
		}

		if (this.check([0x4D, 0x5A])) {
			return {
				ext: 'exe',
				mime: 'application/x-msdownload',
			};
		}

		if (this.check([0x25, 0x21])) {
			await tokenizer.peekBuffer(this.buffer, {length: 24, mayBeLess: true});

			if (
				this.checkString('PS-Adobe-', {offset: 2})
				&& this.checkString(' EPSF-', {offset: 14})
			) {
				return {
					ext: 'eps',
					mime: 'application/eps',
				};
			}

			return {
				ext: 'ps',
				mime: 'application/postscript',
			};
		}

		if (
			this.check([0x1F, 0xA0])
			|| this.check([0x1F, 0x9D])
		) {
			return {
				ext: 'Z',
				mime: 'application/x-compress',
			};
		}

		if (this.check([0xC7, 0x71])) {
			return {
				ext: 'cpio',
				mime: 'application/x-cpio',
			};
		}

		if (this.check([0x60, 0xEA])) {
			return {
				ext: 'arj',
				mime: 'application/x-arj',
			};
		}

		// -- 3-byte signatures --

		if (this.check([0xEF, 0xBB, 0xBF])) { // UTF-8-BOM
			// Strip off UTF-8-BOM
			this.tokenizer.ignore(3);
			return this.parse(tokenizer);
		}

		if (this.check([0x47, 0x49, 0x46])) {
			return {
				ext: 'gif',
				mime: 'image/gif',
			};
		}

		if (this.check([0x49, 0x49, 0xBC])) {
			return {
				ext: 'jxr',
				mime: 'image/vnd.ms-photo',
			};
		}

		if (this.check([0x1F, 0x8B, 0x8])) {
			return {
				ext: 'gz',
				mime: 'application/gzip',
			};
		}

		if (this.check([0x42, 0x5A, 0x68])) {
			return {
				ext: 'bz2',
				mime: 'application/x-bzip2',
			};
		}

		if (this.checkString('ID3')) {
			await tokenizer.ignore(6); // Skip ID3 header until the header size
			const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
			if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
				// Guess file type based on ID3 header for backward compatibility
				return {
					ext: 'mp3',
					mime: 'audio/mpeg',
				};
			}

			await tokenizer.ignore(id3HeaderLength);
			return this.fromTokenizer(tokenizer); // Skip ID3 header, recursion
		}

		// Musepack, SV7
		if (this.checkString('MP+')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack',
			};
		}

		if (
			(this.buffer[0] === 0x43 || this.buffer[0] === 0x46)
			&& this.check([0x57, 0x53], {offset: 1})
		) {
			return {
				ext: 'swf',
				mime: 'application/x-shockwave-flash',
			};
		}

		// -- 4-byte signatures --

		// Requires a sample size of 4 bytes
		if (this.check([0xFF, 0xD8, 0xFF])) {
			if (this.check([0xF7], {offset: 3})) { // JPG7/SOF55, indicating a ISO/IEC 14495 / JPEG-LS file
				return {
					ext: 'jls',
					mime: 'image/jls',
				};
			}

			return {
				ext: 'jpg',
				mime: 'image/jpeg',
			};
		}

		if (this.check([0x4F, 0x62, 0x6A, 0x01])) {
			return {
				ext: 'avro',
				mime: 'application/avro',
			};
		}

		if (this.checkString('FLIF')) {
			return {
				ext: 'flif',
				mime: 'image/flif',
			};
		}

		if (this.checkString('8BPS')) {
			return {
				ext: 'psd',
				mime: 'image/vnd.adobe.photoshop',
			};
		}

		if (this.checkString('WEBP', {offset: 8})) {
			return {
				ext: 'webp',
				mime: 'image/webp',
			};
		}

		// Musepack, SV8
		if (this.checkString('MPCK')) {
			return {
				ext: 'mpc',
				mime: 'audio/x-musepack',
			};
		}

		if (this.checkString('FORM')) {
			return {
				ext: 'aif',
				mime: 'audio/aiff',
			};
		}

		if (this.checkString('icns', {offset: 0})) {
			return {
				ext: 'icns',
				mime: 'image/icns',
			};
		}

		// Zip-based file formats
		// Need to be before the `zip` check
		if (this.check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature
			try {
				while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
					await tokenizer.readBuffer(this.buffer, {length: 30});

					const view = new DataView(this.buffer.buffer);

					// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers
					const zipHeader = {
						compressedSize: view.getUint32(18, true),
						uncompressedSize: view.getUint32(22, true),
						filenameLength: view.getUint16(26, true),
						extraFieldLength: view.getUint16(28, true),
					};

					zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, 'utf-8'));
					await tokenizer.ignore(zipHeader.extraFieldLength);

					if (/classes\d*\.dex/.test(zipHeader.filename)) {
						return {
							ext: 'apk',
							mime: 'application/vnd.android.package-archive',
						};
					}

					// Assumes signed `.xpi` from addons.mozilla.org
					if (zipHeader.filename === 'META-INF/mozilla.rsa') {
						return {
							ext: 'xpi',
							mime: 'application/x-xpinstall',
						};
					}

					if (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {
						const type = zipHeader.filename.split('/')[0];
						switch (type) {
							case '_rels':
								break;
							case 'word':
								return {
									ext: 'docx',
									mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
								};
							case 'ppt':
								return {
									ext: 'pptx',
									mime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
								};
							case 'xl':
								return {
									ext: 'xlsx',
									mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
								};
							case 'visio':
								return {
									ext: 'vsdx',
									mime: 'application/vnd.visio',
								};
							default:
								break;
						}
					}

					if (zipHeader.filename.startsWith('xl/')) {
						return {
							ext: 'xlsx',
							mime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
						};
					}

					if (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {
						return {
							ext: '3mf',
							mime: 'model/3mf',
						};
					}

					// The docx, xlsx and pptx file types extend the Office Open XML file format:
					// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats
					// We look for:
					// - one entry named '[Content_Types].xml' or '_rels/.rels',
					// - one entry indicating specific type of file.
					// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.
					if (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {
						let mimeType = await tokenizer.readToken(new StringType(zipHeader.compressedSize, 'utf-8'));
						mimeType = mimeType.trim();

						switch (mimeType) {
							case 'application/epub+zip':
								return {
									ext: 'epub',
									mime: 'application/epub+zip',
								};
							case 'application/vnd.oasis.opendocument.text':
								return {
									ext: 'odt',
									mime: 'application/vnd.oasis.opendocument.text',
								};
							case 'application/vnd.oasis.opendocument.spreadsheet':
								return {
									ext: 'ods',
									mime: 'application/vnd.oasis.opendocument.spreadsheet',
								};
							case 'application/vnd.oasis.opendocument.presentation':
								return {
									ext: 'odp',
									mime: 'application/vnd.oasis.opendocument.presentation',
								};
							default:
						}
					}

					// Try to find next header manually when current one is corrupted
					if (zipHeader.compressedSize === 0) {
						let nextHeaderIndex = -1;

						while (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {
							await tokenizer.peekBuffer(this.buffer, {mayBeLess: true});

							nextHeaderIndex = indexOf(this.buffer, new Uint8Array([0x50, 0x4B, 0x03, 0x04]));

							// Move position to the next header if found, skip the whole buffer otherwise
							await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
						}
					} else {
						await tokenizer.ignore(zipHeader.compressedSize);
					}
				}
			} catch (error) {
				if (!(error instanceof EndOfStreamError)) {
					throw error;
				}
			}

			return {
				ext: 'zip',
				mime: 'application/zip',
			};
		}

		if (this.checkString('OggS')) {
			// This is an OGG container
			await tokenizer.ignore(28);
			const type = new Uint8Array(8);
			await tokenizer.readBuffer(type);

			// Needs to be before `ogg` check
			if (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {
				return {
					ext: 'opus',
					mime: 'audio/ogg; codecs=opus',
				};
			}

			// If ' theora' in header.
			if (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {
				return {
					ext: 'ogv',
					mime: 'video/ogg',
				};
			}

			// If '\x01video' in header.
			if (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {
				return {
					ext: 'ogm',
					mime: 'video/ogg',
				};
			}

			// If ' FLAC' in header  https://xiph.org/flac/faq.html
			if (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {
				return {
					ext: 'oga',
					mime: 'audio/ogg',
				};
			}

			// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex
			if (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {
				return {
					ext: 'spx',
					mime: 'audio/ogg',
				};
			}

			// If '\x01vorbis' in header
			if (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {
				return {
					ext: 'ogg',
					mime: 'audio/ogg',
				};
			}

			// Default OGG container https://www.iana.org/assignments/media-types/application/ogg
			return {
				ext: 'ogx',
				mime: 'application/ogg',
			};
		}

		if (
			this.check([0x50, 0x4B])
			&& (this.buffer[2] === 0x3 || this.buffer[2] === 0x5 || this.buffer[2] === 0x7)
			&& (this.buffer[3] === 0x4 || this.buffer[3] === 0x6 || this.buffer[3] === 0x8)
		) {
			return {
				ext: 'zip',
				mime: 'application/zip',
			};
		}

		//

		// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)
		// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.
		// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.
		// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).
		if (
			this.checkString('ftyp', {offset: 4})
			&& (this.buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?
		) {
			// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.
			// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.
			const brandMajor = new StringType(4, 'latin1').get(this.buffer, 8).replace('\0', ' ').trim();
			switch (brandMajor) {
				case 'avif':
				case 'avis':
					return {ext: 'avif', mime: 'image/avif'};
				case 'mif1':
					return {ext: 'heic', mime: 'image/heif'};
				case 'msf1':
					return {ext: 'heic', mime: 'image/heif-sequence'};
				case 'heic':
				case 'heix':
					return {ext: 'heic', mime: 'image/heic'};
				case 'hevc':
				case 'hevx':
					return {ext: 'heic', mime: 'image/heic-sequence'};
				case 'qt':
					return {ext: 'mov', mime: 'video/quicktime'};
				case 'M4V':
				case 'M4VH':
				case 'M4VP':
					return {ext: 'm4v', mime: 'video/x-m4v'};
				case 'M4P':
					return {ext: 'm4p', mime: 'video/mp4'};
				case 'M4B':
					return {ext: 'm4b', mime: 'audio/mp4'};
				case 'M4A':
					return {ext: 'm4a', mime: 'audio/x-m4a'};
				case 'F4V':
					return {ext: 'f4v', mime: 'video/mp4'};
				case 'F4P':
					return {ext: 'f4p', mime: 'video/mp4'};
				case 'F4A':
					return {ext: 'f4a', mime: 'audio/mp4'};
				case 'F4B':
					return {ext: 'f4b', mime: 'audio/mp4'};
				case 'crx':
					return {ext: 'cr3', mime: 'image/x-canon-cr3'};
				default:
					if (brandMajor.startsWith('3g')) {
						if (brandMajor.startsWith('3g2')) {
							return {ext: '3g2', mime: 'video/3gpp2'};
						}

						return {ext: '3gp', mime: 'video/3gpp'};
					}

					return {ext: 'mp4', mime: 'video/mp4'};
			}
		}

		if (this.checkString('MThd')) {
			return {
				ext: 'mid',
				mime: 'audio/midi',
			};
		}

		if (
			this.checkString('wOFF')
			&& (
				this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
				|| this.checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff',
				mime: 'font/woff',
			};
		}

		if (
			this.checkString('wOF2')
			&& (
				this.check([0x00, 0x01, 0x00, 0x00], {offset: 4})
				|| this.checkString('OTTO', {offset: 4})
			)
		) {
			return {
				ext: 'woff2',
				mime: 'font/woff2',
			};
		}

		if (this.check([0xD4, 0xC3, 0xB2, 0xA1]) || this.check([0xA1, 0xB2, 0xC3, 0xD4])) {
			return {
				ext: 'pcap',
				mime: 'application/vnd.tcpdump.pcap',
			};
		}

		// Sony DSD Stream File (DSF)
		if (this.checkString('DSD ')) {
			return {
				ext: 'dsf',
				mime: 'audio/x-dsf', // Non-standard
			};
		}

		if (this.checkString('LZIP')) {
			return {
				ext: 'lz',
				mime: 'application/x-lzip',
			};
		}

		if (this.checkString('fLaC')) {
			return {
				ext: 'flac',
				mime: 'audio/x-flac',
			};
		}

		if (this.check([0x42, 0x50, 0x47, 0xFB])) {
			return {
				ext: 'bpg',
				mime: 'image/bpg',
			};
		}

		if (this.checkString('wvpk')) {
			return {
				ext: 'wv',
				mime: 'audio/wavpack',
			};
		}

		if (this.checkString('%PDF')) {
			try {
				await tokenizer.ignore(1350);
				const maxBufferSize = 10 * 1024 * 1024;
				const buffer = new Uint8Array(Math.min(maxBufferSize, tokenizer.fileInfo.size));
				await tokenizer.readBuffer(buffer, {mayBeLess: true});

				// Check if this is an Adobe Illustrator file
				if (includes(buffer, new TextEncoder().encode('AIPrivateData'))) {
					return {
						ext: 'ai',
						mime: 'application/postscript',
					};
				}
			} catch (error) {
				// Swallow end of stream error if file is too small for the Adobe AI check
				if (!(error instanceof EndOfStreamError)) {
					throw error;
				}
			}

			// Assume this is just a normal PDF
			return {
				ext: 'pdf',
				mime: 'application/pdf',
			};
		}

		if (this.check([0x00, 0x61, 0x73, 0x6D])) {
			return {
				ext: 'wasm',
				mime: 'application/wasm',
			};
		}

		// TIFF, little-endian type
		if (this.check([0x49, 0x49])) {
			const fileType = await this.readTiffHeader(false);
			if (fileType) {
				return fileType;
			}
		}

		// TIFF, big-endian type
		if (this.check([0x4D, 0x4D])) {
			const fileType = await this.readTiffHeader(true);
			if (fileType) {
				return fileType;
			}
		}

		if (this.checkString('MAC ')) {
			return {
				ext: 'ape',
				mime: 'audio/ape',
			};
		}

		// https://github.com/file/file/blob/master/magic/Magdir/matroska
		if (this.check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML
			async function readField() {
				const msb = await tokenizer.peekNumber(UINT8);
				let mask = 0x80;
				let ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D

				while ((msb & mask) === 0 && mask !== 0) {
					++ic;
					mask >>= 1;
				}

				const id = new Uint8Array(ic + 1);
				await tokenizer.readBuffer(id);
				return id;
			}

			async function readElement() {
				const idField = await readField();
				const lengthField = await readField();

				lengthField[0] ^= 0x80 >> (lengthField.length - 1);
				const nrLength = Math.min(6, lengthField.length); // JavaScript can max read 6 bytes integer

				const idView = new DataView(idField.buffer);
				const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);

				return {
					id: getUintBE(idView),
					len: getUintBE(lengthView),
				};
			}

			async function readChildren(children) {
				while (children > 0) {
					const element = await readElement();
					if (element.id === 0x42_82) {
						const rawValue = await tokenizer.readToken(new StringType(element.len));
						return rawValue.replaceAll(/\00.*$/g, ''); // Return DocType
					}

					await tokenizer.ignore(element.len); // ignore payload
					--children;
				}
			}

			const re = await readElement();
			const docType = await readChildren(re.len);

			switch (docType) {
				case 'webm':
					return {
						ext: 'webm',
						mime: 'video/webm',
					};

				case 'matroska':
					return {
						ext: 'mkv',
						mime: 'video/x-matroska',
					};

				default:
					return;
			}
		}

		// RIFF file format which might be AVI, WAV, QCP, etc
		if (this.check([0x52, 0x49, 0x46, 0x46])) {
			if (this.check([0x41, 0x56, 0x49], {offset: 8})) {
				return {
					ext: 'avi',
					mime: 'video/vnd.avi',
				};
			}

			if (this.check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {
				return {
					ext: 'wav',
					mime: 'audio/wav',
				};
			}

			// QLCM, QCP file
			if (this.check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {
				return {
					ext: 'qcp',
					mime: 'audio/qcelp',
				};
			}
		}

		if (this.checkString('SQLi')) {
			return {
				ext: 'sqlite',
				mime: 'application/x-sqlite3',
			};
		}

		if (this.check([0x4E, 0x45, 0x53, 0x1A])) {
			return {
				ext: 'nes',
				mime: 'application/x-nintendo-nes-rom',
			};
		}

		if (this.checkString('Cr24')) {
			return {
				ext: 'crx',
				mime: 'application/x-google-chrome-extension',
			};
		}

		if (
			this.checkString('MSCF')
			|| this.checkString('ISc(')
		) {
			return {
				ext: 'cab',
				mime: 'application/vnd.ms-cab-compressed',
			};
		}

		if (this.check([0xED, 0xAB, 0xEE, 0xDB])) {
			return {
				ext: 'rpm',
				mime: 'application/x-rpm',
			};
		}

		if (this.check([0xC5, 0xD0, 0xD3, 0xC6])) {
			return {
				ext: 'eps',
				mime: 'application/eps',
			};
		}

		if (this.check([0x28, 0xB5, 0x2F, 0xFD])) {
			return {
				ext: 'zst',
				mime: 'application/zstd',
			};
		}

		if (this.check([0x7F, 0x45, 0x4C, 0x46])) {
			return {
				ext: 'elf',
				mime: 'application/x-elf',
			};
		}

		if (this.check([0x21, 0x42, 0x44, 0x4E])) {
			return {
				ext: 'pst',
				mime: 'application/vnd.ms-outlook',
			};
		}

		if (this.checkString('PAR1')) {
			return {
				ext: 'parquet',
				mime: 'application/x-parquet',
			};
		}

		if (this.check([0xCF, 0xFA, 0xED, 0xFE])) {
			return {
				ext: 'macho',
				mime: 'application/x-mach-binary',
			};
		}

		// -- 5-byte signatures --

		if (this.check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {
			return {
				ext: 'otf',
				mime: 'font/otf',
			};
		}

		if (this.checkString('#!AMR')) {
			return {
				ext: 'amr',
				mime: 'audio/amr',
			};
		}

		if (this.checkString('{\\rtf')) {
			return {
				ext: 'rtf',
				mime: 'application/rtf',
			};
		}

		if (this.check([0x46, 0x4C, 0x56, 0x01])) {
			return {
				ext: 'flv',
				mime: 'video/x-flv',
			};
		}

		if (this.checkString('IMPM')) {
			return {
				ext: 'it',
				mime: 'audio/x-it',
			};
		}

		if (
			this.checkString('-lh0-', {offset: 2})
			|| this.checkString('-lh1-', {offset: 2})
			|| this.checkString('-lh2-', {offset: 2})
			|| this.checkString('-lh3-', {offset: 2})
			|| this.checkString('-lh4-', {offset: 2})
			|| this.checkString('-lh5-', {offset: 2})
			|| this.checkString('-lh6-', {offset: 2})
			|| this.checkString('-lh7-', {offset: 2})
			|| this.checkString('-lzs-', {offset: 2})
			|| this.checkString('-lz4-', {offset: 2})
			|| this.checkString('-lz5-', {offset: 2})
			|| this.checkString('-lhd-', {offset: 2})
		) {
			return {
				ext: 'lzh',
				mime: 'application/x-lzh-compressed',
			};
		}

		// MPEG program stream (PS or MPEG-PS)
		if (this.check([0x00, 0x00, 0x01, 0xBA])) {
			//  MPEG-PS, MPEG-1 Part 1
			if (this.check([0x21], {offset: 4, mask: [0xF1]})) {
				return {
					ext: 'mpg', // May also be .ps, .mpeg
					mime: 'video/MP1S',
				};
			}

			// MPEG-PS, MPEG-2 Part 1
			if (this.check([0x44], {offset: 4, mask: [0xC4]})) {
				return {
					ext: 'mpg', // May also be .mpg, .m2p, .vob or .sub
					mime: 'video/MP2P',
				};
			}
		}

		if (this.checkString('ITSF')) {
			return {
				ext: 'chm',
				mime: 'application/vnd.ms-htmlhelp',
			};
		}

		if (this.check([0xCA, 0xFE, 0xBA, 0xBE])) {
			return {
				ext: 'class',
				mime: 'application/java-vm',
			};
		}

		// -- 6-byte signatures --

		if (this.check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {
			return {
				ext: 'xz',
				mime: 'application/x-xz',
			};
		}

		if (this.checkString('<?xml ')) {
			return {
				ext: 'xml',
				mime: 'application/xml',
			};
		}

		if (this.check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {
			return {
				ext: '7z',
				mime: 'application/x-7z-compressed',
			};
		}

		if (
			this.check([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7])
			&& (this.buffer[6] === 0x0 || this.buffer[6] === 0x1)
		) {
			return {
				ext: 'rar',
				mime: 'application/x-rar-compressed',
			};
		}

		if (this.checkString('solid ')) {
			return {
				ext: 'stl',
				mime: 'model/stl',
			};
		}

		if (this.checkString('AC')) {
			const version = new StringType(4, 'latin1').get(this.buffer, 2);
			if (version.match('^d*') && version >= 1000 && version <= 1050) {
				return {
					ext: 'dwg',
					mime: 'image/vnd.dwg',
				};
			}
		}

		if (this.checkString('070707')) {
			return {
				ext: 'cpio',
				mime: 'application/x-cpio',
			};
		}

		// -- 7-byte signatures --

		if (this.checkString('BLENDER')) {
			return {
				ext: 'blend',
				mime: 'application/x-blender',
			};
		}

		if (this.checkString('!<arch>')) {
			await tokenizer.ignore(8);
			const string = await tokenizer.readToken(new StringType(13, 'ascii'));
			if (string === 'debian-binary') {
				return {
					ext: 'deb',
					mime: 'application/x-deb',
				};
			}

			return {
				ext: 'ar',
				mime: 'application/x-unix-archive',
			};
		}

		if (
			this.checkString('WEBVTT')
			&&	(
				// One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
				(['\n', '\r', '\t', ' ', '\0'].some(char7 => this.checkString(char7, {offset: 6}))))
		) {
			return {
				ext: 'vtt',
				mime: 'text/vtt',
			};
		}

		// -- 8-byte signatures --

		if (this.check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
			// APNG format (https://wiki.mozilla.org/APNG_Specification)
			// 1. Find the first IDAT (image data) chunk (49 44 41 54)
			// 2. Check if there is an "acTL" chunk before the IDAT one (61 63 54 4C)

			// Offset calculated as follows:
			// - 8 bytes: PNG signature
			// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk

			await tokenizer.ignore(8); // ignore PNG signature

			async function readChunkHeader() {
				return {
					length: await tokenizer.readToken(INT32_BE),
					type: await tokenizer.readToken(new StringType(4, 'latin1')),
				};
			}

			do {
				const chunk = await readChunkHeader();
				if (chunk.length < 0) {
					return; // Invalid chunk length
				}

				switch (chunk.type) {
					case 'IDAT':
						return {
							ext: 'png',
							mime: 'image/png',
						};
					case 'acTL':
						return {
							ext: 'apng',
							mime: 'image/apng',
						};
					default:
						await tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC
				}
			} while (tokenizer.position + 8 < tokenizer.fileInfo.size);

			return {
				ext: 'png',
				mime: 'image/png',
			};
		}

		if (this.check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {
			return {
				ext: 'arrow',
				mime: 'application/x-apache-arrow',
			};
		}

		if (this.check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {
			return {
				ext: 'glb',
				mime: 'model/gltf-binary',
			};
		}

		// `mov` format variants
		if (
			this.check([0x66, 0x72, 0x65, 0x65], {offset: 4}) // `free`
			|| this.check([0x6D, 0x64, 0x61, 0x74], {offset: 4}) // `mdat` MJPEG
			|| this.check([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) // `moov`
			|| this.check([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`
		) {
			return {
				ext: 'mov',
				mime: 'video/quicktime',
			};
		}

		// -- 9-byte signatures --

		if (this.check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {
			return {
				ext: 'orf',
				mime: 'image/x-olympus-orf',
			};
		}

		if (this.checkString('gimp xcf ')) {
			return {
				ext: 'xcf',
				mime: 'image/x-xcf',
			};
		}

		// -- 12-byte signatures --

		if (this.check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {
			return {
				ext: 'rw2',
				mime: 'image/x-panasonic-rw2',
			};
		}

		// ASF_Header_Object first 80 bytes
		if (this.check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {
			async function readHeader() {
				const guid = new Uint8Array(16);
				await tokenizer.readBuffer(guid);
				return {
					id: guid,
					size: Number(await tokenizer.readToken(UINT64_LE)),
				};
			}

			await tokenizer.ignore(30);
			// Search for header should be in first 1KB of file.
			while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
				const header = await readHeader();
				let payload = header.size - 24;
				if (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {
					// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)
					const typeId = new Uint8Array(16);
					payload -= await tokenizer.readBuffer(typeId);

					if (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found audio:
						return {
							ext: 'asf',
							mime: 'audio/x-ms-asf',
						};
					}

					if (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {
						// Found video:
						return {
							ext: 'asf',
							mime: 'video/x-ms-asf',
						};
					}

					break;
				}

				await tokenizer.ignore(payload);
			}

			// Default to ASF generic extension
			return {
				ext: 'asf',
				mime: 'application/vnd.ms-asf',
			};
		}

		if (this.check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {
			return {
				ext: 'ktx',
				mime: 'image/ktx',
			};
		}

		if ((this.check([0x7E, 0x10, 0x04]) || this.check([0x7E, 0x18, 0x04])) && this.check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {
			return {
				ext: 'mie',
				mime: 'application/x-mie',
			};
		}

		if (this.check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {
			return {
				ext: 'shp',
				mime: 'application/x-esri-shape',
			};
		}

		if (this.check([0xFF, 0x4F, 0xFF, 0x51])) {
			return {
				ext: 'j2c',
				mime: 'image/j2c',
			};
		}

		if (this.check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {
			// JPEG-2000 family

			await tokenizer.ignore(20);
			const type = await tokenizer.readToken(new StringType(4, 'ascii'));
			switch (type) {
				case 'jp2 ':
					return {
						ext: 'jp2',
						mime: 'image/jp2',
					};
				case 'jpx ':
					return {
						ext: 'jpx',
						mime: 'image/jpx',
					};
				case 'jpm ':
					return {
						ext: 'jpm',
						mime: 'image/jpm',
					};
				case 'mjp2':
					return {
						ext: 'mj2',
						mime: 'image/mj2',
					};
				default:
					return;
			}
		}

		if (
			this.check([0xFF, 0x0A])
			|| this.check([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])
		) {
			return {
				ext: 'jxl',
				mime: 'image/jxl',
			};
		}

		if (this.check([0xFE, 0xFF])) { // UTF-16-BOM-LE
			if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], {offset: 2})) {
				return {
					ext: 'xml',
					mime: 'application/xml',
				};
			}

			return undefined; // Some unknown text based format
		}

		// -- Unsafe signatures --

		if (
			this.check([0x0, 0x0, 0x1, 0xBA])
			|| this.check([0x0, 0x0, 0x1, 0xB3])
		) {
			return {
				ext: 'mpg',
				mime: 'video/mpeg',
			};
		}

		if (this.check([0x00, 0x01, 0x00, 0x00, 0x00])) {
			return {
				ext: 'ttf',
				mime: 'font/ttf',
			};
		}

		if (this.check([0x00, 0x00, 0x01, 0x00])) {
			return {
				ext: 'ico',
				mime: 'image/x-icon',
			};
		}

		if (this.check([0x00, 0x00, 0x02, 0x00])) {
			return {
				ext: 'cur',
				mime: 'image/x-icon',
			};
		}

		if (this.check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {
			// Detected Microsoft Compound File Binary File (MS-CFB) Format.
			return {
				ext: 'cfb',
				mime: 'application/x-cfb',
			};
		}

		// Increase sample size from 12 to 256.
		await tokenizer.peekBuffer(this.buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});

		if (this.check([0x61, 0x63, 0x73, 0x70], {offset: 36})) {
			return {
				ext: 'icc',
				mime: 'application/vnd.iccprofile',
			};
		}

		// ACE: requires 14 bytes in the buffer
		if (this.checkString('**ACE', {offset: 7}) && this.checkString('**', {offset: 12})) {
			return {
				ext: 'ace',
				mime: 'application/x-ace-compressed',
			};
		}

		// -- 15-byte signatures --

		if (this.checkString('BEGIN:')) {
			if (this.checkString('VCARD', {offset: 6})) {
				return {
					ext: 'vcf',
					mime: 'text/vcard',
				};
			}

			if (this.checkString('VCALENDAR', {offset: 6})) {
				return {
					ext: 'ics',
					mime: 'text/calendar',
				};
			}
		}

		// `raf` is here just to keep all the raw image detectors together.
		if (this.checkString('FUJIFILMCCD-RAW')) {
			return {
				ext: 'raf',
				mime: 'image/x-fujifilm-raf',
			};
		}

		if (this.checkString('Extended Module:')) {
			return {
				ext: 'xm',
				mime: 'audio/x-xm',
			};
		}

		if (this.checkString('Creative Voice File')) {
			return {
				ext: 'voc',
				mime: 'audio/x-voc',
			};
		}

		if (this.check([0x04, 0x00, 0x00, 0x00]) && this.buffer.length >= 16) { // Rough & quick check Pickle/ASAR
			const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);

			if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
				try {
					const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
					const json = JSON.parse(header);
					// Check if Pickle is ASAR
					if (json.files) { // Final check, assuring Pickle/ASAR format
						return {
							ext: 'asar',
							mime: 'application/x-asar',
						};
					}
				} catch {}
			}
		}

		if (this.check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {
			return {
				ext: 'mxf',
				mime: 'application/mxf',
			};
		}

		if (this.checkString('SCRM', {offset: 44})) {
			return {
				ext: 's3m',
				mime: 'audio/x-s3m',
			};
		}

		// Raw MPEG-2 transport stream (188-byte packets)
		if (this.check([0x47]) && this.check([0x47], {offset: 188})) {
			return {
				ext: 'mts',
				mime: 'video/mp2t',
			};
		}

		// Blu-ray Disc Audio-Video (BDAV) MPEG-2 transport stream has 4-byte TP_extra_header before each 188-byte packet
		if (this.check([0x47], {offset: 4}) && this.check([0x47], {offset: 196})) {
			return {
				ext: 'mts',
				mime: 'video/mp2t',
			};
		}

		if (this.check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {
			return {
				ext: 'mobi',
				mime: 'application/x-mobipocket-ebook',
			};
		}

		if (this.check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {
			return {
				ext: 'dcm',
				mime: 'application/dicom',
			};
		}

		if (this.check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {
			return {
				ext: 'lnk',
				mime: 'application/x.ms.shortcut', // Invented by us
			};
		}

		if (this.check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {
			return {
				ext: 'alias',
				mime: 'application/x.apple.alias', // Invented by us
			};
		}

		if (this.checkString('Kaydara FBX Binary  \u0000')) {
			return {
				ext: 'fbx',
				mime: 'application/x.autodesk.fbx', // Invented by us
			};
		}

		if (
			this.check([0x4C, 0x50], {offset: 34})
			&& (
				this.check([0x00, 0x00, 0x01], {offset: 8})
				|| this.check([0x01, 0x00, 0x02], {offset: 8})
				|| this.check([0x02, 0x00, 0x02], {offset: 8})
			)
		) {
			return {
				ext: 'eot',
				mime: 'application/vnd.ms-fontobject',
			};
		}

		if (this.check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {
			return {
				ext: 'indd',
				mime: 'application/x-indesign',
			};
		}

		// Increase sample size from 256 to 512
		await tokenizer.peekBuffer(this.buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});

		// Requires a buffer size of 512 bytes
		if (tarHeaderChecksumMatches(this.buffer)) {
			return {
				ext: 'tar',
				mime: 'application/x-tar',
			};
		}

		if (this.check([0xFF, 0xFE])) { // UTF-16-BOM-BE
			if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], {offset: 2})) {
				return {
					ext: 'xml',
					mime: 'application/xml',
				};
			}

			if (this.check([0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00], {offset: 2})) {
				return {
					ext: 'skp',
					mime: 'application/vnd.sketchup.skp',
				};
			}

			return undefined; // Some text based format
		}

		if (this.checkString('-----BEGIN PGP MESSAGE-----')) {
			return {
				ext: 'pgp',
				mime: 'application/pgp-encrypted',
			};
		}

		// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)
		if (this.buffer.length >= 2 && this.check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {
			if (this.check([0x10], {offset: 1, mask: [0x16]})) {
				// Check for (ADTS) MPEG-2
				if (this.check([0x08], {offset: 1, mask: [0x08]})) {
					return {
						ext: 'aac',
						mime: 'audio/aac',
					};
				}

				// Must be (ADTS) MPEG-4
				return {
					ext: 'aac',
					mime: 'audio/aac',
				};
			}

			// MPEG 1 or 2 Layer 3 header
			// Check for MPEG layer 3
			if (this.check([0x02], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp3',
					mime: 'audio/mpeg',
				};
			}

			// Check for MPEG layer 2
			if (this.check([0x04], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp2',
					mime: 'audio/mpeg',
				};
			}

			// Check for MPEG layer 1
			if (this.check([0x06], {offset: 1, mask: [0x06]})) {
				return {
					ext: 'mp1',
					mime: 'audio/mpeg',
				};
			}
		}
	}

	async readTiffTag(bigEndian) {
		const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		this.tokenizer.ignore(10);
		switch (tagId) {
			case 50_341:
				return {
					ext: 'arw',
					mime: 'image/x-sony-arw',
				};
			case 50_706:
				return {
					ext: 'dng',
					mime: 'image/x-adobe-dng',
				};
		}
	}

	async readTiffIFD(bigEndian) {
		const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		for (let n = 0; n < numberOfTags; ++n) {
			const fileType = await this.readTiffTag(bigEndian);
			if (fileType) {
				return fileType;
			}
		}
	}

	async readTiffHeader(bigEndian) {
		const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
		const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);

		if (version === 42) {
			// TIFF file header
			if (ifdOffset >= 6) {
				if (this.checkString('CR', {offset: 8})) {
					return {
						ext: 'cr2',
						mime: 'image/x-canon-cr2',
					};
				}

				if (ifdOffset >= 8 && (this.check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || this.check([0x1F, 0x00, 0x0B, 0x00], {offset: 8}))) {
					return {
						ext: 'nef',
						mime: 'image/x-nikon-nef',
					};
				}
			}

			await this.tokenizer.ignore(ifdOffset);
			const fileType = await this.readTiffIFD(bigEndian);
			return fileType ?? {
				ext: 'tif',
				mime: 'image/tiff',
			};
		}

		if (version === 43) {	// Big TIFF file header
			return {
				ext: 'tif',
				mime: 'image/tiff',
			};
		}
	}
}

new Set(extensions);
new Set(mimeTypes);

/**
Node.js specific entry point.
*/


class NodeFileTypeParser extends FileTypeParser {
	async fromStream(stream) {
		const tokenizer = await (stream instanceof ReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream(stream, this.tokenizerOptions));
		try {
			return await super.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async fromFile(path) {
		const tokenizer = await fromFile(path);
		try {
			return await super.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}

	async toDetectionStream(readableStream, options = {}) {
		if (!(readableStream instanceof Readable)) {
			return super.toDetectionStream(readableStream, options);
		}

		const {sampleSize = reasonableDetectionSizeInBytes} = options;

		return new Promise((resolve, reject) => {
			readableStream.on('error', reject);

			readableStream.once('readable', () => {
				(async () => {
					try {
						// Set up output stream
						const pass = new PassThrough();
						const outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);

						// Read the input stream and detect the filetype
						const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
						try {
							pass.fileType = await this.fromBuffer(chunk);
						} catch (error) {
							if (error instanceof EndOfStreamError) {
								pass.fileType = undefined;
							} else {
								reject(error);
							}
						}

						resolve(outputStream);
					} catch (error) {
						reject(error);
					}
				})();
			});
		});
	}
}

async function fileTypeFromFile(path, fileTypeOptions) {
	return (new NodeFileTypeParser(fileTypeOptions)).fromFile(path, fileTypeOptions);
}

var dist = {exports: {}};

var queue = {exports: {}};

var inherits_browser = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

var inherits_browserExports = inherits_browser.exports;

var inherits = inherits_browserExports;
var EventEmitter$1 = require$$1.EventEmitter;

queue.exports = Queue;
queue.exports.default = Queue;

function Queue (options) {
  if (!(this instanceof Queue)) {
    return new Queue(options)
  }

  EventEmitter$1.call(this);
  options = options || {};
  this.concurrency = options.concurrency || Infinity;
  this.timeout = options.timeout || 0;
  this.autostart = options.autostart || false;
  this.results = options.results || null;
  this.pending = 0;
  this.session = 0;
  this.running = false;
  this.jobs = [];
  this.timers = {};
}
inherits(Queue, EventEmitter$1);

var arrayMethods = [
  'pop',
  'shift',
  'indexOf',
  'lastIndexOf'
];

arrayMethods.forEach(function (method) {
  Queue.prototype[method] = function () {
    return Array.prototype[method].apply(this.jobs, arguments)
  };
});

Queue.prototype.slice = function (begin, end) {
  this.jobs = this.jobs.slice(begin, end);
  return this
};

Queue.prototype.reverse = function () {
  this.jobs.reverse();
  return this
};

var arrayAddMethods = [
  'push',
  'unshift',
  'splice'
];

arrayAddMethods.forEach(function (method) {
  Queue.prototype[method] = function () {
    var methodResult = Array.prototype[method].apply(this.jobs, arguments);
    if (this.autostart) {
      this.start();
    }
    return methodResult
  };
});

Object.defineProperty(Queue.prototype, 'length', {
  get: function () {
    return this.pending + this.jobs.length
  }
});

Queue.prototype.start = function (cb) {
  if (cb) {
    callOnErrorOrEnd.call(this, cb);
  }

  this.running = true;

  if (this.pending >= this.concurrency) {
    return
  }

  if (this.jobs.length === 0) {
    if (this.pending === 0) {
      done.call(this);
    }
    return
  }

  var self = this;
  var job = this.jobs.shift();
  var once = true;
  var session = this.session;
  var timeoutId = null;
  var didTimeout = false;
  var resultIndex = null;
  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout;

  function next (err, result) {
    if (once && self.session === session) {
      once = false;
      self.pending--;
      if (timeoutId !== null) {
        delete self.timers[timeoutId];
        clearTimeout(timeoutId);
      }

      if (err) {
        self.emit('error', err, job);
      } else if (didTimeout === false) {
        if (resultIndex !== null) {
          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
        }
        self.emit('success', result, job);
      }

      if (self.session === session) {
        if (self.pending === 0 && self.jobs.length === 0) {
          done.call(self);
        } else if (self.running) {
          self.start();
        }
      }
    }
  }

  if (timeout) {
    timeoutId = setTimeout(function () {
      didTimeout = true;
      if (self.listeners('timeout').length > 0) {
        self.emit('timeout', next, job);
      } else {
        next();
      }
    }, timeout);
    this.timers[timeoutId] = timeoutId;
  }

  if (this.results) {
    resultIndex = this.results.length;
    this.results[resultIndex] = null;
  }

  this.pending++;
  self.emit('start', job);
  var promise = job(next);
  if (promise && promise.then && typeof promise.then === 'function') {
    promise.then(function (result) {
      return next(null, result)
    }).catch(function (err) {
      return next(err || true)
    });
  }

  if (this.running && this.jobs.length > 0) {
    this.start();
  }
};

Queue.prototype.stop = function () {
  this.running = false;
};

Queue.prototype.end = function (err) {
  clearTimers.call(this);
  this.jobs.length = 0;
  this.pending = 0;
  done.call(this, err);
};

function clearTimers () {
  for (var key in this.timers) {
    var timeoutId = this.timers[key];
    delete this.timers[key];
    clearTimeout(timeoutId);
  }
}

function callOnErrorOrEnd (cb) {
  var self = this;
  this.on('error', onerror);
  this.on('end', onend);

  function onerror (err) { self.end(err); }
  function onend (err) {
    self.removeListener('error', onerror);
    self.removeListener('end', onend);
    cb(err, this.results);
  }
}

function done (err) {
  this.session++;
  this.running = false;
  this.emit('end', err);
}

var queueExports = queue.exports;

var types$1 = {};

var bmp = {};

var utils$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.findBox = exports.readUInt = exports.readUInt32LE = exports.readUInt32BE = exports.readInt32LE = exports.readUInt24LE = exports.readUInt16LE = exports.readUInt16BE = exports.readInt16LE = exports.toHexString = exports.toUTF8String = void 0;
	const decoder = new TextDecoder();
	const toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
	exports.toUTF8String = toUTF8String;
	const toHexString = (input, start = 0, end = input.length) => input
	    .slice(start, end)
	    .reduce((memo, i) => memo + ('0' + i.toString(16)).slice(-2), '');
	exports.toHexString = toHexString;
	const readInt16LE = (input, offset = 0) => {
	    const val = input[offset] + input[offset + 1] * 2 ** 8;
	    return val | ((val & (2 ** 15)) * 0x1fffe);
	};
	exports.readInt16LE = readInt16LE;
	const readUInt16BE = (input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1];
	exports.readUInt16BE = readUInt16BE;
	const readUInt16LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8;
	exports.readUInt16LE = readUInt16LE;
	const readUInt24LE = (input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16;
	exports.readUInt24LE = readUInt24LE;
	const readInt32LE = (input, offset = 0) => input[offset] +
	    input[offset + 1] * 2 ** 8 +
	    input[offset + 2] * 2 ** 16 +
	    (input[offset + 3] << 24);
	exports.readInt32LE = readInt32LE;
	const readUInt32BE = (input, offset = 0) => input[offset] * 2 ** 24 +
	    input[offset + 1] * 2 ** 16 +
	    input[offset + 2] * 2 ** 8 +
	    input[offset + 3];
	exports.readUInt32BE = readUInt32BE;
	const readUInt32LE = (input, offset = 0) => input[offset] +
	    input[offset + 1] * 2 ** 8 +
	    input[offset + 2] * 2 ** 16 +
	    input[offset + 3] * 2 ** 24;
	exports.readUInt32LE = readUInt32LE;
	// Abstract reading multi-byte unsigned integers
	const methods = {
	    readUInt16BE: exports.readUInt16BE,
	    readUInt16LE: exports.readUInt16LE,
	    readUInt32BE: exports.readUInt32BE,
	    readUInt32LE: exports.readUInt32LE,
	};
	function readUInt(input, bits, offset, isBigEndian) {
	    offset = offset || 0;
	    const endian = isBigEndian ? 'BE' : 'LE';
	    const methodName = ('readUInt' + bits + endian);
	    return methods[methodName](input, offset);
	}
	exports.readUInt = readUInt;
	function readBox(buffer, offset) {
	    if (buffer.length - offset < 4)
	        return;
	    const boxSize = (0, exports.readUInt32BE)(buffer, offset);
	    if (buffer.length - offset < boxSize)
	        return;
	    return {
	        name: (0, exports.toUTF8String)(buffer, 4 + offset, 8 + offset),
	        offset,
	        size: boxSize,
	    };
	}
	function findBox(buffer, boxName, offset) {
	    while (offset < buffer.length) {
	        const box = readBox(buffer, offset);
	        if (!box)
	            break;
	        if (box.name === boxName)
	            return box;
	        offset += box.size;
	    }
	}
	exports.findBox = findBox; 
} (utils$1));

Object.defineProperty(bmp, "__esModule", { value: true });
bmp.BMP = void 0;
const utils_1$h = utils$1;
bmp.BMP = {
    validate: (input) => (0, utils_1$h.toUTF8String)(input, 0, 2) === 'BM',
    calculate: (input) => ({
        height: Math.abs((0, utils_1$h.readInt32LE)(input, 22)),
        width: (0, utils_1$h.readUInt32LE)(input, 18),
    }),
};

var cur = {};

var ico = {};

Object.defineProperty(ico, "__esModule", { value: true });
ico.ICO = void 0;
const utils_1$g = utils$1;
const TYPE_ICON = 1;
/**
 * ICON Header
 *
 * | Offset | Size | Purpose |
 * | 0	    | 2    | Reserved. Must always be 0.  |
 * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |
 * | 4      | 2    | Number of images in the file. |
 *
 */
const SIZE_HEADER$1 = 2 + 2 + 2; // 6
/**
 * Image Entry
 *
 * | Offset | Size | Purpose |
 * | 0	    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |
 * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |
 * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |
 * | 3      | 1    | Reserved. Should be 0. |
 * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |
 * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |
 * | 6      | 2    | ICO format: Bits per pixel. |
 * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |
 * | 8      | 4    | The size of the image's data in bytes |
 * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |
 *
 */
const SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16
function getSizeFromOffset(input, offset) {
    const value = input[offset];
    return value === 0 ? 256 : value;
}
function getImageSize$1(input, imageIndex) {
    const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;
    return {
        height: getSizeFromOffset(input, offset + 1),
        width: getSizeFromOffset(input, offset),
    };
}
ico.ICO = {
    validate(input) {
        const reserved = (0, utils_1$g.readUInt16LE)(input, 0);
        const imageCount = (0, utils_1$g.readUInt16LE)(input, 4);
        if (reserved !== 0 || imageCount === 0)
            return false;
        const imageType = (0, utils_1$g.readUInt16LE)(input, 2);
        return imageType === TYPE_ICON;
    },
    calculate(input) {
        const nbImages = (0, utils_1$g.readUInt16LE)(input, 4);
        const imageSize = getImageSize$1(input, 0);
        if (nbImages === 1)
            return imageSize;
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
            imgs.push(getImageSize$1(input, imageIndex));
        }
        return {
            height: imageSize.height,
            images: imgs,
            width: imageSize.width,
        };
    },
};

Object.defineProperty(cur, "__esModule", { value: true });
cur.CUR = void 0;
const ico_1$1 = ico;
const utils_1$f = utils$1;
const TYPE_CURSOR = 2;
cur.CUR = {
    validate(input) {
        const reserved = (0, utils_1$f.readUInt16LE)(input, 0);
        const imageCount = (0, utils_1$f.readUInt16LE)(input, 4);
        if (reserved !== 0 || imageCount === 0)
            return false;
        const imageType = (0, utils_1$f.readUInt16LE)(input, 2);
        return imageType === TYPE_CURSOR;
    },
    calculate: (input) => ico_1$1.ICO.calculate(input),
};

var dds = {};

Object.defineProperty(dds, "__esModule", { value: true });
dds.DDS = void 0;
const utils_1$e = utils$1;
dds.DDS = {
    validate: (input) => (0, utils_1$e.readUInt32LE)(input, 0) === 0x20534444,
    calculate: (input) => ({
        height: (0, utils_1$e.readUInt32LE)(input, 12),
        width: (0, utils_1$e.readUInt32LE)(input, 16),
    }),
};

var gif = {};

Object.defineProperty(gif, "__esModule", { value: true });
gif.GIF = void 0;
const utils_1$d = utils$1;
const gifRegexp = /^GIF8[79]a/;
gif.GIF = {
    validate: (input) => gifRegexp.test((0, utils_1$d.toUTF8String)(input, 0, 6)),
    calculate: (input) => ({
        height: (0, utils_1$d.readUInt16LE)(input, 8),
        width: (0, utils_1$d.readUInt16LE)(input, 6),
    }),
};

var heif = {};

Object.defineProperty(heif, "__esModule", { value: true });
heif.HEIF = void 0;
const utils_1$c = utils$1;
const brandMap = {
    avif: 'avif',
    mif1: 'heif',
    msf1: 'heif', // hief-sequence
    heic: 'heic',
    heix: 'heic',
    hevc: 'heic', // heic-sequence
    hevx: 'heic', // heic-sequence
};
heif.HEIF = {
    validate(buffer) {
        const ftype = (0, utils_1$c.toUTF8String)(buffer, 4, 8);
        const brand = (0, utils_1$c.toUTF8String)(buffer, 8, 12);
        return 'ftyp' === ftype && brand in brandMap;
    },
    calculate(buffer) {
        // Based on https://nokiatech.github.io/heif/technical.html
        const metaBox = (0, utils_1$c.findBox)(buffer, 'meta', 0);
        const iprpBox = metaBox && (0, utils_1$c.findBox)(buffer, 'iprp', metaBox.offset + 12);
        const ipcoBox = iprpBox && (0, utils_1$c.findBox)(buffer, 'ipco', iprpBox.offset + 8);
        const ispeBox = ipcoBox && (0, utils_1$c.findBox)(buffer, 'ispe', ipcoBox.offset + 8);
        if (ispeBox) {
            return {
                height: (0, utils_1$c.readUInt32BE)(buffer, ispeBox.offset + 16),
                width: (0, utils_1$c.readUInt32BE)(buffer, ispeBox.offset + 12),
                type: (0, utils_1$c.toUTF8String)(buffer, 8, 12),
            };
        }
        throw new TypeError('Invalid HEIF, no size found');
    }
};

var icns = {};

Object.defineProperty(icns, "__esModule", { value: true });
icns.ICNS = void 0;
const utils_1$b = utils$1;
/**
 * ICNS Header
 *
 * | Offset | Size | Purpose                                                |
 * | 0	    | 4    | Magic literal, must be "icns" (0x69, 0x63, 0x6e, 0x73) |
 * | 4      | 4    | Length of file, in bytes, msb first.                   |
 *
 */
const SIZE_HEADER = 4 + 4; // 8
const FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN
/**
 * Image Entry
 *
 * | Offset | Size | Purpose                                                          |
 * | 0	    | 4    | Icon type, see OSType below.                                     |
 * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |
 * | 8      | n    | Icon data                                                        |
 */
const ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN
const ICON_TYPE_SIZE = {
    ICON: 32,
    'ICN#': 32,
    // m => 16 x 16
    'icm#': 16,
    icm4: 16,
    icm8: 16,
    // s => 16 x 16
    'ics#': 16,
    ics4: 16,
    ics8: 16,
    is32: 16,
    s8mk: 16,
    icp4: 16,
    // l => 32 x 32
    icl4: 32,
    icl8: 32,
    il32: 32,
    l8mk: 32,
    icp5: 32,
    ic11: 32,
    // h => 48 x 48
    ich4: 48,
    ich8: 48,
    ih32: 48,
    h8mk: 48,
    // . => 64 x 64
    icp6: 64,
    ic12: 32,
    // t => 128 x 128
    it32: 128,
    t8mk: 128,
    ic07: 128,
    // . => 256 x 256
    ic08: 256,
    ic13: 256,
    // . => 512 x 512
    ic09: 512,
    ic14: 512,
    // . => 1024 x 1024
    ic10: 1024,
};
function readImageHeader(input, imageOffset) {
    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
    return [
        (0, utils_1$b.toUTF8String)(input, imageOffset, imageLengthOffset),
        (0, utils_1$b.readUInt32BE)(input, imageLengthOffset),
    ];
}
function getImageSize(type) {
    const size = ICON_TYPE_SIZE[type];
    return { width: size, height: size, type };
}
icns.ICNS = {
    validate: (input) => (0, utils_1$b.toUTF8String)(input, 0, 4) === 'icns',
    calculate(input) {
        const inputLength = input.length;
        const fileLength = (0, utils_1$b.readUInt32BE)(input, FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(input, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength)
            return imageSize;
        const result = {
            height: imageSize.height,
            images: [imageSize],
            width: imageSize.width,
        };
        while (imageOffset < fileLength && imageOffset < inputLength) {
            imageHeader = readImageHeader(input, imageOffset);
            imageSize = getImageSize(imageHeader[0]);
            imageOffset += imageHeader[1];
            result.images.push(imageSize);
        }
        return result;
    },
};

var j2c = {};

Object.defineProperty(j2c, "__esModule", { value: true });
j2c.J2C = void 0;
const utils_1$a = utils$1;
j2c.J2C = {
    // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
    validate: (input) => (0, utils_1$a.toHexString)(input, 0, 4) === 'ff4fff51',
    calculate: (input) => ({
        height: (0, utils_1$a.readUInt32BE)(input, 12),
        width: (0, utils_1$a.readUInt32BE)(input, 8),
    }),
};

var jp2 = {};

Object.defineProperty(jp2, "__esModule", { value: true });
jp2.JP2 = void 0;
const utils_1$9 = utils$1;
jp2.JP2 = {
    validate(input) {
        if ((0, utils_1$9.readUInt32BE)(input, 4) !== 0x6a502020 || (0, utils_1$9.readUInt32BE)(input, 0) < 1)
            return false;
        const ftypBox = (0, utils_1$9.findBox)(input, 'ftyp', 0);
        if (!ftypBox)
            return false;
        return (0, utils_1$9.readUInt32BE)(input, ftypBox.offset + 4) === 0x66747970;
    },
    calculate(input) {
        const jp2hBox = (0, utils_1$9.findBox)(input, 'jp2h', 0);
        const ihdrBox = jp2hBox && (0, utils_1$9.findBox)(input, 'ihdr', jp2hBox.offset + 8);
        if (ihdrBox) {
            return {
                height: (0, utils_1$9.readUInt32BE)(input, ihdrBox.offset + 8),
                width: (0, utils_1$9.readUInt32BE)(input, ihdrBox.offset + 12),
            };
        }
        throw new TypeError('Unsupported JPEG 2000 format');
    },
};

var jpg = {};

// NOTE: we only support baseline and progressive JPGs here
// due to the structure of the loader class, we only get a buffer
// with a maximum size of 4096 bytes. so if the SOF marker is outside
// if this range we can't detect the file size correctly.
Object.defineProperty(jpg, "__esModule", { value: true });
jpg.JPG = void 0;
const utils_1$8 = utils$1;
const EXIF_MARKER = '45786966';
const APP1_DATA_SIZE_BYTES = 2;
const EXIF_HEADER_BYTES = 6;
const TIFF_BYTE_ALIGN_BYTES = 2;
const BIG_ENDIAN_BYTE_ALIGN = '4d4d';
const LITTLE_ENDIAN_BYTE_ALIGN = '4949';
// Each entry is exactly 12 bytes
const IDF_ENTRY_BYTES = 12;
const NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
    return (0, utils_1$8.toHexString)(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index) {
    return {
        height: (0, utils_1$8.readUInt16BE)(input, index),
        width: (0, utils_1$8.readUInt16BE)(input, index + 2),
    };
}
function extractOrientation(exifBlock, isBigEndian) {
    // TODO: assert that this contains 0x002A
    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2
    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4
    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES
    const idfOffset = 8;
    // IDF osset works from right after the header bytes
    // (so the offset includes the tiff byte align)
    const offset = EXIF_HEADER_BYTES + idfOffset;
    const idfDirectoryEntries = (0, utils_1$8.readUInt)(exifBlock, 16, offset, isBigEndian);
    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
        const start = offset +
            NUM_DIRECTORY_ENTRIES_BYTES +
            directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        // Skip on corrupt EXIF blocks
        if (start > exifBlock.length) {
            return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = (0, utils_1$8.readUInt)(block, 16, 0, isBigEndian);
        // 0x0112 (decimal: 274) is the `orientation` tag ID
        if (tagNumber === 274) {
            const dataFormat = (0, utils_1$8.readUInt)(block, 16, 2, isBigEndian);
            if (dataFormat !== 3) {
                return;
            }
            // unsinged int has 2 bytes per component
            // if there would more than 4 bytes in total it's a pointer
            const numberOfComponents = (0, utils_1$8.readUInt)(block, 32, 4, isBigEndian);
            if (numberOfComponents !== 1) {
                return;
            }
            return (0, utils_1$8.readUInt)(block, 16, 8, isBigEndian);
        }
    }
}
function validateExifBlock(input, index) {
    // Skip APP1 Data Size
    const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index);
    // Consider byte alignment
    const byteAlign = (0, utils_1$8.toHexString)(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
    // Ignore Empty EXIF. Validate byte alignment
    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
    if (isBigEndian || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian);
    }
}
function validateInput(input, index) {
    // index should be within buffer limits
    if (index > input.length) {
        throw new TypeError('Corrupt JPG, exceeded buffer limits');
    }
}
jpg.JPG = {
    validate: (input) => (0, utils_1$8.toHexString)(input, 0, 2) === 'ffd8',
    calculate(input) {
        // Skip 4 chars, they are for signature
        input = input.slice(4);
        let orientation;
        let next;
        while (input.length) {
            // read length of the next block
            const i = (0, utils_1$8.readUInt16BE)(input, 0);
            // Every JPEG block must begin with a 0xFF
            if (input[i] !== 0xff) {
                input = input.slice(1);
                continue;
            }
            if (isEXIF(input)) {
                orientation = validateExifBlock(input, i);
            }
            // ensure correct format
            validateInput(input, i);
            // 0xFFC0 is baseline standard(SOF)
            // 0xFFC1 is baseline optimized(SOF)
            // 0xFFC2 is progressive(SOF2)
            next = input[i + 1];
            if (next === 0xc0 || next === 0xc1 || next === 0xc2) {
                const size = extractSize(input, i + 5);
                // TODO: is orientation=0 a valid answer here?
                if (!orientation) {
                    return size;
                }
                return {
                    height: size.height,
                    orientation,
                    width: size.width,
                };
            }
            // move to the next block
            input = input.slice(i + 2);
        }
        throw new TypeError('Invalid JPG, no size found');
    },
};

var ktx = {};

Object.defineProperty(ktx, "__esModule", { value: true });
ktx.KTX = void 0;
const utils_1$7 = utils$1;
ktx.KTX = {
    validate: (input) => {
        const signature = (0, utils_1$7.toUTF8String)(input, 1, 7);
        return ['KTX 11', 'KTX 20'].includes(signature);
    },
    calculate: (input) => {
        const type = input[5] === 0x31 ? 'ktx' : 'ktx2';
        const offset = type === 'ktx' ? 36 : 20;
        return ({
            height: (0, utils_1$7.readUInt32LE)(input, offset + 4),
            width: (0, utils_1$7.readUInt32LE)(input, offset),
            type,
        });
    },
};

var png = {};

Object.defineProperty(png, "__esModule", { value: true });
png.PNG = void 0;
const utils_1$6 = utils$1;
const pngSignature = 'PNG\r\n\x1a\n';
const pngImageHeaderChunkName = 'IHDR';
// Used to detect "fried" png's: http://www.jongware.com/pngdefry.html
const pngFriedChunkName = 'CgBI';
png.PNG = {
    validate(input) {
        if (pngSignature === (0, utils_1$6.toUTF8String)(input, 1, 8)) {
            let chunkName = (0, utils_1$6.toUTF8String)(input, 12, 16);
            if (chunkName === pngFriedChunkName) {
                chunkName = (0, utils_1$6.toUTF8String)(input, 28, 32);
            }
            if (chunkName !== pngImageHeaderChunkName) {
                throw new TypeError('Invalid PNG');
            }
            return true;
        }
        return false;
    },
    calculate(input) {
        if ((0, utils_1$6.toUTF8String)(input, 12, 16) === pngFriedChunkName) {
            return {
                height: (0, utils_1$6.readUInt32BE)(input, 36),
                width: (0, utils_1$6.readUInt32BE)(input, 32),
            };
        }
        return {
            height: (0, utils_1$6.readUInt32BE)(input, 20),
            width: (0, utils_1$6.readUInt32BE)(input, 16),
        };
    },
};

var pnm = {};

Object.defineProperty(pnm, "__esModule", { value: true });
pnm.PNM = void 0;
const utils_1$5 = utils$1;
const PNMTypes = {
    P1: 'pbm/ascii',
    P2: 'pgm/ascii',
    P3: 'ppm/ascii',
    P4: 'pbm',
    P5: 'pgm',
    P6: 'ppm',
    P7: 'pam',
    PF: 'pfm',
};
const handlers = {
    default: (lines) => {
        let dimensions = [];
        while (lines.length > 0) {
            const line = lines.shift();
            if (line[0] === '#') {
                continue;
            }
            dimensions = line.split(' ');
            break;
        }
        if (dimensions.length === 2) {
            return {
                height: parseInt(dimensions[1], 10),
                width: parseInt(dimensions[0], 10),
            };
        }
        else {
            throw new TypeError('Invalid PNM');
        }
    },
    pam: (lines) => {
        const size = {};
        while (lines.length > 0) {
            const line = lines.shift();
            if (line.length > 16 || line.charCodeAt(0) > 128) {
                continue;
            }
            const [key, value] = line.split(' ');
            if (key && value) {
                size[key.toLowerCase()] = parseInt(value, 10);
            }
            if (size.height && size.width) {
                break;
            }
        }
        if (size.height && size.width) {
            return {
                height: size.height,
                width: size.width,
            };
        }
        else {
            throw new TypeError('Invalid PAM');
        }
    },
};
pnm.PNM = {
    validate: (input) => (0, utils_1$5.toUTF8String)(input, 0, 2) in PNMTypes,
    calculate(input) {
        const signature = (0, utils_1$5.toUTF8String)(input, 0, 2);
        const type = PNMTypes[signature];
        // TODO: this probably generates garbage. move to a stream based parser
        const lines = (0, utils_1$5.toUTF8String)(input, 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
    },
};

var psd = {};

Object.defineProperty(psd, "__esModule", { value: true });
psd.PSD = void 0;
const utils_1$4 = utils$1;
psd.PSD = {
    validate: (input) => (0, utils_1$4.toUTF8String)(input, 0, 4) === '8BPS',
    calculate: (input) => ({
        height: (0, utils_1$4.readUInt32BE)(input, 14),
        width: (0, utils_1$4.readUInt32BE)(input, 18),
    }),
};

var svg = {};

Object.defineProperty(svg, "__esModule", { value: true });
svg.SVG = void 0;
const utils_1$3 = utils$1;
const svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
const extractorRegExps = {
    height: /\sheight=(['"])([^%]+?)\1/,
    root: svgReg,
    viewbox: /\sviewBox=(['"])(.+?)\1/i,
    width: /\swidth=(['"])([^%]+?)\1/,
};
const INCH_CM = 2.54;
const units = {
    in: 96,
    cm: 96 / INCH_CM,
    em: 16,
    ex: 8,
    m: (96 / INCH_CM) * 100,
    mm: 96 / INCH_CM / 10,
    pc: 96 / 72 / 12,
    pt: 96 / 72,
    px: 1,
};
const unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join('|')})?$`);
function parseLength(len) {
    const m = unitsReg.exec(len);
    if (!m) {
        return undefined;
    }
    return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
    const bounds = viewbox.split(' ');
    return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2]),
    };
}
function parseAttributes(root) {
    const width = root.match(extractorRegExps.width);
    const height = root.match(extractorRegExps.height);
    const viewbox = root.match(extractorRegExps.viewbox);
    return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width && parseLength(width[2]),
    };
}
function calculateByDimensions(attrs) {
    return {
        height: attrs.height,
        width: attrs.width,
    };
}
function calculateByViewbox(attrs, viewbox) {
    const ratio = viewbox.width / viewbox.height;
    if (attrs.width) {
        return {
            height: Math.floor(attrs.width / ratio),
            width: attrs.width,
        };
    }
    if (attrs.height) {
        return {
            height: attrs.height,
            width: Math.floor(attrs.height * ratio),
        };
    }
    return {
        height: viewbox.height,
        width: viewbox.width,
    };
}
svg.SVG = {
    // Scan only the first kilo-byte to speed up the check on larger files
    validate: (input) => svgReg.test((0, utils_1$3.toUTF8String)(input, 0, 1000)),
    calculate(input) {
        const root = (0, utils_1$3.toUTF8String)(input).match(extractorRegExps.root);
        if (root) {
            const attrs = parseAttributes(root[0]);
            if (attrs.width && attrs.height) {
                return calculateByDimensions(attrs);
            }
            if (attrs.viewbox) {
                return calculateByViewbox(attrs, attrs.viewbox);
            }
        }
        throw new TypeError('Invalid SVG');
    },
};

var tga = {};

Object.defineProperty(tga, "__esModule", { value: true });
tga.TGA = void 0;
const utils_1$2 = utils$1;
tga.TGA = {
    validate(input) {
        return (0, utils_1$2.readUInt16LE)(input, 0) === 0 && (0, utils_1$2.readUInt16LE)(input, 4) === 0;
    },
    calculate(input) {
        return {
            height: (0, utils_1$2.readUInt16LE)(input, 14),
            width: (0, utils_1$2.readUInt16LE)(input, 12),
        };
    },
};

var tiff = {};

Object.defineProperty(tiff, "__esModule", { value: true });
tiff.TIFF = void 0;
// based on http://www.compix.com/fileformattif.htm
// TO-DO: support big-endian as well
const fs$1 = fs__default;
const utils_1$1 = utils$1;
// Read IFD (image-file-directory) into a buffer
function readIFD(input, filepath, isBigEndian) {
    const ifdOffset = (0, utils_1$1.readUInt)(input, 32, 4, isBigEndian);
    // read only till the end of the file
    let bufferSize = 1024;
    const fileSize = fs$1.statSync(filepath).size;
    if (ifdOffset + bufferSize > fileSize) {
        bufferSize = fileSize - ifdOffset - 10;
    }
    // populate the buffer
    const endBuffer = new Uint8Array(bufferSize);
    const descriptor = fs$1.openSync(filepath, 'r');
    fs$1.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
    fs$1.closeSync(descriptor);
    return endBuffer.slice(2);
}
// TIFF values seem to be messed up on Big-Endian, this helps
function readValue(input, isBigEndian) {
    const low = (0, utils_1$1.readUInt)(input, 16, 8, isBigEndian);
    const high = (0, utils_1$1.readUInt)(input, 16, 10, isBigEndian);
    return (high << 16) + low;
}
// move to the next tag
function nextTag(input) {
    if (input.length > 24) {
        return input.slice(12);
    }
}
// Extract IFD tags from TIFF metadata
function extractTags(input, isBigEndian) {
    const tags = {};
    let temp = input;
    while (temp && temp.length) {
        const code = (0, utils_1$1.readUInt)(temp, 16, 0, isBigEndian);
        const type = (0, utils_1$1.readUInt)(temp, 16, 2, isBigEndian);
        const length = (0, utils_1$1.readUInt)(temp, 32, 4, isBigEndian);
        // 0 means end of IFD
        if (code === 0) {
            break;
        }
        else {
            // 256 is width, 257 is height
            // if (code === 256 || code === 257) {
            if (length === 1 && (type === 3 || type === 4)) {
                tags[code] = readValue(temp, isBigEndian);
            }
            // move to the next tag
            temp = nextTag(temp);
        }
    }
    return tags;
}
// Test if the TIFF is Big Endian or Little Endian
function determineEndianness(input) {
    const signature = (0, utils_1$1.toUTF8String)(input, 0, 2);
    if ('II' === signature) {
        return 'LE';
    }
    else if ('MM' === signature) {
        return 'BE';
    }
}
const signatures = [
    // '492049', // currently not supported
    '49492a00', // Little endian
    '4d4d002a', // Big Endian
    // '4d4d002a', // BigTIFF > 4GB. currently not supported
];
tiff.TIFF = {
    validate: (input) => signatures.includes((0, utils_1$1.toHexString)(input, 0, 4)),
    calculate(input, filepath) {
        if (!filepath) {
            throw new TypeError('Tiff doesn\'t support buffer');
        }
        // Determine BE/LE
        const isBigEndian = determineEndianness(input) === 'BE';
        // read the IFD
        const ifdBuffer = readIFD(input, filepath, isBigEndian);
        // extract the tags from the IFD
        const tags = extractTags(ifdBuffer, isBigEndian);
        const width = tags[256];
        const height = tags[257];
        if (!width || !height) {
            throw new TypeError('Invalid Tiff. Missing tags');
        }
        return { height, width };
    },
};

var webp = {};

Object.defineProperty(webp, "__esModule", { value: true });
webp.WEBP = void 0;
const utils_1 = utils$1;
function calculateExtended(input) {
    return {
        height: 1 + (0, utils_1.readUInt24LE)(input, 7),
        width: 1 + (0, utils_1.readUInt24LE)(input, 4),
    };
}
function calculateLossless(input) {
    return {
        height: 1 +
            (((input[4] & 0xf) << 10) | (input[3] << 2) | ((input[2] & 0xc0) >> 6)),
        width: 1 + (((input[2] & 0x3f) << 8) | input[1]),
    };
}
function calculateLossy(input) {
    // `& 0x3fff` returns the last 14 bits
    // TO-DO: include webp scaling in the calculations
    return {
        height: (0, utils_1.readInt16LE)(input, 8) & 0x3fff,
        width: (0, utils_1.readInt16LE)(input, 6) & 0x3fff,
    };
}
webp.WEBP = {
    validate(input) {
        const riffHeader = 'RIFF' === (0, utils_1.toUTF8String)(input, 0, 4);
        const webpHeader = 'WEBP' === (0, utils_1.toUTF8String)(input, 8, 12);
        const vp8Header = 'VP8' === (0, utils_1.toUTF8String)(input, 12, 15);
        return riffHeader && webpHeader && vp8Header;
    },
    calculate(input) {
        const chunkHeader = (0, utils_1.toUTF8String)(input, 12, 16);
        input = input.slice(20, 30);
        // Extended webp stream signature
        if (chunkHeader === 'VP8X') {
            const extendedHeader = input[0];
            const validStart = (extendedHeader & 0xc0) === 0;
            const validEnd = (extendedHeader & 0x01) === 0;
            if (validStart && validEnd) {
                return calculateExtended(input);
            }
            else {
                // TODO: breaking change
                throw new TypeError('Invalid WebP');
            }
        }
        // Lossless webp stream signature
        if (chunkHeader === 'VP8 ' && input[0] !== 0x2f) {
            return calculateLossy(input);
        }
        // Lossy webp stream signature
        const signature = (0, utils_1.toHexString)(input, 3, 6);
        if (chunkHeader === 'VP8L' && signature !== '9d012a') {
            return calculateLossless(input);
        }
        throw new TypeError('Invalid WebP');
    },
};

Object.defineProperty(types$1, "__esModule", { value: true });
types$1.typeHandlers = void 0;
// load all available handlers explicitly for browserify support
const bmp_1 = bmp;
const cur_1 = cur;
const dds_1 = dds;
const gif_1 = gif;
const heif_1 = heif;
const icns_1 = icns;
const ico_1 = ico;
const j2c_1 = j2c;
const jp2_1 = jp2;
const jpg_1 = jpg;
const ktx_1 = ktx;
const png_1 = png;
const pnm_1 = pnm;
const psd_1 = psd;
const svg_1 = svg;
const tga_1 = tga;
const tiff_1 = tiff;
const webp_1 = webp;
types$1.typeHandlers = {
    bmp: bmp_1.BMP,
    cur: cur_1.CUR,
    dds: dds_1.DDS,
    gif: gif_1.GIF,
    heif: heif_1.HEIF,
    icns: icns_1.ICNS,
    ico: ico_1.ICO,
    j2c: j2c_1.J2C,
    jp2: jp2_1.JP2,
    jpg: jpg_1.JPG,
    ktx: ktx_1.KTX,
    png: png_1.PNG,
    pnm: pnm_1.PNM,
    psd: psd_1.PSD,
    svg: svg_1.SVG,
    tga: tga_1.TGA,
    tiff: tiff_1.TIFF,
    webp: webp_1.WEBP,
};

var detector$1 = {};

Object.defineProperty(detector$1, "__esModule", { value: true });
detector$1.detector = void 0;
const index_1 = types$1;
const keys = Object.keys(index_1.typeHandlers);
// This map helps avoid validating for every single image type
const firstBytes = {
    0x38: 'psd',
    0x42: 'bmp',
    0x44: 'dds',
    0x47: 'gif',
    0x49: 'tiff',
    0x4d: 'tiff',
    0x52: 'webp',
    0x69: 'icns',
    0x89: 'png',
    0xff: 'jpg',
};
function detector(input) {
    const byte = input[0];
    if (byte in firstBytes) {
        const type = firstBytes[byte];
        if (type && index_1.typeHandlers[type].validate(input)) {
            return type;
        }
    }
    const finder = (key) => index_1.typeHandlers[key].validate(input);
    return keys.find(finder);
}
detector$1.detector = detector;

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.types = exports.setConcurrency = exports.disableTypes = exports.disableFS = exports.imageSize = void 0;
	const fs = fs__default;
	const path = path$2;
	const queue_1 = queueExports;
	const index_1 = types$1;
	const detector_1 = detector$1;
	// Maximum input size, with a default of 512 kilobytes.
	// TO-DO: make this adaptive based on the initial signature of the image
	const MaxInputSize = 512 * 1024;
	// This queue is for async `fs` operations, to avoid reaching file-descriptor limits
	const queue = new queue_1.default({ concurrency: 100, autostart: true });
	const globalOptions = {
	    disabledFS: false,
	    disabledTypes: [],
	};
	/**
	 * Return size information based on an Uint8Array
	 *
	 * @param {Uint8Array} input
	 * @param {String} filepath
	 * @returns {Object}
	 */
	function lookup(input, filepath) {
	    // detect the file type.. don't rely on the extension
	    const type = (0, detector_1.detector)(input);
	    if (typeof type !== 'undefined') {
	        if (globalOptions.disabledTypes.indexOf(type) > -1) {
	            throw new TypeError('disabled file type: ' + type);
	        }
	        // find an appropriate handler for this file type
	        if (type in index_1.typeHandlers) {
	            const size = index_1.typeHandlers[type].calculate(input, filepath);
	            if (size !== undefined) {
	                size.type = size.type ?? type;
	                return size;
	            }
	        }
	    }
	    // throw up, if we don't understand the file
	    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');
	}
	/**
	 * Reads a file into an Uint8Array.
	 * @param {String} filepath
	 * @returns {Promise<Uint8Array>}
	 */
	async function readFileAsync(filepath) {
	    const handle = await fs.promises.open(filepath, 'r');
	    try {
	        const { size } = await handle.stat();
	        if (size <= 0) {
	            throw new Error('Empty file');
	        }
	        const inputSize = Math.min(size, MaxInputSize);
	        const input = new Uint8Array(inputSize);
	        await handle.read(input, 0, inputSize, 0);
	        return input;
	    }
	    finally {
	        await handle.close();
	    }
	}
	/**
	 * Synchronously reads a file into an Uint8Array, blocking the nodejs process.
	 *
	 * @param {String} filepath
	 * @returns {Uint8Array}
	 */
	function readFileSync(filepath) {
	    // read from the file, synchronously
	    const descriptor = fs.openSync(filepath, 'r');
	    try {
	        const { size } = fs.fstatSync(descriptor);
	        if (size <= 0) {
	            throw new Error('Empty file');
	        }
	        const inputSize = Math.min(size, MaxInputSize);
	        const input = new Uint8Array(inputSize);
	        fs.readSync(descriptor, input, 0, inputSize, 0);
	        return input;
	    }
	    finally {
	        fs.closeSync(descriptor);
	    }
	}
	// eslint-disable-next-line @typescript-eslint/no-use-before-define
	module.exports = exports = imageSize; // backwards compatibility
	exports.default = imageSize;
	/**
	 * @param {Uint8Array|string} input - Uint8Array or relative/absolute path of the image file
	 * @param {Function=} [callback] - optional function for async detection
	 */
	function imageSize(input, callback) {
	    // Handle Uint8Array input
	    if (input instanceof Uint8Array) {
	        return lookup(input);
	    }
	    // input should be a string at this point
	    if (typeof input !== 'string' || globalOptions.disabledFS) {
	        throw new TypeError('invalid invocation. input should be a Uint8Array');
	    }
	    // resolve the file path
	    const filepath = path.resolve(input);
	    if (typeof callback === 'function') {
	        queue.push(() => readFileAsync(filepath)
	            .then((input) => process.nextTick(callback, null, lookup(input, filepath)))
	            .catch(callback));
	    }
	    else {
	        const input = readFileSync(filepath);
	        return lookup(input, filepath);
	    }
	}
	exports.imageSize = imageSize;
	const disableFS = (v) => {
	    globalOptions.disabledFS = v;
	};
	exports.disableFS = disableFS;
	const disableTypes = (types) => {
	    globalOptions.disabledTypes = types;
	};
	exports.disableTypes = disableTypes;
	const setConcurrency = (c) => {
	    queue.concurrency = c;
	};
	exports.setConcurrency = setConcurrency;
	exports.types = Object.keys(index_1.typeHandlers); 
} (dist, dist.exports));

var distExports = dist.exports;
const imageSize = /*@__PURE__*/getDefaultExportFromCjs(distExports);

class RequestUtil {
  // 适用于获取服务器下发cookies时获取，仅GET
  static async HttpsGetCookies(url) {
    const client = url.startsWith("https") ? https$1 : http__default;
    return new Promise((resolve, reject) => {
      const req = client.get(url, (res) => {
        let cookies = {};
        const handleRedirect = (res2) => {
          if (res2.statusCode === 301 || res2.statusCode === 302) {
            if (res2.headers.location) {
              const redirectUrl = new URL(res2.headers.location, url);
              RequestUtil.HttpsGetCookies(redirectUrl.href).then((redirectCookies) => {
                cookies = { ...cookies, ...redirectCookies };
                resolve(cookies);
              }).catch((err) => {
                reject(err);
              });
            } else {
              resolve(cookies);
            }
          } else {
            resolve(cookies);
          }
        };
        res.on("data", () => {
        });
        res.on("end", () => {
          handleRedirect(res);
        });
        if (res.headers["set-cookie"]) {
          res.headers["set-cookie"].forEach((cookie) => {
            const parts = cookie.split(";")[0].split("=");
            const key = parts[0];
            const value = parts[1];
            if (key && value && key.length > 0 && value.length > 0) {
              cookies[key] = value;
            }
          });
        }
      });
      req.on("error", (error) => {
        reject(error);
      });
    });
  }
  // 请求和回复都是JSON data传原始内容 自动编码json
  static async HttpGetJson(url, method = "GET", data, headers = {}, isJsonRet = true, isArgJson = true) {
    const option = new URL(url);
    const protocol = url.startsWith("https://") ? https$1 : http__default;
    const options = {
      hostname: option.hostname,
      port: option.port,
      path: option.pathname + option.search,
      method,
      headers
    };
    return new Promise((resolve, reject) => {
      const req = protocol.request(options, (res) => {
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk.toString();
        });
        res.on("end", () => {
          try {
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
              if (isJsonRet) {
                const responseJson = JSON.parse(responseBody);
                resolve(responseJson);
              } else {
                resolve(responseBody);
              }
            } else {
              reject(new Error(`Unexpected status code: ${res.statusCode}`));
            }
          } catch (parseError) {
            reject(parseError);
          }
        });
      });
      req.on("error", (error) => {
        reject(error);
      });
      if (method === "POST" || method === "PUT" || method === "PATCH") {
        if (isArgJson) {
          req.write(JSON.stringify(data));
        } else {
          req.write(data);
        }
      }
      req.end();
    });
  }
  // 请求返回都是原始内容
  static async HttpGetText(url, method = "GET", data, headers = {}) {
    return this.HttpGetJson(url, method, data, headers, false, false);
  }
  static async createFormData(boundary, filePath) {
    let type = "image/png";
    if (filePath.endsWith(".jpg")) {
      type = "image/jpeg";
    }
    const formDataParts = [
      `------${boundary}\r
`,
      `Content-Disposition: form-data; name="share_image"; filename="${filePath}"\r
`,
      "Content-Type: " + type + "\r\n\r\n"
    ];
    const fileContent = readFileSync(filePath);
    const footer = `\r
------${boundary}--`;
    return Buffer.concat([
      Buffer.from(formDataParts.join(""), "utf8"),
      fileContent,
      Buffer.from(footer, "utf8")
    ]);
  }
  static async uploadImageForOpenPlatform(filePath, cookies) {
    return new Promise(async (resolve, reject) => {
      try {
        const options = {
          hostname: "cgi.connect.qq.com",
          port: 443,
          path: "/qqconnectopen/upload_share_image",
          method: "POST",
          headers: {
            "Referer": "https://cgi.connect.qq.com",
            "Cookie": cookies,
            "Accept": "*/*",
            "Connection": "keep-alive",
            "Content-Type": "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW"
          }
        };
        const req = https$1.request(options, async (res) => {
          let responseBody = "";
          res.on("data", (chunk) => {
            responseBody += chunk.toString();
          });
          res.on("end", () => {
            try {
              if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                const responseJson = JSON.parse(responseBody);
                resolve(responseJson.result.url);
              } else {
                reject(new Error(`Unexpected status code: ${res.statusCode}`));
              }
            } catch (parseError) {
              reject(parseError);
            }
          });
        });
        req.on("error", (error) => {
          reject(error);
          console.log("Error during upload:", error);
        });
        const body = await RequestUtil.createFormData("WebKitFormBoundary7MA4YWxkTrZu0gW", filePath);
        req.write(body);
        req.end();
        return;
      } catch (error) {
        reject(error);
      }
      return void 0;
    });
  }
}

class RkeyManager {
  serverUrl = [];
  logger;
  rkeyData = {
    group_rkey: "",
    private_rkey: "",
    expired_time: 0
  };
  constructor(serverUrl, logger) {
    this.logger = logger;
    this.serverUrl = serverUrl;
  }
  async getRkey() {
    if (this.isExpired()) {
      try {
        await this.refreshRkey();
      } catch (e) {
        throw new Error(`获取rkey失败: ${e}`);
      }
    }
    return this.rkeyData;
  }
  isExpired() {
    const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    return now > this.rkeyData.expired_time;
  }
  async refreshRkey() {
    for (const url of this.serverUrl) {
      try {
        const temp = await RequestUtil.HttpGetJson(url, "GET");
        this.rkeyData = {
          group_rkey: temp.group_rkey.slice(6),
          private_rkey: temp.private_rkey.slice(6),
          expired_time: temp.expired_time
        };
      } catch (e) {
        this.logger.logError.bind(this.logger)(`[Rkey] Get Rkey ${url} Error `, e);
        if (url === this.serverUrl[this.serverUrl.length - 1]) {
          throw new Error(`获取rkey失败: ${e}`);
        }
      }
    }
  }
}

function isGIF(path2) {
  const buffer = Buffer.alloc(4);
  const fd = fs__default.openSync(path2, "r");
  fs__default.readSync(fd, buffer, 0, 4, 0);
  fs__default.closeSync(fd);
  return buffer.toString() === "GIF8";
}
function checkFileReceived(path2, timeout = 3e3) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    function check() {
      if (fs__default.existsSync(path2)) {
        resolve();
      } else if (Date.now() - startTime > timeout) {
        reject(new Error(`文件不存在: ${path2}`));
      } else {
        setTimeout(check, 100);
      }
    }
    check();
  });
}
function calculateFileMD5(filePath) {
  return new Promise((resolve, reject) => {
    const stream = fs__default.createReadStream(filePath);
    const hash = crypto__default.createHash("md5");
    stream.on("data", (data) => {
      hash.update(data);
    });
    stream.on("end", () => {
      const md5 = hash.digest("hex");
      resolve(md5);
    });
    stream.on("error", (err) => {
      reject(err);
    });
  });
}
async function tryDownload(options, useReferer = false) {
  let url;
  let headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36"
  };
  if (typeof options === "string") {
    url = options;
    headers["Host"] = new URL(url).hostname;
  } else {
    url = options.url;
    if (options.headers) {
      if (typeof options.headers === "string") {
        headers = JSON.parse(options.headers);
      } else {
        headers = options.headers;
      }
    }
  }
  if (useReferer && !headers["Referer"]) {
    headers["Referer"] = url;
  }
  const fetchRes = await fetch(url, { headers }).catch((err) => {
    if (err.cause) {
      throw err.cause;
    }
    throw err;
  });
  return fetchRes;
}
async function httpDownload(options) {
  const useReferer = typeof options === "string";
  let resp = await tryDownload(options);
  if (resp.status === 403 && useReferer) {
    resp = await tryDownload(options, true);
  }
  if (!resp.ok) throw new Error(`下载文件失败: ${resp.statusText}`);
  const blob = await resp.blob();
  const buffer = await blob.arrayBuffer();
  return Buffer.from(buffer);
}
async function checkFileV2(filePath) {
  try {
    const ext = (await fileTypeFromFile(filePath))?.ext;
    if (ext) {
      fs__default.renameSync(filePath, filePath + `.${ext}`);
      filePath += `.${ext}`;
      return { success: true, ext, path: filePath };
    }
  } catch (e) {
  }
  return { success: false, ext: "", path: filePath };
}
async function checkUriType(Uri) {
  const LocalFileRet = await solveProblem((uri) => {
    if (fs__default.existsSync(uri)) {
      return { Uri: uri, Type: 1 /* Local */ };
    }
    return void 0;
  }, Uri);
  if (LocalFileRet) return LocalFileRet;
  const OtherFileRet = await solveProblem((uri) => {
    if (uri.startsWith("http://") || uri.startsWith("https://")) {
      return { Uri: uri, Type: 2 /* Remote */ };
    }
    if (uri.startsWith("base64://")) {
      return { Uri: uri, Type: 3 /* Base64 */ };
    }
    if (uri.startsWith("file://")) {
      let filePath;
      const pathname = decodeURIComponent(new URL(uri).pathname);
      if (process.platform === "win32") {
        filePath = pathname.slice(1);
      } else {
        filePath = pathname;
      }
      return { Uri: filePath, Type: 1 /* Local */ };
    }
    if (uri.startsWith("data:")) {
      const data = uri.split(",")[1];
      if (data) return { Uri: data, Type: 3 /* Base64 */ };
    }
  }, Uri);
  if (OtherFileRet) return OtherFileRet;
  return { Uri, Type: 0 /* Unknown */ };
}
async function uri2local(dir, uri, filename = void 0) {
  const { Uri: HandledUri, Type: UriType } = await checkUriType(uri);
  const tempName = randomUUID();
  if (!filename) filename = randomUUID();
  if (UriType == 0 /* Unknown */) {
    return { success: false, errMsg: "未知文件类型", fileName: "", ext: "", path: "" };
  }
  if (UriType == 1 /* Local */) {
    const fileExt = path$1.extname(HandledUri);
    let filename2 = path$1.basename(HandledUri, fileExt);
    filename2 += fileExt;
    const filenameTemp = tempName + fileExt;
    const filePath = path$1.join(dir, filenameTemp);
    fs__default.copyFileSync(HandledUri, filePath);
    return { success: true, errMsg: "", fileName: filename2, ext: fileExt, path: filePath };
  }
  if (UriType == 2 /* Remote */) {
    const pathInfo = path$1.parse(decodeURIComponent(new URL(HandledUri).pathname));
    if (pathInfo.name) {
      const pathlen = 200 - dir.length - pathInfo.name.length;
      filename = pathlen > 0 ? pathInfo.name.substring(0, pathlen) : pathInfo.name.substring(pathInfo.name.length, pathInfo.name.length - 10);
      if (pathInfo.ext) {
        filename += pathInfo.ext;
      }
    }
    filename = filename.replace(/[/\\:*?"<>|]/g, "_");
    const fileExt = path$1.extname(HandledUri).replace(/[/\\:*?"<>|]/g, "_").substring(0, 10);
    const filePath = path$1.join(dir, tempName + fileExt);
    const buffer = await httpDownload(HandledUri);
    fs__default.writeFileSync(filePath, buffer, { flag: "wx" });
    return { success: true, errMsg: "", fileName: filename, ext: fileExt, path: filePath };
  }
  if (UriType == 3 /* Base64 */) {
    const base64 = HandledUri.replace(/^base64:\/\//, "");
    const buffer = Buffer.from(base64, "base64");
    let filePath = path$1.join(dir, filename);
    let fileExt = "";
    fs__default.writeFileSync(filePath, buffer);
    const { success, ext, path: fileTypePath } = await checkFileV2(filePath);
    if (success) {
      filePath = fileTypePath;
      fileExt = ext;
      filename = filename + "." + ext;
    }
    return { success: true, errMsg: "", fileName: filename, ext: fileExt, path: filePath };
  }
  return { success: false, errMsg: "未知文件类型", fileName: "", ext: "", path: "" };
}

const defaultVideoThumbB64 = "/9j/4AAQSkZJRgABAQAAAQABAAD//gAXR2VuZXJhdGVkIGJ5IFNuaXBhc3Rl/9sAhAAKBwcIBwYKCAgICwoKCw4YEA4NDQ4dFRYRGCMfJSQiHyIhJis3LyYpNCkhIjBBMTQ5Oz4+PiUuRElDPEg3PT47AQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAF/APADAREAAhEBAxEB/8QBogAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoLEAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+foBAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKCxEAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDiAayNxwagBwNAC5oAM0xBmgBM0ANJoAjY0AQsaBkTGgCM0DEpAFAC0AFMBaACgAoEJTASgQlACUwCgQ4UAOFADhQA4UAOFADxQIkBqDQUGgBwagBQaBC5pgGaAELUAMLUARs1AETGgBhNAxhoASkAUALQIKYxaBBQAUwEoAQ0CEoASmAUAOoEKKAHCgBwoAeKAHigQ7NZmoZpgLmgBd1Ahd1ABupgNLUAMLUAMY0AMJoAYaAENACUCCgAoAWgAoAWgBKYCUAJQISgApgLQAooEOFACigB4oAeKBDxQAVmaiZpgGaAFzQAbqAE3UAIWpgNJoAYTQIaaAEoAQ0CEoASgBaACgBaACmAUAJQAlAgoAKYC0AKKBCigB4FADgKBDwKAHigBuazNRM0DEzTAM0AJmgAzQAhNAhpNACGmA2gQlACUCEoAKACgBaAFpgFACUAJQAUCCmAUALQIcBQA4CgB4FADgKBDhQA4UAMzWZqNzTGJQAZoATNABmgBKAEoEIaYCUCEoASgQlABQAtABQAtMBKACgAoEFABimAYoEKBQA4CgB4FADwKBDgKAFFADhQBCazNhKAEpgFACUAFACUAFAhDTAbQISgAoEJQAUALQAtMAoAKADFABigQYoAMUALimIUCgBwFAh4FADgKAHUALQAtAENZmwlACUwEoAKAEoAKACgQlMBpoEJQAUCCgBcUAFABTAXFAC4oAMUAGKBBigAxQIKYCigQ8UAOFADhQAtAC0ALQBDWZqJQMSgBKYBQAlABQISgBKYCGgQlAC0CCgBcUAFABTAUCkA7FMAxQAYoEJQAUCCmAooEOFADxQA4UAFAC0ALQBDWZqJQAlACUxhQAlABQIKAEoASmISgBcUCCgBaACgBcUAKBQAuKYC0CEoAQ0AJQISmAooEPFADhQA4UALQAtAC0AQ1maiUAFACUAJTAKAEoAKAEoAMUxBigAxQIWgAoAKAFAoAWgBaYBQIQ0ANNACUCCmIUUAOFADxQA4UALQAtABQBFWZqFACUAFACYpgFACUAFACUAFAgxTEFABQAUALQAooAWgAoAKYDTQIaaAEpiCgQ4UAOFAh4oGOFAC0ALSAKYEdZmglABQAUDDFACUwEoASgAoAKBBQIKYBQAUALQAtAC0AJQAhpgNJoENJoATNMQCgQ8UCHigB4oAWgYtABQAUAMrM0CgAoAKADFACUxiUAJQAlAgoAKYgoAKACgYtAC0AFAhDTAQmgBhNAhpNACZpiFBoEPFAEi0CHigB1ABQAUDEoAbWZoFABQAtABTAQ0ANNAxDQAlAhaAEpiCgAoGFAC0AFABmgBCaYhpNADCaBDSaBBmgABpiJFNAEimgB4NADqAFzQAlACE0AJWZoFAC0AFAC0wEIoAaaAG0AJQAUCCgApjCgAoAKADNABmgBpNMQ0mgBpNAhhNAgzQAoNADwaAHqaAJAaBDgaYC5oATNACZoAWszQKACgBaBDqYCGgBpoAYaBiUCCgBKYBQMKACgAoAM0AITQIaTQA0mmA0mgQ3NAhKAHCgBwNADwaAHg0AOBpiFzQAZoATNAD6zNAoAKAFoEOpgBoAaaAGGmAw0AJmgAzQMM0AGaADNABmgBM0AITQIaTQAhNMQw0AJQIKAFFADhQA4GgBwNADs0xC5oAM0CDNAEtZmoUCCgBaAHUwCgBppgRtQAw0ANzQAZoAM0AGaADNABmgBKAEoAQ0ANNMQhoEJQAlMBaQDgaAFBoAcDTAdmgQuaADNAgzQBPWZqFAgoAWgBaYC0CGmmBG1AyM0ANJoATNACZoAXNABmgAzQAUAJQAhoAQ0xDTQISmAUALQAUgHA0AKDTAdmgQuaBBQAtAFiszQKACgBaAFFMAoEIaYEbUDI2oAYaAEoASgAzQAuaACgAoAKAENMQ00AJTEFAhKACgAoAXNACg0AOBoAWgQtAC0AWazNAoAKACgBaYBQIQ0AMNMYw0AMIoAbQAlMAoAKACgAzSAKYhKAENACUxBQIKACgBKACgBaAHCgQ4UALQAUAWqzNAoAKACgApgFACGgQ00xjTQAwigBCKAG4pgJQAlABQAUCCgBKACgBKYgoEFABQISgAoAWgBRQA4UALQAUCLdZmoUAFABQAlMAoASgBDQA00wENACYoATFMBpFADSKAEoEJQAUAFABQAlMQtAgoASgQUAJQAUAKKAHCgBaBBQBbrM1CgAoAKACmAUAJQAlADaYBQAlACYpgIRQA0igBpFAhtABQAUAFMAoEFABQIKAEoASgQUALQAooAWgQUAW81mbC0CCgApgFACUAIaAEpgJQAUAFABQAhFMBpFADSKAGkUCExQAYoAMUAGKADFMQYoAMUCExSATFABQIKYBQAtABQIt5qDYM0ALmgQtIApgIaAENADaACmAlAC0ALQAUwGkUANIoAaRQAmKBBigAxQAYoAMUAGKBBigBMUAJigQmKAExTAKBC0AFAFnNQaig0AKDQAtAgoASgBDQAlMBKACgAFADhQAtMBCKAGkUAIRQAmKADFABigQmKADFACYoAXFABigQmKAExQAmKBCYpgJigAoAnzUGgZoAcDQAuaBC0AJQAhoASmAlABQAtADhQAtMAoATFACEUAJigAxQAYoATFAhMUAFABQAuKADFABigBpWgBCKBCYpgJigB+ag0DNADgaBDgaAFzQITNACUAJTAKACgBRQAopgOoAWgBKAEoAKACgAoASgBpoEJQAooAWgBaBhigBMUCEIoAQigBMUAJSLCgBQaBDgaQC5oEFACUwCgBKACmAtADhQA4UALQAUAJQAUAJQAUAJQAhoENoAWgBRQAooGLQAUAGKAGkUAIRQIZSKEoGKKBDhQAUCCgAoAKBBQAUwFoGKKAHCgBaACgAoASgAoASgBCaAEoEJmgAoAUGgBQaAHZoGFABQAUANoAjpDEoAWgBaAFoEFACUALQAUCCmAUAOFAxRQAtAC0AJQAUAJQAmaBDSaAEzQAmaYBmgBQaAHA0gFzQAuaBhmgAzQAlAEdIYUALQAtAgoAKAEoEFAC0AFMAoAUUDFFAC0ALQAUAJQAhoENNACE0wEoATNABmgBc0ALmgBc0gDNAC5oATNABmgBKRQlACigB1AgoASgQlABTAWgBKACgBaBi0ALQAZoAM0AFACGgQ00wENACUAJQAUCFzQMM0ALmgAzQAZoAM0AGaQC0igoAUUALQIWgBDQISmAUAFACUAFABQAuaBi5oAM0AGaBBmgBKAEpgIaAG0AJQAUCFoAM0DDNAC5oATNABmgAzQBJUlBQAooAWgQtACGmIaaACgAoASgBKACgBc0DCgQUAGaADNABTASgBDQAlACUAFAgoAKBhQAUAFABQAlAE1SUFAxRQIWgQtMBDQIQ0AJQAlAhKBiUAFABmgBc0AGaADNABTAKACgBKAEoASgQlABQAUAFAC0AFACUAFAE1SaBQAUCHCgQtMBKBCUAJQISgBDQA00DEzQAuaADNMBc0AGaADNABQAUAJQAlABQISgAoAKACgBaACgBKAEoAnqTQSgBRQIcKBC0xCUAJQISgBKAENADDQAmaYwzQAuaADNAC0AFABQAUAFAhKACgBKACgAoAWgAoELQAlAxKAJqk0EoAWgQooELTEFADaBCUABoENNMY00ANNAwzQAZoAXNAC0AFAC0CFoASgAoASgBKACgAoAWgQtABQAUANNAyWpNAoAKBCimIWgQUCEoASmIQ0ANNADTQMaaAEoGLmgAzQAtADhQIWgBaACgQhoASgYlACUALQIWgBaACgBKAENAyWpNBKYBQIcKBC0CEoEJTAKBCUANNADDQMQ0ANoGFAC5oAUGgBwNAhRQIWgBaAENACGgBtAwoAKAFzQIXNABmgAoAQ0DJKRoJQAtAhRQSLQIKYCUCCgBDQA00AMNAxpoGNoAM0AGaAFBoAcDQIcKBDqACgBDQAhoAQ0DEoAKADNAC5oEGaBhmgAoAkpGgUCCgQooELQIKYhKACgBKAGmgBpoGMNAxDQAlAwzQIUUAOFAhwoAcKBC0AJQAhoGNNACUAFABQAZoAXNABQAUAS0ixKACgQoNAhaYgoEFACUABoAaaAGmgYw0DENAxtABQAooEOFADhQIcKAFoASgBDQAhoGJQAUAFACUALQIKBi0CJDSLEoATNAhc0CHZpiCgQUAJQIKBjTQAhoGNNAxpoATFABigBQKAHCgBwoAWgAoAKACgBKAEoASgAoASgBaAAUAOoEONIoaTQAZoAUGmIUGgQtAgzQISgAoAQ0DGmgYlAxKACgAxQAtACigBRQAtAxaACgAoATFABigBCKAG0CEoAWgBRTAUUAf//Z";
async function getVideoInfo(filePath, logger) {
  const size = fs__default.statSync(filePath).size;
  return new Promise((resolve, reject) => {
    const ffmpegPath = process.env.FFMPEG_PATH;
    if (ffmpegPath)
      ffmpeg.setFfmpegPath(ffmpegPath);
    ffmpeg(filePath).ffprobe((err, metadata) => {
      if (err) {
        reject(err);
      } else {
        const videoStream = metadata.streams.find((s) => s.codec_type === "video");
        if (videoStream) {
          logger.log(`视频尺寸: ${videoStream.width}x${videoStream.height}`);
        } else {
          return reject(new Error("未找到视频流信息。"));
        }
        resolve({
          width: videoStream.width,
          height: videoStream.height,
          time: +(videoStream.duration ?? 10),
          format: metadata.format.format_name,
          size,
          filePath
        });
      }
    });
  });
}

const ALLOW_SAMPLE_RATE = [8e3, 12e3, 16e3, 24e3, 32e3, 44100, 48e3];
const EXIT_CODES = [0, 255];
const FFMPEG_PATH$1 = process.env.FFMPEG_PATH || "ffmpeg";
async function guessDuration(pttPath, logger) {
  const pttFileInfo = await fsPromise.stat(pttPath);
  const duration = Math.max(1, Math.floor(pttFileInfo.size / 1024 / 3));
  logger.log("通过文件大小估算语音的时长:", duration);
  return duration;
}
async function convert(filePath, pcmPath, logger) {
  return new Promise((resolve, reject) => {
    const cp = spawn(FFMPEG_PATH$1, ["-y", "-i", filePath, "-ar", "24000", "-ac", "1", "-f", "s16le", pcmPath]);
    cp.on("error", (err) => {
      logger.log("FFmpeg处理转换出错: ", err.message);
      reject(err);
    });
    cp.on("exit", async (code, signal) => {
      if (code == null || EXIT_CODES.includes(code)) {
        try {
          const data = await fsPromise.readFile(pcmPath);
          await fsPromise.unlink(pcmPath);
          resolve(data);
        } catch (err) {
          reject(err);
        }
      } else {
        logger.log(`FFmpeg exit: code=${code ?? "unknown"} sig=${signal ?? "unknown"}`);
        reject(new Error("FFmpeg处理转换失败"));
      }
    });
  });
}
async function handleWavFile(file, filePath, pcmPath, logger) {
  const { fmt } = getWavFileInfo(file);
  if (!ALLOW_SAMPLE_RATE.includes(fmt.sampleRate)) {
    return { input: await convert(filePath, pcmPath, logger), sampleRate: 24e3 };
  }
  return { input: file, sampleRate: fmt.sampleRate };
}
async function encodeSilk(filePath, TEMP_DIR, logger) {
  try {
    const file = await fsPromise.readFile(filePath);
    const pttPath = path$1.join(TEMP_DIR, randomUUID());
    if (!isSilk(file)) {
      logger.log(`语音文件${filePath}需要转换成silk`);
      const pcmPath = `${pttPath}.pcm`;
      const { input, sampleRate } = isWav(file) ? await handleWavFile(file, filePath, pcmPath, logger) : { input: await convert(filePath, pcmPath, logger), sampleRate: 24e3 };
      const silk = await encode(input, sampleRate);
      await fsPromise.writeFile(pttPath, silk.data);
      logger.log(`语音文件${filePath}转换成功!`, pttPath, "时长:", silk.duration);
      return {
        converted: true,
        path: pttPath,
        duration: silk.duration / 1e3
      };
    } else {
      let duration = 0;
      try {
        duration = getDuration(file) / 1e3;
      } catch (e) {
        logger.log("获取语音文件时长失败, 使用文件大小推测时长", filePath, e.stack);
        duration = await guessDuration(filePath, logger);
      }
      return {
        converted: false,
        path: filePath,
        duration
      };
    }
  } catch (error) {
    logger.logError.bind(logger)("convert silk failed", error.stack);
    return {};
  }
}

class NTQQFileApi {
  context;
  core;
  rkeyManager;
  packetRkey;
  constructor(context, core) {
    this.context = context;
    this.core = core;
    this.rkeyManager = new RkeyManager(["https://llob.linyuchen.net/rkey", "http://napcat-sign.wumiao.wang:2082/rkey"], this.context.logger);
  }
  async copyFile(filePath, destPath) {
    await this.core.util.copyFile(filePath, destPath);
  }
  async getFileSize(filePath) {
    return await this.core.util.getFileSize(filePath);
  }
  async getVideoUrl(peer, msgId, elementId) {
    return (await this.context.session.getRichMediaService().getVideoPlayUrlV2(peer, msgId, elementId, 0, {
      downSourceType: 1,
      triggerType: 1
    })).urlResult.domainUrl;
  }
  async uploadFile(filePath, elementType = ElementType.PIC, elementSubType = 0) {
    const fileMd5 = await calculateFileMD5(filePath);
    const extOrEmpty = (await fileTypeFromFile(filePath))?.ext;
    const ext = extOrEmpty ? `.${extOrEmpty}` : "";
    let fileName = `${path$2.basename(filePath)}`;
    if (fileName.indexOf(".") === -1) {
      fileName += ext;
    }
    const mediaPath = this.context.session.getMsgService().getRichMediaFilePathForGuild({
      md5HexStr: fileMd5,
      fileName,
      elementType,
      elementSubType,
      thumbSize: 0,
      needCreate: true,
      downloadType: 1,
      file_uuid: ""
    });
    await this.copyFile(filePath, mediaPath);
    const fileSize = await this.getFileSize(filePath);
    return {
      md5: fileMd5,
      fileName,
      path: mediaPath,
      fileSize,
      ext
    };
  }
  async createValidSendFileElement(context, filePath, fileName = "", folderId = "") {
    const {
      fileName: _fileName,
      path: path2,
      fileSize
    } = await this.core.apis.FileApi.uploadFile(filePath, ElementType.FILE);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    context.deleteAfterSentFiles.push(path2);
    return {
      elementType: ElementType.FILE,
      elementId: "",
      fileElement: {
        fileName: fileName || _fileName,
        folderId,
        filePath: path2,
        fileSize: fileSize.toString()
      }
    };
  }
  async createValidSendPicElement(context, picPath, summary = "", subType = 0) {
    const { md5, fileName, path: path2, fileSize } = await this.core.apis.FileApi.uploadFile(picPath, ElementType.PIC, subType);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    const imageSize2 = await this.core.apis.FileApi.getImageSize(picPath);
    context.deleteAfterSentFiles.push(path2);
    return {
      elementType: ElementType.PIC,
      elementId: "",
      picElement: {
        md5HexStr: md5,
        fileSize: fileSize.toString(),
        picWidth: imageSize2.width,
        picHeight: imageSize2.height,
        fileName,
        sourcePath: path2,
        original: true,
        picType: isGIF(picPath) ? PicType.gif : PicType.jpg,
        picSubType: subType,
        fileUuid: "",
        fileSubId: "",
        thumbFileSize: 0,
        summary
      }
    };
  }
  async createValidSendVideoElement(context, filePath, fileName = "", diyThumbPath = "") {
    const logger = this.core.context.logger;
    let videoInfo = {
      width: 1920,
      height: 1080,
      time: 15,
      format: "mp4",
      size: 0,
      filePath
    };
    try {
      videoInfo = await getVideoInfo(filePath, logger);
    } catch (e) {
      logger.logError.bind(logger)("获取视频信息失败，将使用默认值", e);
    }
    let fileExt = "mp4";
    try {
      const tempExt = (await fileTypeFromFile(filePath))?.ext;
      if (tempExt) fileExt = tempExt;
    } catch (e) {
      this.context.logger.logError.bind(logger)("获取文件类型失败", e);
    }
    const newFilePath = filePath + "." + fileExt;
    fs__default.copyFileSync(filePath, newFilePath);
    context.deleteAfterSentFiles.push(newFilePath);
    filePath = newFilePath;
    const { fileName: _fileName, path: path2, fileSize, md5 } = await this.core.apis.FileApi.uploadFile(filePath, ElementType.VIDEO);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    videoInfo.size = fileSize;
    let thumb = path2.replace(`${path$1.sep}Ori${path$1.sep}`, `${path$1.sep}Thumb${path$1.sep}`);
    thumb = path$1.dirname(thumb);
    const thumbPath = /* @__PURE__ */ new Map();
    const _thumbPath = await new Promise((resolve, reject) => {
      const thumbFileName = `${md5}_0.png`;
      const thumbPath2 = path$1.join(thumb, thumbFileName);
      ffmpeg(filePath).on("error", (err) => {
        logger.logDebug("获取视频封面失败，使用默认封面", err);
        if (diyThumbPath) {
          fsPromise.copyFile(diyThumbPath, thumbPath2).then(() => {
            resolve(thumbPath2);
          }).catch(reject);
        } else {
          fs__default.writeFileSync(thumbPath2, Buffer.from(defaultVideoThumbB64, "base64"));
          resolve(thumbPath2);
        }
      }).screenshots({
        timestamps: [0],
        filename: thumbFileName,
        folder: thumb,
        size: videoInfo.width + "x" + videoInfo.height
      }).on("end", () => {
        resolve(thumbPath2);
      });
    });
    const thumbSize = _thumbPath ? (await fsPromise.stat(_thumbPath)).size : 0;
    thumbPath.set(0, _thumbPath);
    const thumbMd5 = _thumbPath ? await calculateFileMD5(_thumbPath) : "";
    context.deleteAfterSentFiles.push(path2);
    const uploadName = (fileName || _fileName).toLocaleLowerCase().endsWith("." + fileExt.toLocaleLowerCase()) ? fileName || _fileName : (fileName || _fileName) + "." + fileExt;
    return {
      elementType: ElementType.VIDEO,
      elementId: "",
      videoElement: {
        fileName: uploadName,
        filePath: path2,
        videoMd5: md5,
        thumbMd5,
        fileTime: videoInfo.time,
        thumbPath,
        thumbSize,
        thumbWidth: videoInfo.width,
        thumbHeight: videoInfo.height,
        fileSize: "" + fileSize
      }
    };
  }
  async createValidSendPttElement(pttPath) {
    const { converted, path: silkPath, duration } = await encodeSilk(pttPath, this.core.NapCatTempPath, this.core.context.logger);
    if (!silkPath) {
      throw new Error("语音转换失败, 请检查语音文件是否正常");
    }
    const { md5, fileName, path: path2, fileSize } = await this.core.apis.FileApi.uploadFile(silkPath, ElementType.PTT);
    if (fileSize === 0) {
      throw new Error("文件异常，大小为0");
    }
    if (converted) {
      fsPromise.unlink(silkPath).then().catch(
        (e) => this.context.logger.logError.bind(this.context.logger)("删除临时文件失败", e)
      );
    }
    return {
      elementType: ElementType.PTT,
      elementId: "",
      pttElement: {
        fileName,
        filePath: path2,
        md5HexStr: md5,
        fileSize: fileSize.toString(),
        duration: duration ?? 1,
        formatType: 1,
        voiceType: 1,
        voiceChangeType: 0,
        canConvert2Text: true,
        waveAmplitudes: [
          0,
          18,
          9,
          23,
          16,
          17,
          16,
          15,
          44,
          17,
          24,
          20,
          14,
          15,
          17
        ],
        fileSubId: "",
        playState: 1,
        autoConvertText: 0
      }
    };
  }
  async downloadFileForModelId(peer, modelId, unknown, timeout = 1e3 * 60 * 2) {
    const [, fileTransNotifyInfo] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelRichMediaService/downloadFileForModelId",
      "NodeIKernelMsgListener/onRichMediaDownloadComplete",
      [peer, [modelId], unknown],
      () => true,
      (arg) => arg?.commonFileInfo?.fileModelId === modelId,
      1,
      timeout
    );
    return fileTransNotifyInfo.filePath;
  }
  async downloadRawMsgMedia(msg) {
    const res = await Promise.all(
      msg.map(
        (m) => Promise.all(
          m.elements.filter(
            (element) => element.elementType === ElementType.PIC || element.elementType === ElementType.VIDEO || element.elementType === ElementType.PTT || element.elementType === ElementType.FILE
          ).map(
            (element) => this.downloadMedia(m.msgId, m.chatType, m.peerUid, element.elementId, "", "", 1e3 * 60 * 2, true)
          )
        )
      )
    );
    msg.forEach((m, msgIndex) => {
      const elementResults = res[msgIndex];
      let elementIndex = 0;
      m.elements.forEach((element) => {
        if (element.elementType === ElementType.PIC || element.elementType === ElementType.VIDEO || element.elementType === ElementType.PTT || element.elementType === ElementType.FILE) {
          switch (element.elementType) {
            case ElementType.PIC:
              element.picElement.sourcePath = elementResults[elementIndex];
              break;
            case ElementType.VIDEO:
              element.videoElement.filePath = elementResults[elementIndex];
              break;
            case ElementType.PTT:
              element.pttElement.filePath = elementResults[elementIndex];
              break;
            case ElementType.FILE:
              element.fileElement.filePath = elementResults[elementIndex];
              break;
          }
          elementIndex++;
        }
      });
    });
  }
  async downloadMedia(msgId, chatType, peerUid, elementId, thumbPath, sourcePath, timeout = 1e3 * 60 * 2, force = false) {
    if (sourcePath && fs__default.existsSync(sourcePath)) {
      if (force) {
        try {
          await fsPromise.unlink(sourcePath);
        } catch (e) {
        }
      } else {
        return sourcePath;
      }
    }
    const [, completeRetData] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/downloadRichMedia",
      "NodeIKernelMsgListener/onRichMediaDownloadComplete",
      [{
        fileModelId: "0",
        downloadSourceType: 0,
        triggerType: 1,
        msgId,
        chatType,
        peerUid,
        elementId,
        thumbSize: 0,
        downloadType: 1,
        filePath: thumbPath
      }],
      () => true,
      (arg) => arg.msgElementId === elementId && arg.msgId === msgId,
      1,
      timeout
    );
    return completeRetData.filePath;
  }
  async getImageSize(filePath) {
    return new Promise((resolve, reject) => {
      imageSize(filePath, (err, dimensions) => {
        if (err) {
          reject(err);
        } else {
          if (!dimensions) {
            reject(new Error("获取图片尺寸失败"));
          } else {
            resolve(dimensions);
          }
        }
      });
    });
  }
  async searchForFile(keys) {
    const randomResultId = 1e5 + Math.floor(Math.random() * 1e4);
    let searchId = 0;
    const [, searchResult] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelFileAssistantService/searchFile",
      "NodeIKernelFileAssistantListener/onFileSearch",
      [
        keys,
        { resultType: 2, pageLimit: 1 },
        randomResultId
      ],
      (ret) => {
        searchId = ret;
        return true;
      },
      (result) => result.searchId === searchId && result.resultId === randomResultId
    );
    return searchResult.resultItems[0];
  }
  async downloadFileById(fileId, fileSize = 1024576, estimatedTime = fileSize * 1e3 / 1024576 + 5e3) {
    const [, fileData] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelFileAssistantService/downloadFile",
      "NodeIKernelFileAssistantListener/onFileStatusChanged",
      [[fileId]],
      (ret) => ret.result === 0,
      (status) => status.fileStatus === 2 && status.fileProgress === "0",
      1,
      estimatedTime
      // estimate 1MB/s
    );
    return fileData.filePath;
  }
  async getImageUrl(element) {
    if (!element) {
      return "";
    }
    const url = element.originImageUrl ?? "";
    const md5HexStr = element.md5HexStr;
    const fileMd5 = element.md5HexStr;
    if (url) {
      const parsedUrl = new URL(IMAGE_HTTP_HOST + url);
      const urlRkey = parsedUrl.searchParams.get("rkey");
      const imageAppid = parsedUrl.searchParams.get("appid");
      const isNTV2 = imageAppid && ["1406", "1407"].includes(imageAppid);
      const imageFileId = parsedUrl.searchParams.get("fileid");
      const rkeyData = {
        private_rkey: "CAQSKAB6JWENi5LM_xp9vumLbuThJSaYf-yzMrbZsuq7Uz2qEc3Rbib9LP4",
        group_rkey: "CAQSKAB6JWENi5LM_xp9vumLbuThJSaYf-yzMrbZsuq7Uz2qffcqm614gds",
        online_rkey: false
      };
      try {
        if (this.core.apis.PacketApi.available) {
          const rkey_expired_private = !this.packetRkey || this.packetRkey[0].time + Number(this.packetRkey[0].ttl) < Date.now() / 1e3;
          const rkey_expired_group = !this.packetRkey || this.packetRkey[0].time + Number(this.packetRkey[0].ttl) < Date.now() / 1e3;
          if (rkey_expired_private || rkey_expired_group) {
            this.packetRkey = await this.core.apis.PacketApi.sendRkeyPacket();
          }
          if (this.packetRkey && this.packetRkey.length > 0) {
            rkeyData.group_rkey = this.packetRkey[1].rkey.slice(6);
            rkeyData.private_rkey = this.packetRkey[0].rkey.slice(6);
            rkeyData.online_rkey = true;
          }
        }
      } catch (error) {
        this.context.logger.logError.bind(this.context.logger)("获取rkey失败", error.message);
      }
      if (!rkeyData.online_rkey) {
        try {
          const tempRkeyData = await this.rkeyManager.getRkey();
          rkeyData.group_rkey = tempRkeyData.group_rkey;
          rkeyData.private_rkey = tempRkeyData.private_rkey;
          rkeyData.online_rkey = tempRkeyData.expired_time > Date.now() / 1e3;
        } catch (e) {
          this.context.logger.logError.bind(this.context.logger)("获取rkey失败 Fallback Old Mode", e);
        }
      }
      if (isNTV2 && urlRkey) {
        return IMAGE_HTTP_HOST_NT + urlRkey;
      } else if (isNTV2 && rkeyData.online_rkey) {
        const rkey = imageAppid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
        return IMAGE_HTTP_HOST_NT + url + `&rkey=${rkey}`;
      } else if (isNTV2 && imageFileId) {
        const rkey = imageAppid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
        return IMAGE_HTTP_HOST + `/download?appid=${imageAppid}&fileid=${imageFileId}&rkey=${rkey}`;
      }
    }
    if (fileMd5 || md5HexStr) {
      return `${IMAGE_HTTP_HOST}/gchatpic_new/0/0-0-${(fileMd5 ?? md5HexStr).toUpperCase()}/0`;
    }
    this.context.logger.logDebug("图片url获取失败", element);
    return "";
  }
}

class LimitedHashTable {
  keyToValue = /* @__PURE__ */ new Map();
  valueToKey = /* @__PURE__ */ new Map();
  maxSize;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
  resize(count) {
    this.maxSize = count;
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
    while (this.keyToValue.size !== this.valueToKey.size) {
      this.keyToValue.clear();
      this.valueToKey.clear();
    }
    while (this.keyToValue.size > this.maxSize || this.valueToKey.size > this.maxSize) {
      const oldestKey = this.keyToValue.keys().next().value;
      this.valueToKey.delete(this.keyToValue.get(oldestKey));
      this.keyToValue.delete(oldestKey);
    }
  }
  getValue(key) {
    return this.keyToValue.get(key);
  }
  getKey(value) {
    return this.valueToKey.get(value);
  }
  deleteByValue(value) {
    const key = this.valueToKey.get(value);
    if (key !== void 0) {
      this.keyToValue.delete(key);
      this.valueToKey.delete(value);
    }
  }
  deleteByKey(key) {
    const value = this.keyToValue.get(key);
    if (value !== void 0) {
      this.keyToValue.delete(key);
      this.valueToKey.delete(value);
    }
  }
  getKeyList() {
    return Array.from(this.keyToValue.keys());
  }
  //获取最近刚写入的几个值
  getHeads(size) {
    const keyList = this.getKeyList();
    if (keyList.length === 0) {
      return void 0;
    }
    const result = [];
    const listSize = Math.min(size, keyList.length);
    for (let i = 0; i < listSize; i++) {
      const key = keyList[listSize - i];
      result.push({ key, value: this.keyToValue.get(key) });
    }
    return result;
  }
}
class MessageUniqueWrapper {
  msgDataMap;
  msgIdMap;
  constructor(maxMap = 1e3) {
    this.msgIdMap = new LimitedHashTable(maxMap);
    this.msgDataMap = new LimitedHashTable(maxMap);
  }
  getRecentMsgIds(Peer2, size) {
    const heads = this.msgIdMap.getHeads(size);
    if (!heads) {
      return [];
    }
    const data = heads.map((t) => MessageUnique.getMsgIdAndPeerByShortId(t.value));
    const ret = data.filter((t) => t?.Peer.chatType === Peer2.chatType && t?.Peer.peerUid === Peer2.peerUid);
    return ret.map((t) => t?.MsgId).filter((t) => t !== void 0);
  }
  createUniqueMsgId(peer, msgId) {
    const key = `${msgId}|${peer.chatType}|${peer.peerUid}`;
    const hash = crypto__default.createHash("md5").update(key).digest();
    hash[0] &= 127;
    const shortId = hash.readInt32BE(0);
    this.msgIdMap.set(msgId, shortId);
    this.msgDataMap.set(key, shortId);
    return shortId;
  }
  getMsgIdAndPeerByShortId(shortId) {
    const data = this.msgDataMap.getKey(shortId);
    if (data) {
      const [msgId, chatTypeStr, peerUid] = data.split("|");
      const peer = {
        chatType: parseInt(chatTypeStr),
        peerUid,
        guildId: ""
      };
      return { MsgId: msgId, Peer: peer };
    }
    return void 0;
  }
  getShortIdByMsgId(msgId) {
    return this.msgIdMap.getValue(msgId);
  }
  getPeerByMsgId(msgId) {
    const shortId = this.msgIdMap.getValue(msgId);
    if (!shortId) return void 0;
    return this.getMsgIdAndPeerByShortId(shortId);
  }
  resize(maxSize) {
    this.msgIdMap.resize(maxSize);
    this.msgDataMap.resize(maxSize);
  }
}
const MessageUnique = new MessageUniqueWrapper();

class NTQQFriendApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async setBuddyRemark(uid, remark) {
    return this.context.session.getBuddyService().setBuddyRemark({ uid, remark });
  }
  async getBuddyV2SimpleInfoMap(refresh = false) {
    const buddyService = this.context.session.getBuddyService();
    const buddyListV2 = refresh ? await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL) : await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL);
    const uids = buddyListV2.data.flatMap((item) => item.buddyUids);
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
  }
  async getBuddyV2(refresh = false) {
    return Array.from((await this.getBuddyV2SimpleInfoMap(refresh)).values());
  }
  async getBuddyIdMap(refresh = false) {
    const retMap = new LimitedHashTable(5e3);
    const data = await this.getBuddyV2SimpleInfoMap(refresh);
    data.forEach((value) => retMap.set(value.uin, value.uid));
    return retMap;
  }
  async delBuudy(uid, tempBlock = false, tempBothDel = false) {
    return this.context.session.getBuddyService().delBuddy({
      friendUid: uid,
      tempBlock,
      tempBothDel
    });
  }
  async getBuddyV2ExWithCate(refresh = false) {
    const categoryMap = /* @__PURE__ */ new Map();
    const buddyService = this.context.session.getBuddyService();
    const buddyListV2 = refresh ? (await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL)).data : (await buddyService.getBuddyListV2("0", BuddyListReqType.KNOMAL)).data;
    const uids = buddyListV2.flatMap((item) => {
      item.buddyUids.forEach((uid) => {
        categoryMap.set(uid, { categoryId: item.categoryId, categoryName: item.categroyName });
      });
      return item.buddyUids;
    });
    const data = await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
    return buddyListV2.map((category) => ({
      categoryId: category.categoryId,
      categorySortId: category.categorySortId,
      categoryName: category.categroyName,
      categoryMbCount: category.categroyMbCount,
      onlineCount: category.onlineCount,
      buddyList: category.buddyUids.map((uid) => data.get(uid)).filter((value) => value)
    }));
  }
  async isBuddy(uid) {
    return this.context.session.getBuddyService().isBuddy(uid);
  }
  async clearBuddyReqUnreadCnt() {
    return this.context.session.getBuddyService().clearBuddyReqUnreadCnt();
  }
  async getBuddyReq() {
    const [, ret] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelBuddyService/getBuddyReq",
      "NodeIKernelBuddyListener/onBuddyReqChange",
      []
    );
    return ret;
  }
  async handleFriendRequest(flag, accept) {
    const data = flag.split("|");
    if (data.length < 2) {
      return;
    }
    const friendUid = data[0];
    const reqTime = data[1];
    this.context.session.getBuddyService()?.approvalFriendRequest({
      friendUid,
      reqTime,
      accept
    });
  }
}

class NTQQGroupApi {
  context;
  core;
  groupCache = /* @__PURE__ */ new Map();
  groupMemberCache = /* @__PURE__ */ new Map();
  groups = [];
  essenceLRU = new LimitedHashTable(1e3);
  session;
  constructor(context, core) {
    this.context = context;
    this.core = core;
    this.initCache().then().catch(context.logger.logError.bind(context.logger));
  }
  async initCache() {
    this.groups = await this.getGroups();
    for (const group of this.groups) {
      this.groupCache.set(group.groupCode, group);
    }
    this.context.logger.logDebug(`加载${this.groups.length}个群组缓存完成`);
  }
  async getCoreAndBaseInfo(uids) {
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getCoreAndBaseInfo",
      "nodeStore",
      uids
    );
  }
  async fetchGroupEssenceList(groupCode) {
    const pskey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().fetchGroupEssenceList({
      groupCode,
      pageStart: 0,
      pageLimit: 300
    }, pskey);
  }
  async getGroupShutUpMemberList(groupCode) {
    return this.context.session.getGroupService().getGroupShutUpMemberList(groupCode);
  }
  async clearGroupNotifiesUnreadCount(uk) {
    return this.context.session.getGroupService().clearGroupNotifiesUnreadCount(uk);
  }
  async setGroupAvatar(gc, filePath) {
    return this.context.session.getGroupService().setHeader(gc, filePath);
  }
  async getGroups(forced = false) {
    const [, , groupList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelGroupService/getGroupList",
      "NodeIKernelGroupListener/onGroupListUpdate",
      [forced]
    );
    return groupList;
  }
  async getGroupExtFE0Info(groupCode, forced = true) {
    return this.context.session.getGroupService().getGroupExt0xEF0Info(
      groupCode,
      [],
      {
        bindGuildId: 1,
        blacklistExpireTime: 1,
        companyId: 1,
        essentialMsgPrivilege: 1,
        essentialMsgSwitch: 1,
        fullGroupExpansionSeq: 1,
        fullGroupExpansionSwitch: 1,
        gangUpId: 1,
        groupAioBindGuildId: 1,
        groupBindGuildIds: 1,
        groupBindGuildSwitch: 1,
        groupExcludeGuildIds: 1,
        groupExtFlameData: 1,
        groupFlagPro1: 1,
        groupInfoExtSeq: 1,
        groupOwnerId: 1,
        groupSquareSwitch: 1,
        hasGroupCustomPortrait: 1,
        inviteRobotMemberExamine: 1,
        inviteRobotMemberSwitch: 1,
        inviteRobotSwitch: 1,
        isLimitGroupRtc: 1,
        lightCharNum: 1,
        luckyWord: 1,
        luckyWordId: 1,
        msgEventSeq: 1,
        qqMusicMedalSwitch: 1,
        reserve: 1,
        showPlayTogetherSwitch: 1,
        starId: 1,
        todoSeq: 1,
        viewedMsgDisappearTime: 1
      },
      forced
    );
  }
  async getGroup(groupCode, forced = false) {
    let group = this.groupCache.get(groupCode.toString());
    if (!group) {
      try {
        const groupList = await this.getGroups(forced);
        if (groupList.length) {
          groupList.forEach((g) => {
            this.groupCache.set(g.groupCode, g);
          });
        }
      } catch (e) {
        return void 0;
      }
    }
    group = this.groupCache.get(groupCode.toString());
    return group;
  }
  async getGroupMemberAll(groupCode, forced = false) {
    return this.context.session.getGroupService().getAllMemberList(groupCode, forced);
  }
  async getGroupMember(groupCode, memberUinOrUid) {
    const groupCodeStr = groupCode.toString();
    const memberUinOrUidStr = memberUinOrUid.toString();
    let members = this.groupMemberCache.get(groupCodeStr);
    if (!members) {
      try {
        members = await this.getGroupMembers(groupCodeStr);
        this.groupMemberCache.set(groupCodeStr, members);
      } catch (e) {
        return null;
      }
    }
    function getMember() {
      let member2;
      if (isNumeric(memberUinOrUidStr)) {
        member2 = Array.from(members.values()).find((member3) => member3.uin === memberUinOrUidStr);
      } else {
        member2 = members.get(memberUinOrUidStr);
      }
      return member2;
    }
    let member = getMember();
    if (!member) {
      members = await this.getGroupMembers(groupCodeStr);
      member = getMember();
    }
    return member;
  }
  async getGroupRecommendContactArkJson(groupCode) {
    return this.context.session.getGroupService().getGroupRecommendContactArkJson(groupCode);
  }
  async CreatGroupFileFolder(groupCode, folderName) {
    return this.context.session.getRichMediaService().createGroupFolder(groupCode, folderName);
  }
  async DelGroupFile(groupCode, files) {
    return this.context.session.getRichMediaService().deleteGroupFile(groupCode, [102], files);
  }
  async DelGroupFileFolder(groupCode, folderId) {
    return this.context.session.getRichMediaService().deleteGroupFolder(groupCode, folderId);
  }
  async addGroupEssence(GroupCode, msgId) {
    const MsgData = await this.context.session.getMsgService().getMsgsIncludeSelf({
      chatType: 2,
      guildId: "",
      peerUid: GroupCode
    }, msgId, 1, false);
    const param = {
      groupCode: GroupCode,
      msgRandom: parseInt(MsgData.msgList[0].msgRandom),
      msgSeq: parseInt(MsgData.msgList[0].msgSeq)
    };
    return this.context.session.getGroupService().addGroupEssence(param);
  }
  async kickMemberV2Inner(param) {
    return this.context.session.getGroupService().kickMemberV2(param);
  }
  async deleteGroupBulletin(GroupCode, noticeId) {
    const psKey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().deleteGroupBulletin(GroupCode, psKey, noticeId);
  }
  async quitGroupV2(GroupCode, needDeleteLocalMsg) {
    const param = {
      groupCode: GroupCode,
      needDeleteLocalMsg
    };
    return this.context.session.getGroupService().quitGroupV2(param);
  }
  async removeGroupEssenceBySeq(GroupCode, msgRandom, msgSeq) {
    const param = {
      groupCode: GroupCode,
      msgRandom: parseInt(msgRandom),
      msgSeq: parseInt(msgSeq)
    };
    return this.context.session.getGroupService().removeGroupEssence(param);
  }
  async removeGroupEssence(GroupCode, msgId) {
    const MsgData = await this.context.session.getMsgService().getMsgsIncludeSelf({
      chatType: 2,
      guildId: "",
      peerUid: GroupCode
    }, msgId, 1, false);
    const param = {
      groupCode: GroupCode,
      msgRandom: parseInt(MsgData.msgList[0].msgRandom),
      msgSeq: parseInt(MsgData.msgList[0].msgSeq)
    };
    return this.context.session.getGroupService().removeGroupEssence(param);
  }
  async getSingleScreenNotifies(doubt, num) {
    const [, , , notifies] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelGroupService/getSingleScreenNotifies",
      "NodeIKernelGroupListener/onGroupSingleScreenNotifies",
      [
        doubt,
        "",
        num
      ]
    );
    return notifies;
  }
  async getGroupMemberV2(GroupCode, uid, forced = false) {
    const Listener = this.core.eventWrapper.registerListen(
      "NodeIKernelGroupListener/onMemberInfoChange",
      1,
      forced ? 5e3 : 250,
      (params, _, members) => params === GroupCode && members.size > 0
    );
    const retData = await this.core.eventWrapper.createEventFunction("NodeIKernelGroupService/getMemberInfo")(GroupCode, [uid], forced);
    if (retData.result !== 0) {
      throw new Error(`${retData.errMsg}`);
    }
    const result = await Listener;
    let member;
    if (Array.isArray(result) && result?.[2] instanceof Map) {
      const members = result[2];
      member = members.get(uid);
    }
    return member;
  }
  async searchGroup(groupCode) {
    const [, ret] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelSearchService/searchGroup",
      "NodeIKernelSearchListener/onSearchGroupResult",
      [{
        keyWords: groupCode,
        groupNum: 25,
        exactSearch: false,
        penetrate: ""
      }],
      (ret2) => ret2.result === 0,
      (params) => !!params.groupInfos.find((g) => g.groupCode === groupCode),
      1,
      5e3
    );
    return ret.groupInfos.find((g) => g.groupCode === groupCode);
  }
  async getGroupMemberEx(GroupCode, uid, forced = false, retry = 2) {
    const data = await solveAsyncProblem((eventWrapper, GroupCode2, uid2, forced2 = false) => {
      return eventWrapper.callNormalEventV2(
        "NodeIKernelGroupService/getMemberInfo",
        "NodeIKernelGroupListener/onMemberInfoChange",
        [GroupCode2, [uid2], forced2],
        (ret) => ret.result === 0,
        (params, _, members) => params === GroupCode2 && members.size > 0 && members.has(uid2),
        1,
        forced2 ? 2500 : 250
      );
    }, this.core.eventWrapper, GroupCode, uid, forced);
    if (data && data[3] instanceof Map && data[3].has(uid)) {
      return data[3].get(uid);
    }
    if (retry > 0) {
      const trydata = await this.getGroupMemberEx(GroupCode, uid, true, retry - 1);
      if (trydata) return trydata;
    }
    return void 0;
  }
  async tryGetGroupMembersV2(modeListener = false, groupQQ, num = 30, timeout = 100) {
    const sceneId = this.context.session.getGroupService().createMemberListScene(groupQQ, "groupMemberList_MainWindow_1");
    const once = this.core.eventWrapper.registerListen("NodeIKernelGroupListener/onMemberListChange", 0, timeout, (params) => params.sceneId === sceneId).catch(() => {
    });
    const result = await this.context.session.getGroupService().getNextMemberList(sceneId, void 0, num);
    if (result.errCode !== 0) {
      throw new Error("获取群成员列表出错," + result.errMsg);
    }
    let resMode2;
    if (modeListener) {
      const ret = (await once)?.[0];
      if (ret) {
        resMode2 = ret;
      }
    }
    this.context.session.getGroupService().destroyMemberListScene(sceneId);
    return {
      infos: resMode2?.infos || result.result.infos,
      finish: result.result.finish,
      hasNext: resMode2?.hasNext
    };
  }
  async getGroupMembersV2(groupQQ, num = 3e3) {
    let res = await this.tryGetGroupMembersV2(true, groupQQ);
    if (res.hasNext || !res.finish || res.infos.size === 0) {
      res = await this.tryGetGroupMembersV2(false, groupQQ, num);
    }
    if ((res.infos.size === 0 || res.infos.size === 30) && res.finish) {
      res = await this.tryGetGroupMembersV2(true, groupQQ, num);
    }
    return res.infos;
  }
  async getGroupMembers(groupQQ, num = 3e3) {
    const groupService = this.context.session.getGroupService();
    const sceneId = groupService.createMemberListScene(groupQQ, "groupMemberList_MainWindow");
    const result = await groupService.getNextMemberList(sceneId, void 0, num);
    if (result.errCode !== 0) {
      throw new Error("获取群成员列表出错," + result.errMsg);
    }
    this.context.logger.logDebug(`获取群(${groupQQ})成员列表结果:`, `members: ${result.result.infos.size}`);
    return result.result.infos;
  }
  async getGroupFileCount(Gids) {
    return this.context.session.getRichMediaService().batchGetGroupFileCount(Gids);
  }
  async getArkJsonGroupShare(GroupCode) {
    const ret = await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelGroupService/getGroupRecommendContactArkJson",
      GroupCode
    );
    return ret.arkJson;
  }
  //需要异常处理
  async uploadGroupBulletinPic(GroupCode, imageurl) {
    const _Pskey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return this.context.session.getGroupService().uploadGroupBulletinPic(GroupCode, _Pskey, imageurl);
  }
  async handleGroupRequest(flag, operateType, reason) {
    const flagitem = flag.split("|");
    const groupCode = flagitem[0];
    const seq = flagitem[1];
    const type = parseInt(flagitem[2]);
    return this.context.session.getGroupService().operateSysNotify(
      false,
      {
        operateType,
        // 2 拒绝
        targetMsg: {
          seq,
          // 通知序列号
          type,
          groupCode,
          postscript: reason ?? " "
          // 仅传空值可能导致处理失败，故默认给个空格
        }
      }
    );
  }
  async quitGroup(groupQQ) {
    return this.context.session.getGroupService().quitGroup(groupQQ);
  }
  async kickMember(groupQQ, kickUids, refuseForever = false, kickReason = "") {
    return this.context.session.getGroupService().kickMember(groupQQ, kickUids, refuseForever, kickReason);
  }
  async banMember(groupQQ, memList) {
    return this.context.session.getGroupService().setMemberShutUp(groupQQ, memList);
  }
  async banGroup(groupQQ, shutUp) {
    return this.context.session.getGroupService().setGroupShutUp(groupQQ, shutUp);
  }
  async setMemberCard(groupQQ, memberUid, cardName) {
    return this.context.session.getGroupService().modifyMemberCardName(groupQQ, memberUid, cardName);
  }
  async setMemberRole(groupQQ, memberUid, role) {
    return this.context.session.getGroupService().modifyMemberRole(groupQQ, memberUid, role);
  }
  async setGroupName(groupQQ, groupName) {
    return this.context.session.getGroupService().modifyGroupName(groupQQ, groupName, false);
  }
  async publishGroupBulletin(groupQQ, content, picInfo = void 0, pinned = 0, confirmRequired = 0) {
    const psKey = (await this.core.apis.UserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    const data = {
      text: encodeURI(content),
      picInfo,
      oldFeedsId: "",
      pinned,
      confirmRequired
    };
    return this.context.session.getGroupService().publishGroupBulletin(groupQQ, psKey, data);
  }
  async getGroupRemainAtTimes(GroupCode) {
    return this.context.session.getGroupService().getGroupRemainAtTimes(GroupCode);
  }
  async getMemberExtInfo(groupCode, uin) {
    return this.context.session.getGroupService().getMemberExtInfo(
      {
        groupCode,
        sourceType: MemberExtSourceType.TITLETYPE,
        beginUin: "0",
        dataTime: "0",
        uinList: [uin],
        uinNum: "",
        seq: "",
        groupType: "",
        richCardNameVer: "",
        memberExtFilter: {
          memberLevelInfoUin: 1,
          memberLevelInfoPoint: 1,
          memberLevelInfoActiveDay: 1,
          memberLevelInfoLevel: 1,
          memberLevelInfoName: 1,
          levelName: 1,
          dataTime: 1,
          userShowFlag: 1,
          sysShowFlag: 1,
          timeToUpdate: 1,
          nickName: 1,
          specialTitle: 1,
          levelNameNew: 1,
          userShowFlagNew: 1,
          msgNeedField: 1,
          cmdUinFlagExt3Grocery: 1,
          memberIcon: 1,
          memberInfoSeq: 1
        }
      }
    );
  }
}

class NTQQMsgApi {
  // nt_qq//global//nt_data//Emoji//emoji-resource//sysface_res/apng/ 下可以看到所有QQ表情预览
  // nt_qq\global\nt_data\Emoji\emoji-resource\face_config.json 里面有所有表情的id, 自带表情id是QSid, 标准emoji表情id是QCid
  // 其实以官方文档为准是最好的，https://bot.q.qq.com/wiki/develop/api-v2/openapi/emoji/model.html#EmojiType
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async getAioFirstViewLatestMsgs(peer, MsgCount) {
    return this.context.session.getMsgService().getAioFirstViewLatestMsgs(peer, MsgCount);
  }
  async sendShowInputStatusReq(peer, eventType) {
    return this.context.session.getMsgService().sendShowInputStatusReq(peer.chatType, eventType, peer.peerUid);
  }
  async getMsgEmojiLikesList(peer, msgSeq, emojiId, emojiType, count = 20) {
    return this.context.session.getMsgService().getMsgEmojiLikesList(peer, msgSeq, emojiId, emojiType, "", false, count);
  }
  async setEmojiLike(peer, msgSeq, emojiId, set = true) {
    emojiId = emojiId.toString();
    return this.context.session.getMsgService().setMsgEmojiLikes(peer, msgSeq, emojiId, emojiId.length > 3 ? "2" : "1", set);
  }
  async getMultiMsg(peer, rootMsgId, parentMsgId) {
    return this.context.session.getMsgService().getMultiMsg(peer, rootMsgId, parentMsgId);
  }
  async ForwardMsg(peer, msgIds) {
    return this.context.session.getMsgService().forwardMsg(msgIds, peer, [peer], /* @__PURE__ */ new Map());
  }
  async getMsgsByMsgId(peer, msgIds) {
    if (!peer) throw new Error("peer is not allowed");
    if (!msgIds) throw new Error("msgIds is not allowed");
    return await this.context.session.getMsgService().getMsgsByMsgId(peer, msgIds);
  }
  async getSingleMsg(peer, seq) {
    return await this.context.session.getMsgService().getSingleMsg(peer, seq);
  }
  async fetchFavEmojiList(num) {
    return this.context.session.getMsgService().fetchFavEmojiList("", num, true, true);
  }
  async queryMsgsWithFilterExWithSeq(peer, msgSeq) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime: "0",
      filterMsgFromTime: "0",
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  async queryMsgsWithFilterExWithSeqV2(peer, msgSeq, MsgTime, SendersUid) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: SendersUid,
      filterMsgToTime: MsgTime,
      filterMsgFromTime: MsgTime,
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  async queryFirstMsgBySeq(peer, msgSeq) {
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime: "0",
      filterMsgFromTime: "0",
      isReverseOrder: true,
      isIncludeCurrent: true,
      pageLimit: 1
    });
  }
  //@deprecated
  async getMsgsBySeqAndCount(peer, seq, count, desc, z) {
    return await this.context.session.getMsgService().getMsgsBySeqAndCount(peer, seq, count, desc, z);
  }
  async getMsgExBySeq(peer, msgSeq) {
    const DateNow = Math.floor(Date.now() / 1e3);
    const filterMsgFromTime = (DateNow - 300).toString();
    const filterMsgToTime = DateNow.toString();
    return await this.context.session.getMsgService().queryMsgsWithFilterEx("0", "0", msgSeq, {
      chatInfo: peer,
      //此处为Peer 为关键查询参数 没有啥也没有 by mlik iowa
      filterMsgType: [],
      filterSendersUid: [],
      filterMsgToTime,
      filterMsgFromTime,
      isReverseOrder: false,
      isIncludeCurrent: true,
      pageLimit: 100
    });
  }
  async setMsgRead(peer) {
    return this.context.session.getMsgService().setMsgRead(peer);
  }
  async getGroupFileList(GroupCode, params) {
    const [, groupFileListResult] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelRichMediaService/getGroupFileList",
      "NodeIKernelMsgListener/onGroupFileInfoUpdate",
      [
        GroupCode,
        params
      ],
      () => true,
      () => true,
      // Todo: 应当通过 groupFileListResult 判断
      1,
      5e3
    );
    return groupFileListResult.item;
  }
  async getMsgHistory(peer, msgId, count, isReverseOrder = false) {
    return this.context.session.getMsgService().getMsgsIncludeSelf(peer, msgId, count, isReverseOrder);
  }
  async recallMsg(peer, msgId) {
    await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/recallMsg",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [peer, [msgId]],
      () => true,
      (updatedList) => updatedList.find((m) => m.msgId === msgId && m.recallTime !== "0") !== void 0,
      1,
      1e3
    );
  }
  async PrepareTempChat(toUserUid, GroupCode, nickname) {
    return this.context.session.getMsgService().prepareTempChat({
      chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
      peerUid: toUserUid,
      peerNickname: nickname,
      fromGroupCode: GroupCode,
      sig: "",
      selfPhone: "",
      selfUid: this.core.selfInfo.uid,
      gameSession: {
        nickname: "",
        gameAppId: "",
        selfTinyId: "",
        peerRoleId: "",
        peerOpenId: ""
      }
    });
  }
  async getTempChatInfo(chatType, peerUid) {
    return this.context.session.getMsgService().getTempChatInfo(chatType, peerUid);
  }
  async sendMsg(peer, msgElements, waitComplete = true, timeout = 1e4) {
    if (peer.chatType === ChatType.KCHATTYPETEMPC2CFROMGROUP && peer.guildId && peer.guildId !== "") {
      const member = await this.core.apis.GroupApi.getGroupMember(peer.guildId, peer.peerUid);
      if (member) {
        await this.PrepareTempChat(peer.peerUid, peer.guildId, member.nick);
      }
    }
    const msgId = await this.generateMsgUniqueId(peer.chatType);
    peer.guildId = msgId;
    const [, msgList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/sendMsg",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [
        "0",
        peer,
        msgElements,
        /* @__PURE__ */ new Map()
      ],
      (ret) => ret.result === 0,
      (msgRecords) => {
        for (const msgRecord of msgRecords) {
          if (msgRecord.guildId === msgId && msgRecord.sendStatus === SendStatusType.KSEND_STATUS_SUCCESS) {
            return true;
          }
        }
        return false;
      },
      1,
      timeout
    );
    return msgList.find((msgRecord) => msgRecord.guildId === msgId);
  }
  async generateMsgUniqueId(chatType) {
    return this.context.session.getMsgService().generateMsgUniqueId(chatType, this.context.session.getMSFService().getServerTime());
  }
  async forwardMsg(srcPeer, destPeer, msgIds) {
    return this.context.session.getMsgService().forwardMsg(msgIds, srcPeer, [destPeer], /* @__PURE__ */ new Map());
  }
  async multiForwardMsg(srcPeer, destPeer, msgIds) {
    const msgInfos = msgIds.map((id) => {
      return { msgId: id, senderShowName: this.core.selfInfo.nick };
    });
    const [, msgList] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelMsgService/multiForwardMsgWithComment",
      "NodeIKernelMsgListener/onMsgInfoListUpdate",
      [
        msgInfos,
        srcPeer,
        destPeer,
        [],
        /* @__PURE__ */ new Map()
      ],
      () => true,
      (msgRecords) => msgRecords.some(
        (msgRecord) => msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === this.core.selfInfo.uid
      )
    );
    for (const msg of msgList) {
      const arkElement = msg.elements.find((ele) => ele.arkElement);
      if (!arkElement) {
        continue;
      }
      const forwardData = JSON.parse(arkElement.arkElement?.bytesData ?? "");
      if (forwardData.app != "com.tencent.multimsg") {
        continue;
      }
      if (msg.peerUid == destPeer.peerUid && msg.senderUid == this.core.selfInfo.uid) {
        return msg;
      }
    }
    throw new Error("转发消息超时");
  }
  async markAllMsgAsRead() {
    return this.context.session.getMsgService().setAllC2CAndGroupMsgRead();
  }
}

class NTQQUserApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  //self_tind格式
  async createUidFromTinyId(tinyId) {
    return this.context.session.getMsgService().createUidFromTinyId(this.core.selfInfo.uin, tinyId);
  }
  async getStatusByUid(uid) {
    return this.context.session.getProfileService().getStatus(uid);
  }
  async getProfileLike(uid) {
    return this.context.session.getProfileLikeService().getBuddyProfileLike({
      friendUids: [uid],
      basic: 1,
      vote: 1,
      favorite: 0,
      userProfile: 1,
      type: 2,
      start: 0,
      limit: 20
    });
  }
  async fetchOtherProfileLike(uid) {
    return this.context.session.getProfileLikeService().getBuddyProfileLike({
      friendUids: [uid],
      basic: 1,
      vote: 1,
      favorite: 0,
      userProfile: 0,
      type: 1,
      start: 0,
      limit: 20
    });
  }
  async setLongNick(longNick) {
    return this.context.session.getProfileService().setLongNick(longNick);
  }
  async setSelfOnlineStatus(status, extStatus, batteryStatus) {
    return this.context.session.getMsgService().setStatus({
      status,
      extStatus,
      batteryStatus
    });
  }
  async getBuddyRecommendContactArkJson(uin, sencenID = "") {
    return this.context.session.getBuddyService().getBuddyRecommendContactArkJson(uin, sencenID);
  }
  async like(uid, count = 1) {
    return this.context.session.getProfileLikeService().setBuddyProfileLike({
      friendUid: uid,
      sourceId: 71,
      doLikeCount: count,
      doLikeTollCount: 0
    });
  }
  async setQQAvatar(filePath) {
    const ret = await this.context.session.getProfileService().setHeader(filePath);
    return { result: ret?.result, errMsg: ret?.errMsg };
  }
  async setGroupAvatar(gc, filePath) {
    return this.context.session.getGroupService().setHeader(gc, filePath);
  }
  async fetchUserDetailInfo(uid, mode = UserDetailSource.KDB) {
    const [_retData, profile] = await this.core.eventWrapper.callNormalEventV2(
      "NodeIKernelProfileService/fetchUserDetailInfo",
      "NodeIKernelProfileListener/onUserDetailInfoChanged",
      [
        "BuddyProfileStore",
        [uid],
        mode,
        [ProfileBizType.KALL]
      ],
      () => true,
      (profile2) => profile2.uid === uid
    );
    const RetUser = {
      ...profile.simpleInfo.status,
      ...profile.simpleInfo.vasInfo,
      ...profile.commonExt,
      ...profile.simpleInfo.baseInfo,
      qqLevel: profile.commonExt?.qqLevel,
      age: profile.simpleInfo.baseInfo.age,
      pendantId: "",
      ...profile.simpleInfo.coreInfo
    };
    return RetUser;
  }
  async getUserDetailInfo(uid) {
    let retUser = await solveAsyncProblem(async (uid2) => this.fetchUserDetailInfo(uid2, UserDetailSource.KDB), uid);
    if (retUser && retUser.uin !== "0") {
      return retUser;
    }
    this.context.logger.logDebug("[NapCat] [Mark] getUserDetailInfo Mode1 Failed.");
    retUser = await this.fetchUserDetailInfo(uid, UserDetailSource.KSERVER);
    if (retUser && retUser.uin === "0") {
      retUser.uin = await this.core.apis.UserApi.getUidByUinV2(uid) ?? "0";
    }
    return retUser;
  }
  async modifySelfProfile(param) {
    return this.context.session.getProfileService().modifyDesktopMiniProfile(param);
  }
  async getCookies(domain) {
    const ClientKeyData = await this.forceFetchClientKey();
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + ClientKeyData.clientKey + "&u1=https%3A%2F%2F" + domain + "%2F" + this.core.selfInfo.uin + "%2Finfocenter&keyindex=19%27";
    const data = await RequestUtil.HttpsGetCookies(requestUrl);
    if (!data.p_skey || data.p_skey.length == 0) {
      try {
        const pskey = (await this.getPSkey([domain])).domainPskeyMap.get(domain);
        if (pskey) data.p_skey = pskey;
      } catch {
        return data;
      }
    }
    return data;
  }
  async getPSkey(domainList) {
    return await this.context.session.getTipOffService().getPskey(domainList, true);
  }
  async getRobotUinRange() {
    const robotUinRanges = await this.context.session.getRobotService().getRobotUinRange({
      justFetchMsgConfig: "1",
      type: 1,
      version: 0,
      aioKeywordVersion: 0
    });
    return robotUinRanges?.response?.robotUinRanges;
  }
  //需要异常处理
  async getQzoneCookies() {
    const ClientKeyData = await this.forceFetchClientKey();
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + ClientKeyData.clientKey + "&u1=https%3A%2F%2Fuser.qzone.qq.com%2F" + this.core.selfInfo.uin + "%2Finfocenter&keyindex=19%27";
    return await RequestUtil.HttpsGetCookies(requestUrl);
  }
  //需要异常处理
  async getSKey() {
    const ClientKeyData = await this.forceFetchClientKey();
    if (ClientKeyData.result !== 0) {
      throw new Error("getClientKey Error");
    }
    const clientKey = ClientKeyData.clientKey;
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + this.core.selfInfo.uin + "&clientkey=" + clientKey + "&u1=https%3A%2F%2Fh5.qzone.qq.com%2Fqqnt%2Fqzoneinpcqq%2Ffriend%3Frefresh%3D0%26clientuin%3D0%26darkMode%3D0&keyindex=19%27";
    const cookies = await RequestUtil.HttpsGetCookies(requestUrl);
    const skey = cookies["skey"];
    if (!skey) {
      throw new Error("SKey is Empty");
    }
    return skey;
  }
  //后期改成流水线处理
  async getUidByUinV2(Uin) {
    let uid = (await this.context.session.getGroupService().getUidByUins([Uin])).uids.get(Uin);
    if (uid) return uid;
    uid = (await this.context.session.getProfileService().getUidByUin("FriendsServiceImpl", [Uin])).get(Uin);
    if (uid) return uid;
    uid = (await this.context.session.getUixConvertService().getUid([Uin])).uidInfo.get(Uin);
    if (uid) return uid;
    const unverifiedUid = (await this.getUserDetailInfoByUin(Uin)).detail.uid;
    if (unverifiedUid.indexOf("*") == -1) uid = unverifiedUid;
    return uid;
  }
  //后期改成流水线处理
  async getUinByUidV2(Uid) {
    let uin = (await this.context.session.getGroupService().getUinByUids([Uid])).uins.get(Uid);
    if (uin) return uin;
    uin = (await this.context.session.getProfileService().getUinByUid("FriendsServiceImpl", [Uid])).get(Uid);
    if (uin) return uin;
    uin = (await this.context.session.getUixConvertService().getUin([Uid])).uinInfo.get(Uid);
    if (uin) return uin;
    uin = (await this.core.apis.FriendApi.getBuddyIdMap(true)).getKey(Uid);
    if (uin) return uin;
    uin = (await this.getUserDetailInfo(Uid)).uin;
    return uin;
  }
  async getRecentContactListSnapShot(count) {
    return await this.context.session.getRecentContactService().getRecentContactListSnapShot(count);
  }
  async getRecentContactListSyncLimit(count) {
    return await this.context.session.getRecentContactService().getRecentContactListSyncLimit(count);
  }
  async getRecentContactListSync() {
    return await this.context.session.getRecentContactService().getRecentContactListSync();
  }
  async getRecentContactList() {
    return await this.context.session.getRecentContactService().getRecentContactList();
  }
  async getUserDetailInfoByUin(Uin) {
    return await this.core.eventWrapper.callNoListenerEvent(
      "NodeIKernelProfileService/getUserDetailInfoByUin",
      Uin
    );
  }
  async forceFetchClientKey() {
    return await this.context.session.getTicketService().forceFetchClientKey("");
  }
}

class NTQQWebApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async shareDigest(groupCode, msgSeq, msgRandom, targetGroupCode) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const url = `https://qun.qq.com/cgi-bin/group_digest/share_digest?${new URLSearchParams({
      bkn: this.getBknFromCookie(cookieObject),
      group_code: groupCode,
      msg_seq: msgSeq,
      msg_random: msgRandom,
      target_group_code: targetGroupCode
    }).toString()}`;
    try {
      return RequestUtil.HttpGetText(url, "GET", "", { "Cookie": this.cookieToString(cookieObject) });
    } catch (e) {
      return void 0;
    }
  }
  async getGroupEssenceMsgAll(GroupCode) {
    const ret = [];
    for (let i = 0; i < 20; i++) {
      const data = await this.getGroupEssenceMsg(GroupCode, i, 50);
      if (!data) break;
      ret.push(data);
      if (data.data.is_end) break;
    }
    return ret;
  }
  async getGroupEssenceMsg(GroupCode, page_start = 0, page_limit = 50) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const url = `https://qun.qq.com/cgi-bin/group_digest/digest_list?${new URLSearchParams({
      bkn: this.getBknFromCookie(cookieObject),
      page_start: page_start.toString(),
      page_limit: page_limit.toString(),
      group_code: GroupCode
    }).toString()}`;
    try {
      const ret = await RequestUtil.HttpGetJson(
        url,
        "GET",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret.retcode === 0 ? ret : void 0;
    } catch {
      return void 0;
    }
  }
  async getGroupMembers(GroupCode, cached = true) {
    const memberData = new Array();
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const retList = [];
    const fastRet = await RequestUtil.HttpGetJson(
      `https://qun.qq.com/cgi-bin/qun_mgr/search_group_members?${new URLSearchParams({
        st: "0",
        end: "40",
        sort: "1",
        gc: GroupCode,
        bkn: this.getBknFromCookie(cookieObject)
      }).toString()}`,
      "POST",
      "",
      { "Cookie": this.cookieToString(cookieObject) }
    );
    if (!fastRet?.count || fastRet?.errcode !== 0 || !fastRet?.mems) {
      return [];
    } else {
      for (const key in fastRet.mems) {
        memberData.push(fastRet.mems[key]);
      }
    }
    const PageNum = Math.ceil(fastRet.count / 40);
    for (let i = 2; i <= PageNum; i++) {
      const ret = RequestUtil.HttpGetJson(
        `https://qun.qq.com/cgi-bin/qun_mgr/search_group_members?${new URLSearchParams({
          st: ((i - 1) * 40).toString(),
          end: (i * 40).toString(),
          sort: "1",
          gc: GroupCode,
          bkn: this.getBknFromCookie(cookieObject)
        }).toString()}`,
        "POST",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      retList.push(ret);
    }
    for (let i = 1; i <= PageNum; i++) {
      const ret = await retList[i];
      if (!ret?.count || ret?.errcode !== 0 || !ret?.mems) {
        continue;
      }
      for (const key in ret.mems) {
        memberData.push(ret.mems[key]);
      }
    }
    return memberData;
  }
  // public  async addGroupDigest(groupCode: string, msgSeq: string) {
  //   const url = `https://qun.qq.com/cgi-bin/group_digest/cancel_digest?random=665&X-CROSS-ORIGIN=fetch&group_code=${groupCode}&msg_seq=${msgSeq}&msg_random=444021292`;
  //   const res = await this.request(url);
  //   return await res.json();
  // }
  // public async getGroupDigest(groupCode: string) {
  //   const url = `https://qun.qq.com/cgi-bin/group_digest/digest_list?random=665&X-CROSS-ORIGIN=fetch&group_code=${groupCode}&page_start=0&page_limit=20`;
  //   const res = await this.request(url);
  //   return await res.json();
  // }
  async setGroupNotice(GroupCode, Content, pinned = 0, type = 1, is_show_edit_card = 1, tip_window_type = 1, confirm_required = 1, picId = "", imgWidth = 540, imgHeight = 300) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    try {
      const settings = JSON.stringify({
        is_show_edit_card,
        tip_window_type,
        confirm_required
      });
      const externalParam = {
        pic: picId,
        imgWidth: imgWidth.toString(),
        imgHeight: imgHeight.toString()
      };
      const ret = await RequestUtil.HttpGetJson(
        `https://web.qun.qq.com/cgi-bin/announce/add_qun_notice?${new URLSearchParams({
          bkn: this.getBknFromCookie(cookieObject),
          qid: GroupCode,
          text: Content,
          pinned: pinned.toString(),
          type: type.toString(),
          settings,
          ...picId === "" ? {} : externalParam
        }).toString()}`,
        "POST",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret;
    } catch (e) {
      return void 0;
    }
  }
  async getGroupNotice(GroupCode) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    try {
      const ret = await RequestUtil.HttpGetJson(
        `https://web.qun.qq.com/cgi-bin/announce/get_t_list?${new URLSearchParams({
          bkn: this.getBknFromCookie(cookieObject),
          qid: GroupCode,
          ft: "23",
          ni: "1",
          n: "1",
          i: "1",
          log_read: "1",
          platform: "1",
          s: "-1"
        }).toString()}&n=20`,
        "GET",
        "",
        { "Cookie": this.cookieToString(cookieObject) }
      );
      return ret?.ec === 0 ? ret : void 0;
    } catch (e) {
      return void 0;
    }
  }
  async getGroupHonorInfo(groupCode, getType) {
    const cookieObject = await this.core.apis.UserApi.getCookies("qun.qq.com");
    const getDataInternal = async (Internal_groupCode, Internal_type) => {
      let resJson;
      try {
        const res = await RequestUtil.HttpGetText(
          `https://qun.qq.com/interactive/honorlist?${new URLSearchParams({
            gc: Internal_groupCode,
            type: Internal_type.toString()
          }).toString()}`,
          "GET",
          "",
          { "Cookie": this.cookieToString(cookieObject) }
        );
        const match = /window\.__INITIAL_STATE__=(.*?);/.exec(res);
        if (match) {
          resJson = JSON.parse(match[1].trim());
        }
        if (Internal_type === 1) {
          return resJson?.talkativeList;
        } else {
          return resJson?.actorList;
        }
      } catch (e) {
        this.context.logger.logDebug("获取当前群荣耀失败", e);
      }
      return void 0;
    };
    const HonorInfo = { group_id: groupCode };
    if (getType === WebHonorType.TALKATIVE || getType === WebHonorType.ALL) {
      const RetInternal = await getDataInternal(groupCode, 1);
      if (RetInternal) {
        HonorInfo.current_talkative = {
          user_id: RetInternal[0]?.uin,
          avatar: RetInternal[0]?.avatar,
          nickname: RetInternal[0]?.name,
          day_count: 0,
          description: RetInternal[0]?.desc
        };
        HonorInfo.talkative_list = [];
        for (const talkative_ele of RetInternal) {
          HonorInfo.talkative_list.push({
            user_id: talkative_ele?.uin,
            avatar: talkative_ele?.avatar,
            description: talkative_ele?.desc,
            day_count: 0,
            nickname: talkative_ele?.name
          });
        }
      } else {
        this.context.logger.logError.bind(this.context.logger)("获取龙王信息失败");
      }
    }
    if (getType === WebHonorType.PERFORMER || getType === WebHonorType.ALL) {
      const RetInternal = await getDataInternal(groupCode, 2);
      if (RetInternal) {
        HonorInfo.performer_list = [];
        for (const performer_ele of RetInternal) {
          HonorInfo.performer_list.push({
            user_id: performer_ele?.uin,
            nickname: performer_ele?.name,
            avatar: performer_ele?.avatar,
            description: performer_ele?.desc
          });
        }
      } else {
        this.context.logger.logError.bind(this.context.logger)("获取群聊之火失败");
      }
    }
    if (getType === WebHonorType.PERFORMER || getType === WebHonorType.ALL) {
      const RetInternal = await getDataInternal(groupCode, 3);
      if (RetInternal) {
        HonorInfo.legend_list = [];
        for (const legend_ele of RetInternal) {
          HonorInfo.legend_list.push({
            user_id: legend_ele?.uin,
            nickname: legend_ele?.name,
            avatar: legend_ele?.avatar,
            desc: legend_ele?.description
          });
        }
      } else {
        this.context.logger.logError.bind(this.context.logger)("获取群聊炽焰失败");
      }
    }
    if (getType === WebHonorType.EMOTION || getType === WebHonorType.ALL) {
      const RetInternal = await getDataInternal(groupCode, 6);
      if (RetInternal) {
        HonorInfo.emotion_list = [];
        for (const emotion_ele of RetInternal) {
          HonorInfo.emotion_list.push({
            user_id: emotion_ele.uin,
            nickname: emotion_ele.name,
            avatar: emotion_ele.avatar,
            desc: emotion_ele.description
          });
        }
      } else {
        this.context.logger.logError.bind(this.context.logger)("获取快乐源泉失败");
      }
    }
    if (getType === WebHonorType.EMOTION || getType === WebHonorType.ALL) {
      HonorInfo.strong_newbie_list = [];
    }
    return HonorInfo;
  }
  cookieToString(cookieObject) {
    return Object.entries(cookieObject).map(([key, value]) => `${key}=${value}`).join("; ");
  }
  getBknFromCookie(cookieObject) {
    const sKey = cookieObject.skey;
    let hash = 5381;
    for (let i = 0; i < sKey.length; i++) {
      const code = sKey.charCodeAt(i);
      hash = hash + (hash << 5) + code;
    }
    return (hash & 2147483647).toString();
  }
  getBknFromSKey(sKey) {
    let hash = 5381;
    for (let i = 0; i < sKey.length; i++) {
      const code = sKey.charCodeAt(i);
      hash = hash + (hash << 5) + code;
    }
    return (hash & 2147483647).toString();
  }
}

class NTQQSystemApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async hasOtherRunningQQProcess() {
    return this.core.util.hasOtherRunningQQProcess();
  }
  async ocrImage(filePath) {
    return this.context.session.getNodeMiscService().wantWinScreenOCR(filePath);
  }
  async translateEnWordToZn(words) {
    return this.context.session.getRichMediaService().translateEnWordToZn(words);
  }
  async getOnlineDev() {
    this.context.session.getMsgService().getOnLineDev();
  }
  async getArkJsonCollection(cid) {
    return await this.core.eventWrapper.callNoListenerEvent("NodeIKernelCollectionService/collectionArkShare", "1717662698058");
  }
  async bootMiniApp(appFile, params) {
    await this.context.session.getNodeMiscService().setMiniAppVersion("2.16.4");
    return this.context.session.getNodeMiscService().startNewMiniApp(appFile, params);
  }
}

class NTQQCollectionApi {
  context;
  core;
  constructor(context, core) {
    this.context = context;
    this.core = core;
  }
  async createCollection(authorUin, authorUid, authorName, brief, rawData) {
    return this.context.session.getCollectionService().createNewCollectionItem({
      commInfo: {
        bid: 1,
        category: 2,
        author: {
          type: 1,
          numId: authorUin,
          strId: authorName,
          groupId: "0",
          groupName: "",
          uid: authorUid
        },
        customGroupId: "0",
        createTime: Date.now().toString(),
        sequence: Date.now().toString()
      },
      richMediaSummary: {
        originalUri: "",
        publisher: "",
        richMediaVersion: 0,
        subTitle: "",
        title: "",
        brief,
        picList: [],
        contentType: 1
      },
      richMediaContent: {
        rawData,
        bizDataList: [],
        picList: [],
        fileList: []
      },
      need_share_url: false
    });
  }
  async getAllCollection(category = 0, count = 50) {
    return this.context.session.getCollectionService().getCollectionItemList({
      category,
      groupId: -1,
      forceSync: true,
      forceFromDb: false,
      timeStamp: "0",
      count,
      searchDown: true
    });
  }
}

var PlatformType = /* @__PURE__ */ ((PlatformType2) => {
  PlatformType2[PlatformType2["KUNKNOWN"] = 0] = "KUNKNOWN";
  PlatformType2[PlatformType2["KANDROID"] = 1] = "KANDROID";
  PlatformType2[PlatformType2["KIOS"] = 2] = "KIOS";
  PlatformType2[PlatformType2["KWINDOWS"] = 3] = "KWINDOWS";
  PlatformType2[PlatformType2["KMAC"] = 4] = "KMAC";
  PlatformType2[PlatformType2["KLINUX"] = 5] = "KLINUX";
  return PlatformType2;
})(PlatformType || {});
var VendorType = /* @__PURE__ */ ((VendorType2) => {
  VendorType2[VendorType2["KNOSETONIOS"] = 0] = "KNOSETONIOS";
  VendorType2[VendorType2["KSUPPORTGOOGLEPUSH"] = 99] = "KSUPPORTGOOGLEPUSH";
  VendorType2[VendorType2["KSUPPORTHMS"] = 3] = "KSUPPORTHMS";
  VendorType2[VendorType2["KSUPPORTOPPOPUSH"] = 4] = "KSUPPORTOPPOPUSH";
  VendorType2[VendorType2["KSUPPORTTPNS"] = 2] = "KSUPPORTTPNS";
  VendorType2[VendorType2["KSUPPORTVIVOPUSH"] = 5] = "KSUPPORTVIVOPUSH";
  VendorType2[VendorType2["KUNSUPPORTANDROIDPUSH"] = 1] = "KUNSUPPORTANDROIDPUSH";
  return VendorType2;
})(VendorType || {});

let osName;
try {
  osName = os$1.hostname();
} catch (e) {
  osName = "NapCat";
}
const homeDir = os$1.homedir();
const systemPlatform = os$1.platform();
os$1.arch();
const systemVersion = os$1.release();
const hostname = osName;
path$1.join(homeDir, "Downloads");
const systemName = os$1.type();

class NTEventWrapper {
  WrapperSession;
  //WrapperSession
  listenerManager = /* @__PURE__ */ new Map();
  //ListenerName-Unique -> Listener实例
  EventTask = /* @__PURE__ */ new Map();
  //tasks ListenerMainName -> ListenerSubName-> uuid -> {timeout,createtime,func}
  constructor(wrapperSession) {
    this.WrapperSession = wrapperSession;
  }
  createProxyDispatch(ListenerMainName) {
    const dispatcherListenerFunc = this.dispatcherListener.bind(this);
    return new Proxy(
      {},
      {
        get(target, prop, receiver) {
          if (typeof target[prop] === "undefined") {
            return (...args) => {
              dispatcherListenerFunc(ListenerMainName, prop, ...args).then();
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      }
    );
  }
  createEventFunction(eventName) {
    const eventNameArr = eventName.split("/");
    if (eventNameArr.length > 1) {
      const serviceName = "get" + eventNameArr[0].replace("NodeIKernel", "");
      const eventName2 = eventNameArr[1];
      const services = this.WrapperSession[serviceName]();
      let event = services[eventName2];
      event = event.bind(services);
      if (event) {
        return event;
      }
      return void 0;
    }
  }
  createListenerFunction(listenerMainName, uniqueCode = "") {
    const existListener = this.listenerManager.get(listenerMainName + uniqueCode);
    if (!existListener) {
      const Listener = this.createProxyDispatch(listenerMainName);
      const ServiceSubName = /^NodeIKernel(.*?)Listener$/.exec(listenerMainName)[1];
      const Service = `NodeIKernel${ServiceSubName}Service/addKernel${ServiceSubName}Listener`;
      this.createEventFunction(Service)(Listener);
      this.listenerManager.set(listenerMainName + uniqueCode, Listener);
      return Listener;
    }
    return existListener;
  }
  //统一回调清理事件
  async dispatcherListener(ListenerMainName, ListenerSubName, ...args) {
    this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.forEach((task, uuid) => {
      if (task.createtime + task.timeout < Date.now()) {
        this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.delete(uuid);
        return;
      }
      if (task?.checker?.(...args)) {
        task.func(...args);
      }
    });
  }
  async callNoListenerEvent(serviceAndMethod, ...args) {
    return this.createEventFunction(serviceAndMethod)(...args);
  }
  async registerListen(listenerAndMethod, waitTimes = 1, timeout = 5e3, checker) {
    return new Promise((resolve, reject) => {
      const ListenerNameList = listenerAndMethod.split("/");
      const ListenerMainName = ListenerNameList[0];
      const ListenerSubName = ListenerNameList[1];
      const id = randomUUID();
      let complete = 0;
      let retData = void 0;
      function sendDataCallback() {
        if (complete == 0) {
          reject(new Error(" ListenerName:" + listenerAndMethod + " timeout"));
        } else {
          resolve(retData);
        }
      }
      const timeoutRef = setTimeout(sendDataCallback, timeout);
      const eventCallback = {
        timeout,
        createtime: Date.now(),
        checker,
        func: (...args) => {
          complete++;
          retData = args;
          if (complete >= waitTimes) {
            clearTimeout(timeoutRef);
            sendDataCallback();
          }
        }
      };
      if (!this.EventTask.get(ListenerMainName)) {
        this.EventTask.set(ListenerMainName, /* @__PURE__ */ new Map());
      }
      if (!this.EventTask.get(ListenerMainName)?.get(ListenerSubName)) {
        this.EventTask.get(ListenerMainName)?.set(ListenerSubName, /* @__PURE__ */ new Map());
      }
      this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.set(id, eventCallback);
      this.createListenerFunction(ListenerMainName);
    });
  }
  async callNormalEventV2(serviceAndMethod, listenerAndMethod, args, checkerEvent = () => true, checkerListener = () => true, callbackTimesToWait = 1, timeout = 5e3) {
    return new Promise(
      async (resolve, reject) => {
        const id = randomUUID();
        let complete = 0;
        let retData = void 0;
        let retEvent = {};
        function sendDataCallback() {
          if (complete == 0) {
            reject(
              new Error(
                "Timeout: NTEvent serviceAndMethod:" + serviceAndMethod + " ListenerName:" + listenerAndMethod + " EventRet:\n" + JSON.stringify(retEvent, null, 4) + "\n"
              )
            );
          } else {
            resolve([retEvent, ...retData]);
          }
        }
        const ListenerNameList = listenerAndMethod.split("/");
        const ListenerMainName = ListenerNameList[0];
        const ListenerSubName = ListenerNameList[1];
        const timeoutRef = setTimeout(sendDataCallback, timeout);
        const eventCallback = {
          timeout,
          createtime: Date.now(),
          checker: checkerListener,
          func: (...args2) => {
            complete++;
            retData = args2;
            if (complete >= callbackTimesToWait) {
              clearTimeout(timeoutRef);
              sendDataCallback();
            }
          }
        };
        if (!this.EventTask.get(ListenerMainName)) {
          this.EventTask.set(ListenerMainName, /* @__PURE__ */ new Map());
        }
        if (!this.EventTask.get(ListenerMainName)?.get(ListenerSubName)) {
          this.EventTask.get(ListenerMainName)?.set(ListenerSubName, /* @__PURE__ */ new Map());
        }
        this.EventTask.get(ListenerMainName)?.get(ListenerSubName)?.set(id, eventCallback);
        this.createListenerFunction(ListenerMainName);
        const eventFunction = this.createEventFunction(serviceAndMethod);
        retEvent = await eventFunction(...args);
        if (!checkerEvent(retEvent) && timeoutRef.hasRef()) {
          clearTimeout(timeoutRef);
          reject(
            new Error(
              "EventChecker Failed: NTEvent serviceAndMethod:" + serviceAndMethod + " ListenerName:" + listenerAndMethod + " EventRet:\n" + JSON.stringify(retEvent, null, 4) + "\n"
            )
          );
        }
      }
    );
  }
}

class ConfigBase {
  name;
  core;
  configPath;
  configData = {};
  constructor(name, core, configPath) {
    this.name = name;
    this.core = core;
    this.configPath = configPath;
    fs__default$1.mkdirSync(this.configPath, { recursive: true });
    this.read();
  }
  getKeys() {
    return null;
  }
  getConfigPath(pathName) {
    if (!pathName) {
      const filename = `${this.name}.json`;
      const mainPath = this.core.context.pathWrapper.binaryPath;
      return path$1.join(mainPath, "config", filename);
    } else {
      const filename = `${this.name}_${pathName}.json`;
      return path$1.join(this.configPath, filename);
    }
  }
  read() {
    const logger = this.core.context.logger;
    const configPath = this.getConfigPath(this.core.selfInfo.uin);
    if (!fs__default$1.existsSync(configPath)) {
      try {
        fs__default$1.writeFileSync(configPath, fs__default$1.readFileSync(this.getConfigPath(void 0), "utf-8"));
        logger.log(`[Core] [Config] 配置文件创建成功!
`);
      } catch (e) {
        logger.logError.bind(logger)(`[Core] [Config] 创建配置文件时发生错误:`, e.message);
      }
    }
    try {
      this.configData = JSON.parse(fs__default$1.readFileSync(configPath, "utf-8"));
      logger.logDebug(`[Core] [Config] 配置文件${configPath}加载`, this.configData);
      return this.configData;
    } catch (e) {
      if (e instanceof SyntaxError) {
        logger.logError.bind(logger)(`[Core] [Config] 配置文件格式错误，请检查配置文件:`, e.message);
      } else {
        logger.logError.bind(logger)(`[Core] [Config] 读取配置文件时发生错误:`, e.message);
      }
      return {};
    }
  }
  save(newConfigData = this.configData) {
    const logger = this.core.context.logger;
    const selfInfo = this.core.selfInfo;
    this.configData = newConfigData;
    const configPath = this.getConfigPath(selfInfo.uin);
    try {
      fs__default$1.writeFileSync(configPath, JSON.stringify(newConfigData, this.getKeys(), 2));
    } catch (e) {
      logger.logError.bind(logger)(`保存配置文件 ${configPath} 时发生错误:`, e.message);
    }
  }
}

class NapCatConfigLoader extends ConfigBase {
  constructor(core, configPath) {
    super("napcat", core, configPath);
  }
}

class NodeIKernelSessionListener {
  onNTSessionCreate(args) {
  }
  onGProSessionCreate(args) {
  }
  onSessionInitComplete(args) {
  }
  onOpentelemetryInit(args) {
  }
  onUserOnlineResult(args) {
  }
  onGetSelfTinyId(args) {
  }
}

class NodeIKernelLoginListener {
  onLoginConnected(...args) {
  }
  onLoginDisConnected(...args) {
  }
  onLoginConnecting(...args) {
  }
  onQRCodeGetPicture(arg) {
  }
  onQRCodeLoginPollingStarted(...args) {
  }
  onQRCodeSessionUserScaned(...args) {
  }
  onQRCodeLoginSucceed(arg) {
  }
  onQRCodeSessionFailed(...args) {
  }
  onLoginFailed(...args) {
  }
  onLogoutSucceed(...args) {
  }
  onLogoutFailed(...args) {
  }
  onUserLoggedIn(...args) {
  }
  onQRCodeSessionQuickLoginFailed(...args) {
  }
  onPasswordLoginFailed(...args) {
  }
  OnConfirmUnusualDeviceFailed(...args) {
  }
  onQQLoginNumLimited(...args) {
  }
  onLoginState(...args) {
  }
}

class NodeIKernelMsgListener {
  onAddSendMsg(msgRecord) {
  }
  onBroadcastHelperDownloadComplete(broadcastHelperTransNotifyInfo) {
  }
  onBroadcastHelperProgressUpdate(broadcastHelperTransNotifyInfo) {
  }
  onChannelFreqLimitInfoUpdate(contact, z, freqLimitInfo) {
  }
  onContactUnreadCntUpdate(hashMap) {
  }
  onCustomWithdrawConfigUpdate(customWithdrawConfig) {
  }
  onDraftUpdate(contact, arrayList, j2) {
  }
  onEmojiDownloadComplete(emojiNotifyInfo) {
  }
  onEmojiResourceUpdate(emojiResourceInfo) {
  }
  onFeedEventUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onFileMsgCome(arrayList) {
  }
  onFirstViewDirectMsgUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onFirstViewGroupGuildMapping(arrayList) {
  }
  onGrabPasswordRedBag(i2, str, i3, recvdOrder, msgRecord) {
  }
  onGroupFileInfoAdd(groupItem) {
  }
  onGroupFileInfoUpdate(groupFileListResult) {
  }
  onGroupGuildUpdate(groupGuildNotifyInfo) {
  }
  onGroupTransferInfoAdd(groupItem) {
  }
  onGroupTransferInfoUpdate(groupFileListResult) {
  }
  onGuildInteractiveUpdate(guildInteractiveNotificationItem) {
  }
  onGuildMsgAbFlagChanged(guildMsgAbFlag) {
  }
  onGuildNotificationAbstractUpdate(guildNotificationAbstractInfo) {
  }
  onHitCsRelatedEmojiResult(downloadRelateEmojiResultInfo) {
  }
  onHitEmojiKeywordResult(hitRelatedEmojiWordsResult) {
  }
  onHitRelatedEmojiResult(relatedWordEmojiInfo) {
  }
  onImportOldDbProgressUpdate(importOldDbMsgNotifyInfo) {
  }
  onInputStatusPush(inputStatusInfo) {
  }
  onKickedOffLine(kickedInfo) {
  }
  onLineDev(arrayList) {
  }
  onLogLevelChanged(j2) {
  }
  onMsgAbstractUpdate(arrayList) {
  }
  onMsgBoxChanged(arrayList) {
  }
  onMsgDelete(contact, arrayList) {
  }
  onMsgEventListUpdate(hashMap) {
  }
  onMsgInfoListAdd(arrayList) {
  }
  onMsgInfoListUpdate(msgList) {
  }
  onMsgQRCodeStatusChanged(i2) {
  }
  onMsgRecall(i2, str, j2) {
  }
  onMsgSecurityNotify(msgRecord) {
  }
  onMsgSettingUpdate(msgSetting) {
  }
  onNtFirstViewMsgSyncEnd() {
  }
  onNtMsgSyncEnd() {
  }
  onNtMsgSyncStart() {
  }
  onReadFeedEventUpdate(firstViewDirectMsgNotifyInfo) {
  }
  onRecvGroupGuildFlag(i2) {
  }
  onRecvMsg(arrayList) {
  }
  onRecvMsgSvrRspTransInfo(j2, contact, i2, i3, str, bArr) {
  }
  onRecvOnlineFileMsg(arrayList) {
  }
  onRecvS2CMsg(arrayList) {
  }
  onRecvSysMsg(arrayList) {
  }
  onRecvUDCFlag(i2) {
  }
  onRichMediaDownloadComplete(fileTransNotifyInfo) {
  }
  onRichMediaProgerssUpdate(fileTransNotifyInfo) {
  }
  onRichMediaUploadComplete(fileTransNotifyInfo) {
  }
  onSearchGroupFileInfoUpdate(searchGroupFileResult) {
  }
  onSendMsgError(j2, contact, i2, str) {
  }
  onSysMsgNotification(i2, j2, j3, arrayList) {
  }
  onTempChatInfoUpdate(tempChatInfo) {
  }
  onUnreadCntAfterFirstView(hashMap) {
  }
  onUnreadCntUpdate(hashMap) {
  }
  onUserChannelTabStatusChanged(z) {
  }
  onUserOnlineStatusChanged(z) {
  }
  onUserTabStatusChanged(arrayList) {
  }
  onlineStatusBigIconDownloadPush(i2, j2, str) {
  }
  onlineStatusSmallIconDownloadPush(i2, j2, str) {
  }
  // 第一次发现于Linux
  onUserSecQualityChanged(...args) {
  }
  onMsgWithRichLinkInfoUpdate(...args) {
  }
  onRedTouchChanged(...args) {
  }
  // 第一次发现于Win 9.9.9-23159
  onBroadcastHelperProgerssUpdate(...args) {
  }
}

class NodeIKernelGroupListener {
  onGroupListInited(listEmpty) {
  }
  // 发现于Win 9.9.9 23159
  onGroupMemberLevelInfoChange(...args) {
  }
  onGetGroupBulletinListResult(...args) {
  }
  onGroupAllInfoChange(...args) {
  }
  onGroupBulletinChange(...args) {
  }
  onGroupBulletinRemindNotify(...args) {
  }
  onGroupArkInviteStateResult(...args) {
  }
  onGroupBulletinRichMediaDownloadComplete(...args) {
  }
  onGroupConfMemberChange(...args) {
  }
  onGroupDetailInfoChange(...args) {
  }
  onGroupExtListUpdate(...args) {
  }
  onGroupFirstBulletinNotify(...args) {
  }
  onGroupListUpdate(updateType, groupList) {
  }
  onGroupNotifiesUpdated(dboubt, notifies) {
  }
  onGroupBulletinRichMediaProgressUpdate(...args) {
  }
  onGroupNotifiesUnreadCountUpdated(...args) {
  }
  onGroupSingleScreenNotifies(doubt, seq, notifies) {
  }
  onGroupsMsgMaskResult(...args) {
  }
  onGroupStatisticInfoChange(...args) {
  }
  onJoinGroupNotify(...args) {
  }
  onJoinGroupNoVerifyFlag(...args) {
  }
  onMemberInfoChange(groupCode, dateSource, members) {
  }
  onMemberListChange(arg) {
  }
  onSearchMemberChange(...args) {
  }
  onShutUpMemberListChanged(...args) {
  }
}

class NodeIKernelBuddyListener {
  onBuddyListChangedV2(arg) {
  }
  onAddBuddyNeedVerify(arg) {
  }
  onAddMeSettingChanged(arg) {
  }
  onAvatarUrlUpdated(arg) {
  }
  onBlockChanged(arg) {
  }
  onBuddyDetailInfoChange(arg) {
  }
  onBuddyInfoChange(arg) {
  }
  onBuddyListChange(arg) {
  }
  onBuddyRemarkUpdated(arg) {
  }
  onBuddyReqChange(arg) {
  }
  onBuddyReqUnreadCntChange(arg) {
  }
  onCheckBuddySettingResult(arg) {
  }
  onDelBatchBuddyInfos(arg) {
  }
  onDoubtBuddyReqChange(arg) {
  }
  onDoubtBuddyReqUnreadNumChange(arg) {
  }
  onNickUpdated(arg) {
  }
  onSmartInfos(arg) {
  }
  onSpacePermissionInfos(arg) {
  }
}

class NodeIKernelProfileListener {
  onUserDetailInfoChanged(arg) {
  }
  onProfileSimpleChanged(...args) {
  }
  onProfileDetailInfoChanged(profile) {
  }
  onStatusUpdate(...args) {
  }
  onSelfStatusChanged(...args) {
  }
  onStrangerRemarkChanged(...args) {
  }
  onMemberListChange(...args) {
  }
  onMemberInfoChange(...args) {
  }
  onGroupListUpdate(...args) {
  }
  onGroupAllInfoChange(...args) {
  }
  onGroupDetailInfoChange(...args) {
  }
  onGroupConfMemberChange(...args) {
  }
  onGroupExtListUpdate(...args) {
  }
  onGroupNotifiesUpdated(...args) {
  }
  onGroupNotifiesUnreadCountUpdated(...args) {
  }
  onGroupMemberLevelInfoChange(...args) {
  }
  onGroupBulletinChange(...args) {
  }
}

function proxyHandlerOf(logger) {
  return {
    get(target, prop, receiver) {
      if (typeof target[prop] === "undefined") {
        return (..._args) => {
          logger.logDebug(`${target.constructor.name} has no method ${prop}`);
        };
      }
      return Reflect.get(target, prop, receiver);
    }
  };
}
function proxiedListenerOf(listener, logger) {
  return new Proxy(listener, proxyHandlerOf(logger));
}

const offset = {
	"3.2.12-28418-x64": {
	recv: "A0723E0",
	send: "A06EAE0"
},
	"9.9.15-28418-x64": {
	recv: "37A9004",
	send: "37A4BD0"
},
	"9.9.15-28498-x64": {
	recv: "37A9004",
	send: "37A4BD0"
},
	"9.9.16-28788-x64": {
	send: "38076D0",
	recv: "380BB04"
},
	"3.2.13-28788-x64": {
	send: "A0CEC20",
	recv: "A0D2520"
},
	"3.2.13-28788-arm64": {
	send: "6E91018",
	recv: "6E94850"
},
	"9.9.16-28971-x64": {
	send: "38079F0",
	recv: "380BE24"
},
	"3.2.13-28971-x64": {
	send: "A0CEF60",
	recv: "A0D2860"
},
	"3.2.12-28971-arm64": {
	send: "6E91318",
	recv: "6E94B50"
},
	"6.9.56-28418-arm64": {
	send: "4471360",
	recv: "4473BCC"
}
};

class LRUCache {
  capacity;
  cache;
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = /* @__PURE__ */ new Map();
  }
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== void 0) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
}

class PacketClient {
  websocket;
  isConnected = false;
  reconnectAttempts = 0;
  maxReconnectAttempts = 60;
  //现在暂时不可配置
  cb = new LRUCache(500);
  // trace_id-type callback
  clientUrl = "";
  napCatCore;
  logger;
  constructor(url, core) {
    this.clientUrl = url;
    this.napCatCore = core;
    this.logger = core.context.logger;
  }
  get available() {
    return this.isConnected && this.websocket !== void 0;
  }
  randText(len) {
    let text = "";
    const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < len; i++) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  }
  connect(cb) {
    return new Promise((resolve, reject) => {
      this.websocket = new WebSocket(this.clientUrl);
      this.websocket.on(
        "error",
        (err) => {
        }
        /*this.logger.logError.bind(this.logger)('[Core] [Packet Server] Error:', err.message)*/
      );
      this.websocket.onopen = () => {
        this.isConnected = true;
        this.reconnectAttempts = 0;
        this.logger.log.bind(this.logger)(`[Core] [Packet Server] 已连接到 ${this.clientUrl}`);
        cb();
        resolve();
      };
      this.websocket.onerror = (error) => {
        reject(new Error(`${error.message}`));
      };
      this.websocket.onmessage = (event) => {
        this.handleMessage(event.data).then().catch();
      };
      this.websocket.onclose = () => {
        this.isConnected = false;
        this.attemptReconnect(cb);
      };
    });
  }
  attemptReconnect(cb) {
    try {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        setTimeout(() => {
          this.connect(cb).catch((error) => {
            this.logger.logError.bind(this.logger)(`[Core] [Packet Server] 尝试重连失败：${error.message}`);
          });
        }, 5e3 * this.reconnectAttempts);
      } else {
        this.logger.logError.bind(this.logger)(`[Core] [Packet Server] ${this.clientUrl} 已达到最大重连次数！`);
      }
    } catch (error) {
      this.logger.logError.bind(this.logger)(`[Core] [Packet Server] 重连时出错: ${error.message}`);
    }
  }
  async registerCallback(trace_id, type, callback) {
    this.cb.put(createHash("md5").update(trace_id).digest("hex") + type, callback);
  }
  async init(pid, recv, send) {
    if (!this.isConnected || !this.websocket) {
      throw new Error("WebSocket is not connected");
    }
    const initMessage = {
      action: "init",
      pid,
      recv,
      send
    };
    this.websocket.send(JSON.stringify(initMessage));
  }
  async sendCommand(cmd, data, trace_id, rsp = false, timeout = 2e4, sendcb = () => {
  }) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.websocket) {
        throw new Error("WebSocket is not connected");
      }
      const commandMessage = {
        action: "send",
        cmd,
        data,
        trace_id
      };
      this.websocket.send(JSON.stringify(commandMessage));
      if (rsp) {
        this.registerCallback(trace_id, "recv", async (json) => {
          clearTimeout(timeoutHandle);
          resolve(json);
        });
      }
      this.registerCallback(trace_id, "send", async (json) => {
        sendcb(json);
        if (!rsp) {
          clearTimeout(timeoutHandle);
          resolve(json);
        }
      });
      const timeoutHandle = setTimeout(() => {
        reject(new Error(`sendCommand timed out after ${timeout} ms for ${cmd} with trace_id ${trace_id}`));
      }, timeout);
    });
  }
  async handleMessage(message) {
    try {
      const json = JSON.parse(message.toString());
      const trace_id_md5 = json.trace_id_md5;
      const action = json?.type ?? "init";
      const event = this.cb.get(trace_id_md5 + action);
      if (event) {
        await event(json.data);
      }
    } catch (error) {
      this.logger.logError.bind(this.logger)(`Error parsing message: ${error}`);
    }
  }
  async sendPacket(cmd, data, rsp = false) {
    return new Promise((resolve, reject) => {
      if (!this.available) {
        this.logger.logError("NapCat.Packet 未初始化！");
        return void 0;
      }
      const md5 = crypto__default.createHash("md5").update(data).digest("hex");
      const trace_id = (this.randText(4) + md5 + data).slice(0, data.length / 2);
      this.sendCommand(cmd, data, trace_id, rsp, 2e4, async () => {
        await this.napCatCore.context.session.getMsgService().sendSsoCmdReqByContend(cmd, trace_id);
      }).then((res) => resolve(res)).catch((e) => reject(e));
    });
  }
  async sendOidbPacket(pkt, rsp = false) {
    return this.sendPacket(pkt.cmd, pkt.data, rsp);
  }
}

/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value))
            return "array";
        if (value === null)
            return "null";
    }
    return t;
}
/**
 * Is this a JSON object (instead of an array or null)?
 */
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}

// lookup table from base64 character to byte
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for (let i = 0; i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
/**
 * Decodes a base64 string to a byte array.
 *
 * - ignores white-space, including line breaks and tabs
 * - allows inner padding (can decode concatenated base64 strings)
 * - does not require padding
 * - understands base64url encoding:
 *   "-" instead of "+",
 *   "_" instead of "/",
 *   no padding
 */
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=')
        es -= 2;
    else if (base64Str[base64Str.length - 1] == '=')
        es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
    groupPos = 0, // position in base64 group
    b, // current byte
    p = 0 // previous byte
    ;
    for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch (base64Str[i]) {
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch (groupPos) {
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1)
        throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
/**
 * Encodes a byte array to a base64 string.
 * Adds padding at the end.
 * Does not insert newlines.
 */
function base64encode(bytes) {
    let base64 = '', groupPos = 0, // position in base64 group
    b, // current byte
    p = 0; // carry over from previous byte
    for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1)
            base64 += '=';
    }
    return base64;
}

/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */
var UnknownFieldHandler;
(function (UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */
    UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */
    UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({ no: fieldNo, wireType, data });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */
    UnknownFieldHandler.onWrite = (typeName, message, writer) => {
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))
            writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */
    UnknownFieldHandler.list = (message, fieldNo) => {
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */
    UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
/**
 * Protobuf binary format wire types.
 *
 * A wire type provides just enough information to find the length of the
 * following value.
 *
 * See https://developers.google.com/protocol-buffers/docs/encoding#structure
 */
var WireType;
(function (WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */
    WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */
    WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */
    WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */
    WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */
    WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [lowBits, highBits];
        }
    }
    throw new Error('invalid varint');
}
/**
 * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
 */
function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !((shift >>> 7) == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
    const hasMoreBits = !((hi >> 3) == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !((shift >>> 7) == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push((hi >>> 31) & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
/**
 * Parse decimal string of 64 bit integer value as two JS numbers.
 *
 * Returns tuple:
 * [0]: minus sign?
 * [1]: low bits
 * [2]: high bits
 *
 * Copyright 2008 Google Inc.
 */
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus)
        dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL$1) {
            highBits = highBits + ((lowBits / TWO_PWR_32_DBL$1) | 0);
            lowBits = lowBits % TWO_PWR_32_DBL$1;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
}
/**
 * Format 64 bit integer value (as two JS numbers) to decimal string.
 *
 * Copyright 2008 Google Inc.
 */
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if ((bitsHigh >>> 0) <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
    let high = (bitsHigh >> 16) & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + (mid * 6777216) + (high * 6710656);
    let digitB = mid + (high * 8147497);
    let digitC = (high * 2);
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
        decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
        // If the final 1e7 digit didn't need leading zeros, we would have
        // returned via the trivial code path at the top.
        decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
/**
 * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
 */
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while (value > 0x7f) {
            bytes.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    }
    else {
        for (let i = 0; i < 9; i++) {
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
/**
 * Read an unsigned 32 bit varint.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
 */
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
    if ((b & 0x80) != 0)
        throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}

let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined
        && typeof dv.getBigInt64 === "function"
        && typeof dv.getBigUint64 === "function"
        && typeof dv.setBigInt64 === "function"
        && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv,
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi)
        throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */
    constructor(lo, hi) {
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */
    isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */
    toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result))
            throw new Error("cannot convert to safe number");
        return result;
    }
}
/**
 * 64-bit unsigned integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.UMIN)
                        throw new Error('signed value for ulong');
                    if (value > BI.UMAX)
                        throw new Error('ulong too large');
                    BI.V.setBigUint64(0, value, true);
                    return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = int64fromString(value);
                    if (minus)
                        throw new Error('signed value for ulong');
                    return new PbULong(lo, hi);
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    if (value < 0)
                        throw new Error('signed value for ulong');
                    return new PbULong(value, value / TWO_PWR_32_DBL);
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */
PbULong.ZERO = new PbULong(0, 0);
/**
 * 64-bit signed integer as two 32-bit values.
 * Converts between `string`, `number` and `bigint` representations.
 */
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */
    static from(value) {
        if (BI)
            // noinspection FallThroughInSwitchStatementJS
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    if (value == "")
                        throw new Error('string is no integer');
                    value = BI.C(value);
                case "number":
                    if (value === 0)
                        return this.ZERO;
                    value = BI.C(value);
                case "bigint":
                    if (!value)
                        return this.ZERO;
                    if (value < BI.MIN)
                        throw new Error('signed long too small');
                    if (value > BI.MAX)
                        throw new Error('signed long too large');
                    BI.V.setBigInt64(0, value, true);
                    return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
            }
        else
            switch (typeof value) {
                case "string":
                    if (value == "0")
                        return this.ZERO;
                    value = value.trim();
                    if (!RE_DECIMAL_STR.test(value))
                        throw new Error('string is no integer');
                    let [minus, lo, hi] = int64fromString(value);
                    if (minus) {
                        if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                            throw new Error('signed long too small');
                    }
                    else if (hi >= HALF_2_PWR_32)
                        throw new Error('signed long too large');
                    let pbl = new PbLong(lo, hi);
                    return minus ? pbl.negate() : pbl;
                case "number":
                    if (value == 0)
                        return this.ZERO;
                    if (!Number.isSafeInteger(value))
                        throw new Error('number is no integer');
                    return value > 0
                        ? new PbLong(value, value / TWO_PWR_32_DBL)
                        : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
            }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */
    isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */
    negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo)
            lo = ~lo + 1;
        else
            hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */
    toString() {
        if (BI)
            return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + int64toString(n.lo, n.hi);
        }
        return int64toString(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */
    toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */
PbLong.ZERO = new PbLong(0, 0);

const defaultsRead$1 = {
    readUnknownField: true,
    readerFactory: bytes => new BinaryReader(bytes),
};
/**
 * Make options for reading binary data form partial options.
 */
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
}
class BinaryReader {
    constructor(buf, textDecoder) {
        this.varint64 = varint64read; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */
        this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true,
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */
    skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch (wireType) {
            case WireType.Varint:
                while (this.buf[this.pos++] & 0x80) {
                    // ignore
                }
                break;
            case WireType.Bit64:
                this.pos += 4;
            case WireType.Bit32:
                this.pos += 4;
                break;
            case WireType.LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case WireType.StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while ((t = this.tag()[1]) !== WireType.EndGroup) {
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
        let zze = this.uint32();
        // decode zigzag
        return (zze >>> 1) ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
        return new PbLong(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
        return new PbULong(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
        hi = (hi >>> 1 ^ s);
        return new PbLong(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
        return new PbULong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
        return new PbLong(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
        return this.textDecoder.decode(this.bytes());
    }
}

/**
 * assert that condition is true or throw error (with message)
 */
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
        throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
        throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number")
        throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg))
        return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
        throw new Error('invalid float 32: ' + arg);
}

const defaultsWrite$1 = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
/**
 * Make options for writing binary data form partial options.
 */
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
}
class BinaryWriter {
    constructor(textEncoder) {
        /**
         * Previous fork states.
         */
        this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev)
            throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
        assertUInt32(value);
        // write value as varint 32, inlined for speed
        while (value > 0x7f) {
            this.buf.push((value & 0x7f) | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
        assertInt32(value);
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
        assertInt32(value);
        // zigzag encode
        value = ((value << 1) ^ (value >> 31)) >>> 0;
        varint32write(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbLong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = PbULong.from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
        let long = PbLong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
        let long = PbLong.from(value), 
        // zigzag encode
        sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
        varint64write(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
        let long = PbULong.from(value);
        varint64write(long.lo, long.hi, this.buf);
        return this;
    }
}

const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0,
}, defaultsRead = {
    ignoreUnknownFields: false,
};
/**
 * Make options for reading JSON data from partial options.
 */
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
/**
 * Make options for writing JSON data from partial options.
 */
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}

/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i = 0; i < snakeCase.length; i++) {
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        }
        else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        }
        else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        }
        else if (i == 0) {
            sb.push(next.toLowerCase());
        }
        else {
            sb.push(next);
        }
    }
    return sb.join('');
}

/**
 * Scalar value types. This is a subset of field types declared by protobuf
 * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
 * are omitted, but the numerical values are identical.
 */
var ScalarType;
(function (ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
/**
 * JavaScript representation of 64 bit integral types. Equivalent to the
 * field option "jstype".
 *
 * By default, protobuf-ts represents 64 bit types as `bigint`.
 *
 * You can change the default behaviour by enabling the plugin parameter
 * `long_type_string`, which will represent 64 bit types as `string`.
 *
 * Alternatively, you can change the behaviour for individual fields
 * with the field option "jstype":
 *
 * ```protobuf
 * uint64 my_field = 1 [jstype = JS_STRING];
 * uint64 other_field = 2 [jstype = JS_NUMBER];
 * ```
 */
var LongType;
(function (LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */
    LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */
    LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */
    LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
/**
 * Protobuf 2.1.0 introduced packed repeated fields.
 * Setting the field option `[packed = true]` enables packing.
 *
 * In proto3, all repeated fields are packed by default.
 * Setting the field option `[packed = false]` disables packing.
 *
 * Packed repeated fields are encoded with a single tag,
 * then a length-delimiter, then the element values.
 *
 * Unpacked repeated fields are encoded with a tag and
 * value for each element.
 *
 * `bytes` and `string` cannot be packed.
 */
var RepeatType;
(function (RepeatType) {
    /**
     * The field is not repeated.
     */
    RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */
    RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */
    RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
/**
 * Turns PartialFieldInfo into FieldInfo.
 */
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
    return field;
}

/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch (typeof any.oneofKind) {
        case "string":
            if (any[any.oneofKind] === undefined)
                return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}

// noinspection JSMethodCanBeStatic
class ReflectionTypeCheck {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data)
            return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields) {
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            }
            else {
                known.push(field.localName);
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat)
                            req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat)
                            req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */
    is(message, depth, allowExcessProperties = false) {
        if (depth < 0)
            return true;
        if (message === null || message === undefined || typeof message != 'object')
            return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
            return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some(k => !data.known.includes(k)))
                return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs) {
            const group = message[name];
            if (!isOneofGroup(group))
                return false;
            if (group.oneofKind === undefined)
                continue;
            const field = this.fields.find(f => f.localName === group.oneofKind);
            if (!field)
                return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                return false;
        }
        // check types
        for (const field of this.fields) {
            if (field.oneof !== undefined)
                continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch (field.kind) {
            case "scalar":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined)
                    return field.opt;
                if (repeated)
                    return this.scalars(arg, ScalarType.INT32, depth);
                return this.scalar(arg, ScalarType.INT32);
            case "message":
                if (arg === undefined)
                    return true;
                if (repeated)
                    return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null)
                    return false;
                if (depth < 2)
                    return true;
                if (!this.mapKeys(arg, field.K, depth))
                    return false;
                switch (field.V.kind) {
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), ScalarType.INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (allowExcessProperties) {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.isAssignable(arg[i], depth - 1))
                    return false;
        }
        else {
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!type.is(arg[i], depth - 1))
                    return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch (type) {
            case ScalarType.UINT64:
            case ScalarType.FIXED64:
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
                switch (longType) {
                    case LongType.BIGINT:
                        return argType == "bigint";
                    case LongType.NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case ScalarType.BOOL:
                return argType == 'boolean';
            case ScalarType.STRING:
                return argType == 'string';
            case ScalarType.BYTES:
                return arg instanceof Uint8Array;
            case ScalarType.DOUBLE:
            case ScalarType.FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg))
            return false;
        if (depth < 2)
            return true;
        if (Array.isArray(arg))
            for (let i = 0; i < arg.length && i < depth; i++)
                if (!this.scalar(arg[i], type, longType))
                    return false;
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch (type) {
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
            case ScalarType.UINT32:
                return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
            case ScalarType.BOOL:
                return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, LongType.STRING);
        }
    }
}

/**
 * Utility method to convert a PbLong or PbUlong to a JavaScript
 * representation during runtime.
 *
 * Works with generated field information, `undefined` is equivalent
 * to `STRING`.
 */
function reflectionLongConvert(long, type) {
    switch (type) {
        case LongType.BIGINT:
            return long.toBigInt();
        case LongType.NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}

/**
 * Reads proto3 messages in canonical JSON format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput) {
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = typeofJsonValue(jsonValue);
            if (what == "number" || what == "boolean")
                what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)) {
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields)
                    throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof))
                    throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert(isJsonObject(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch (field.V.kind) {
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == ScalarType.BOOL)
                        key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            }
            else if (field.repeat) {
                if (jsonValue === null)
                    continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue) {
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch (field.kind) {
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false)
                                continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            }
            else {
                switch (field.kind) {
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false)
                            continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */
    enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue')
            assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null)
            // we require 0 to be default value for all enums
            return 0;
        switch (typeof json) {
            case "number":
                assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2])
                    // lookup without the shared prefix
                    localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch (type) {
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case ScalarType.DOUBLE:
                case ScalarType.FLOAT:
                    if (json === null)
                        return .0;
                    if (json === "NaN")
                        return Number.NaN;
                    if (json === "Infinity")
                        return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity")
                        return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == ScalarType.FLOAT)
                        assertFloat32(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case ScalarType.INT32:
                case ScalarType.FIXED32:
                case ScalarType.SFIXED32:
                case ScalarType.SINT32:
                case ScalarType.UINT32:
                    if (json === null)
                        return 0;
                    let int32;
                    if (typeof json == "number")
                        int32 = json;
                    else if (json === "")
                        e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length)
                            e = "extra whitespace";
                        else
                            int32 = Number(json);
                    }
                    if (int32 === undefined)
                        break;
                    if (type == ScalarType.UINT32)
                        assertUInt32(int32);
                    else
                        assertInt32(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case ScalarType.INT64:
                case ScalarType.SFIXED64:
                case ScalarType.SINT64:
                    if (json === null)
                        return reflectionLongConvert(PbLong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return reflectionLongConvert(PbLong.from(json), longType);
                case ScalarType.FIXED64:
                case ScalarType.UINT64:
                    if (json === null)
                        return reflectionLongConvert(PbULong.ZERO, longType);
                    if (typeof json != "number" && typeof json != "string")
                        break;
                    return reflectionLongConvert(PbULong.from(json), longType);
                // bool:
                case ScalarType.BOOL:
                    if (json === null)
                        return false;
                    if (typeof json !== "boolean")
                        break;
                    return json;
                // string:
                case ScalarType.STRING:
                    if (json === null)
                        return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    }
                    catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case ScalarType.BYTES:
                    if (json === null || json === "")
                        return new Uint8Array(0);
                    if (typeof json !== 'string')
                        break;
                    return base64decode(json);
            }
        }
        catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}

/**
 * Writes proto3 messages in canonical JSON format using reflection
 * information.
 *
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 */
class ReflectionJsonWriter {
    constructor(info) {
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */
    write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields) {
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined)
                    json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName)
                continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum'
                ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            assert(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            assert(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch (field.V.kind) {
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        const val = this.message(messageType, entryValue, field.name, options);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)) {
                        assert(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        assert(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                jsonValue = jsonObj;
        }
        else if (field.repeat) {
            assert(Array.isArray(value));
            const jsonArr = [];
            switch (field.kind) {
                case "scalar":
                    for (let i = 0; i < value.length; i++) {
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for (let i = 0; i < value.length; i++) {
                        assert(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for (let i = 0; i < value.length; i++) {
                        const val = this.message(messageType, value[i], field.name, options);
                        assert(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                jsonValue = jsonArr;
        }
        else {
            switch (field.kind) {
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue')
            return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            assert(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional)
            // we require 0 to be default value for all enums
            return undefined;
        assert(typeof value == 'number');
        assert(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value))
            // if we don't now the enum value, just return the number
            return value;
        if (type[2])
            // restore the dropped prefix
            return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined)
            return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            assert(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch (type) {
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case ScalarType.INT32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                assertInt32(value);
                return value;
            case ScalarType.FIXED32:
            case ScalarType.UINT32:
                if (value === 0)
                    return ed ? 0 : undefined;
                assertUInt32(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case ScalarType.FLOAT:
                assertFloat32(value);
            case ScalarType.DOUBLE:
                if (value === 0)
                    return ed ? 0 : undefined;
                assert(typeof value == 'number');
                if (Number.isNaN(value))
                    return 'NaN';
                if (value === Number.POSITIVE_INFINITY)
                    return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY)
                    return '-Infinity';
                return value;
            // string:
            case ScalarType.STRING:
                if (value === "")
                    return ed ? '' : undefined;
                assert(typeof value == 'string');
                return value;
            // bool:
            case ScalarType.BOOL:
                if (value === false)
                    return ed ? false : undefined;
                assert(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case ScalarType.UINT64:
            case ScalarType.FIXED64:
                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = PbULong.from(value);
                if (ulong.isZero() && !ed)
                    return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case ScalarType.INT64:
            case ScalarType.SFIXED64:
            case ScalarType.SINT64:
                assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = PbLong.from(value);
                if (long.isZero() && !ed)
                    return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case ScalarType.BYTES:
                assert(value instanceof Uint8Array);
                if (!value.byteLength)
                    return ed ? "" : undefined;
                return base64encode(value);
        }
    }
}

/**
 * Creates the default value for a scalar type.
 */
function reflectionScalarDefault(type, longType = LongType.STRING) {
    switch (type) {
        case ScalarType.BOOL:
            return false;
        case ScalarType.UINT64:
        case ScalarType.FIXED64:
            return reflectionLongConvert(PbULong.ZERO, longType);
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
            return reflectionLongConvert(PbLong.ZERO, longType);
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
            return 0.0;
        case ScalarType.BYTES:
            return new Uint8Array(0);
        case ScalarType.STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}

/**
 * Reads proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryReader {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while (reader.pos < end) {
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw")
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false)
                    (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName)
                    target = message[field.oneof] = {
                        oneofKind: localName
                    };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while (reader.pos < e)
                                arr.push(this.scalar(reader, T, L));
                        }
                        else
                            arr.push(this.scalar(reader, T, L));
                    }
                    else
                        target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    }
                    else
                        target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */
    mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    if (field.K == ScalarType.BOOL)
                        key = reader.bool().toString();
                    else
                        // long types are read as string, number types are okay as number
                        key = this.scalar(reader, field.K, LongType.STRING);
                    break;
                case 2:
                    switch (field.V.kind) {
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = reflectionScalarDefault(field.K);
            key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined)
            switch (field.V.kind) {
                case "scalar":
                    val = reflectionScalarDefault(field.V.T, field.V.L);
                    break;
                case "enum":
                    val = 0;
                    break;
                case "message":
                    val = field.V.T().create();
                    break;
            }
        return [key, val];
    }
    scalar(reader, type, longType) {
        switch (type) {
            case ScalarType.INT32:
                return reader.int32();
            case ScalarType.STRING:
                return reader.string();
            case ScalarType.BOOL:
                return reader.bool();
            case ScalarType.DOUBLE:
                return reader.double();
            case ScalarType.FLOAT:
                return reader.float();
            case ScalarType.INT64:
                return reflectionLongConvert(reader.int64(), longType);
            case ScalarType.UINT64:
                return reflectionLongConvert(reader.uint64(), longType);
            case ScalarType.FIXED64:
                return reflectionLongConvert(reader.fixed64(), longType);
            case ScalarType.FIXED32:
                return reader.fixed32();
            case ScalarType.BYTES:
                return reader.bytes();
            case ScalarType.UINT32:
                return reader.uint32();
            case ScalarType.SFIXED32:
                return reader.sfixed32();
            case ScalarType.SFIXED64:
                return reflectionLongConvert(reader.sfixed64(), longType);
            case ScalarType.SINT32:
                return reader.sint32();
            case ScalarType.SINT64:
                return reflectionLongConvert(reader.sint64(), longType);
        }
    }
}

/**
 * Writes proto3 messages in binary format using reflection information.
 *
 * https://developers.google.com/protocol-buffers/docs/encoding
 */
class ReflectionBinaryWriter {
    constructor(info) {
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b) => a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */
    write(message, writer, options) {
        this.prepare();
        for (const field of this.fields) {
            let value, // this will be our field value, whether it is member of a oneof or not
            emitDefault, // whether we emit the default value (only true for oneof members)
            repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName)
                    continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            }
            else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch (field.kind) {
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                    if (repeated) {
                        assert(Array.isArray(value));
                        if (repeated == RepeatType.PACKED)
                            this.packed(writer, T, field.no, value);
                        else
                            for (const item of value)
                                this.scalar(writer, T, field.no, item, true);
                    }
                    else if (value === undefined)
                        assert(field.opt);
                    else
                        this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        assert(Array.isArray(value));
                        for (const item of value)
                            this.message(writer, options, field.T(), field.no, item);
                    }
                    else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    assert(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))
                        this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, WireType.LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch (field.K) {
            case ScalarType.INT32:
            case ScalarType.FIXED32:
            case ScalarType.UINT32:
            case ScalarType.SFIXED32:
            case ScalarType.SINT32:
                keyValue = Number.parseInt(key);
                break;
            case ScalarType.BOOL:
                assert(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch (field.V.kind) {
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, ScalarType.INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined)
            return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */
    scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */
    packed(writer, type, fieldNo, value) {
        if (!value.length)
            return;
        assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
        // write tag
        writer.tag(fieldNo, WireType.LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method,] = this.scalarInfo(type);
        for (let i = 0; i < value.length; i++)
            writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */
    scalarInfo(type, value) {
        let t = WireType.Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch (type) {
            case ScalarType.INT32:
                m = "int32";
                break;
            case ScalarType.STRING:
                d = i || !value.length;
                t = WireType.LengthDelimited;
                m = "string";
                break;
            case ScalarType.BOOL:
                d = value === false;
                m = "bool";
                break;
            case ScalarType.UINT32:
                m = "uint32";
                break;
            case ScalarType.DOUBLE:
                t = WireType.Bit64;
                m = "double";
                break;
            case ScalarType.FLOAT:
                t = WireType.Bit32;
                m = "float";
                break;
            case ScalarType.INT64:
                d = i || PbLong.from(value).isZero();
                m = "int64";
                break;
            case ScalarType.UINT64:
                d = i || PbULong.from(value).isZero();
                m = "uint64";
                break;
            case ScalarType.FIXED64:
                d = i || PbULong.from(value).isZero();
                t = WireType.Bit64;
                m = "fixed64";
                break;
            case ScalarType.BYTES:
                d = i || !value.byteLength;
                t = WireType.LengthDelimited;
                m = "bytes";
                break;
            case ScalarType.FIXED32:
                t = WireType.Bit32;
                m = "fixed32";
                break;
            case ScalarType.SFIXED32:
                t = WireType.Bit32;
                m = "sfixed32";
                break;
            case ScalarType.SFIXED64:
                d = i || PbLong.from(value).isZero();
                t = WireType.Bit64;
                m = "sfixed64";
                break;
            case ScalarType.SINT32:
                m = "sint32";
                break;
            case ScalarType.SINT64:
                d = i || PbLong.from(value).isZero();
                m = "sint64";
                break;
        }
        return [t, m, i || d];
    }
}

/**
 * Creates an instance of the generic message, using the field
 * information.
 */
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */
    const msg = type.messagePrototype
        ? Object.create(type.messagePrototype)
        : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
        let name = field.localName;
        if (field.opt)
            continue;
        if (field.oneof)
            msg[field.oneof] = { oneofKind: undefined };
        else if (field.repeat)
            msg[name] = [];
        else
            switch (field.kind) {
                case "scalar":
                    msg[name] = reflectionScalarDefault(field.T, field.L);
                    break;
                case "enum":
                    // we require 0 to be default value for all enums
                    msg[name] = 0;
                    break;
                case "map":
                    msg[name] = {};
                    break;
            }
    }
    return msg;
}

/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */
function reflectionMergePartial(info, target, source) {
    let fieldValue, // the field value we are working with
    input = source, output; // where we want our field value to go
    for (let field of info.fields) {
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) { // the user is free to omit
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        }
        else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat)
            output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch (field.kind) {
            case "scalar":
            case "enum":
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = fieldValue[i]; // not a reference type
                else
                    output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat)
                    for (let i = 0; i < fieldValue.length; i++)
                        output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined)
                    output[name] = T.create(fieldValue); // nothing to merge with
                else
                    T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch (field.V.kind) {
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T = field.V.T();
                        for (let k of Object.keys(fieldValue))
                            output[name][k] = T.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}

/**
 * Determines whether two message of the same type have the same field values.
 * Checks for deep equality, traversing repeated fields, oneof groups, maps
 * and messages recursively.
 * Will also return true if both messages are `undefined`.
 */
function reflectionEquals(info, a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    for (let field of info.fields) {
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch (field.kind) {
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
                if (!(field.repeat
                    ? repeatedPrimitiveEq(t, val_a, val_b)
                    : primitiveEq(t, val_a, val_b)))
                    return false;
                break;
            case "map":
                if (!(field.V.kind == "message"
                    ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                    : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                    return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat
                    ? repeatedMsgEq(T, val_a, val_b)
                    : T.equals(val_a, val_b)))
                    return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b)
        return true;
    if (type !== ScalarType.BYTES)
        return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length)
        return false;
    for (let i = 0; i < ba.length; i++)
        if (ba[i] != bb[i])
            return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!primitiveEq(type, a[i], b[i]))
            return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!type.equals(a[i], b[i]))
            return false;
    return true;
}

const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
/**
 * This standard message type provides reflection-based
 * operations to work with a message.
 */
class MessageType {
    constructor(name, fields, options) {
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(normalizeFieldInfo);
        this.options = options !== null && options !== void 0 ? options : {};
        this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
        this.refTypeCheck = new ReflectionTypeCheck(this);
        this.refJsonReader = new ReflectionJsonReader(this);
        this.refJsonWriter = new ReflectionJsonWriter(this);
        this.refBinReader = new ReflectionBinaryReader(this);
        this.refBinWriter = new ReflectionBinaryWriter(this);
    }
    create(value) {
        let message = reflectionCreate(this);
        if (value !== undefined) {
            reflectionMergePartial(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */
    clone(message) {
        let copy = this.create();
        reflectionMergePartial(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */
    equals(a, b) {
        return reflectionEquals(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */
    isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */
    mergePartial(target, source) {
        reflectionMergePartial(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */
    fromBinary(data, options) {
        let opt = binaryReadOptions(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */
    fromJson(json, options) {
        return this.internalJsonRead(json, jsonReadOptions(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */
    fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */
    toJson(message, options) {
        return this.internalJsonWrite(message, jsonWriteOptions(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */
    toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */
    toBinary(message, options) {
        let opt = binaryWriteOptions(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */
    internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */
    internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */
    internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}

function ProtoField(no, type, optional, repeat) {
  if (typeof type === "function") {
    return { kind: "message", no, type, optional: optional ?? false, repeat: repeat ?? false };
  } else {
    return { kind: "scalar", no, type, optional: optional ?? false, repeat: repeat ?? false };
  }
}
class NapProtoMsg {
  _msg;
  _field;
  _proto_msg;
  constructor(fields) {
    this._msg = fields;
    this._field = Object.keys(fields).map((key) => {
      const field = fields[key];
      if (field.kind === "scalar") {
        const repeatType = field.repeat ? [ScalarType.STRING, ScalarType.BYTES].includes(field.type) ? RepeatType.UNPACKED : RepeatType.PACKED : RepeatType.NO;
        return {
          no: field.no,
          name: key,
          kind: "scalar",
          T: field.type,
          opt: field.optional,
          repeat: repeatType
        };
      } else if (field.kind === "message") {
        return {
          no: field.no,
          name: key,
          kind: "message",
          repeat: field.repeat ? RepeatType.PACKED : RepeatType.NO,
          T: () => new NapProtoMsg(field.type())._proto_msg
        };
      }
    });
    this._proto_msg = new MessageType("nya", this._field);
  }
  encode(data) {
    return this._proto_msg.toBinary(this._proto_msg.create(data));
  }
  decode(data) {
    return this._proto_msg.fromBinary(data);
  }
}

const ForwardHead = {
  field1: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.UINT32, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  unknownBase64: ProtoField(5, ScalarType.STRING, true),
  avatar: ProtoField(6, ScalarType.STRING, true)
};
const Grp = {
  groupCode: ProtoField(1, ScalarType.UINT32, true)
};
const GrpTmp = {
  groupUin: ProtoField(1, ScalarType.UINT32, true),
  toUin: ProtoField(2, ScalarType.UINT32, true)
};
const ResponseForward = {
  friendName: ProtoField(6, ScalarType.STRING, true)
};
const ResponseGrp = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  memberName: ProtoField(4, ScalarType.STRING),
  unknown5: ProtoField(5, ScalarType.UINT32),
  groupName: ProtoField(7, ScalarType.STRING)
};
const Trans0X211 = {
  toUin: ProtoField(1, ScalarType.UINT64, true),
  ccCmd: ProtoField(2, ScalarType.UINT32, true),
  uid: ProtoField(8, ScalarType.STRING, true)
};
const WPATmp = {
  toUin: ProtoField(1, ScalarType.UINT64),
  sig: ProtoField(2, ScalarType.BYTES)
};

const Elem = {
  text: ProtoField(1, () => Text, true),
  face: ProtoField(2, () => Face, true),
  onlineImage: ProtoField(3, () => OnlineImage, true),
  notOnlineImage: ProtoField(4, () => NotOnlineImage, true),
  transElem: ProtoField(5, () => TransElem, true),
  marketFace: ProtoField(6, () => MarketFace, true),
  customFace: ProtoField(8, () => CustomFace, true),
  elemFlags2: ProtoField(9, () => ElemFlags2, true),
  richMsg: ProtoField(12, () => RichMsg, true),
  groupFile: ProtoField(13, () => GroupFile, true),
  extraInfo: ProtoField(16, () => ExtraInfo, true),
  videoFile: ProtoField(19, () => VideoFile, true),
  anonymousGroupMessage: ProtoField(21, () => AnonymousGroupMessage, true),
  customElem: ProtoField(31, () => CustomElem, true),
  generalFlags: ProtoField(37, () => GeneralFlags, true),
  srcMsg: ProtoField(45, () => SrcMsg, true),
  lightAppElem: ProtoField(51, () => LightAppElem, true),
  commonElem: ProtoField(53, () => CommonElem, true)
};
const Text = {
  str: ProtoField(1, ScalarType.STRING, true),
  lint: ProtoField(2, ScalarType.STRING, true),
  attr6Buf: ProtoField(3, ScalarType.BYTES, true),
  attr7Buf: ProtoField(4, ScalarType.BYTES, true),
  buf: ProtoField(11, ScalarType.BYTES, true),
  pbReserve: ProtoField(12, ScalarType.BYTES, true)
};
const Face = {
  index: ProtoField(1, ScalarType.INT32, true),
  old: ProtoField(2, ScalarType.BYTES, true),
  buf: ProtoField(11, ScalarType.BYTES, true)
};
const OnlineImage = {
  guid: ProtoField(1, ScalarType.BYTES),
  filePath: ProtoField(2, ScalarType.BYTES),
  oldVerSendFile: ProtoField(3, ScalarType.BYTES)
};
const NotOnlineImage = {
  filePath: ProtoField(1, ScalarType.STRING),
  fileLen: ProtoField(2, ScalarType.UINT32),
  downloadPath: ProtoField(3, ScalarType.STRING),
  oldVerSendFile: ProtoField(4, ScalarType.BYTES),
  imgType: ProtoField(5, ScalarType.INT32),
  previewsImage: ProtoField(6, ScalarType.BYTES),
  picMd5: ProtoField(7, ScalarType.BYTES),
  picHeight: ProtoField(8, ScalarType.UINT32),
  picWidth: ProtoField(9, ScalarType.UINT32),
  resId: ProtoField(10, ScalarType.STRING),
  flag: ProtoField(11, ScalarType.BYTES),
  thumbUrl: ProtoField(12, ScalarType.STRING),
  original: ProtoField(13, ScalarType.INT32),
  bigUrl: ProtoField(14, ScalarType.STRING),
  origUrl: ProtoField(15, ScalarType.STRING),
  bizType: ProtoField(16, ScalarType.INT32),
  result: ProtoField(17, ScalarType.INT32),
  index: ProtoField(18, ScalarType.INT32),
  opFaceBuf: ProtoField(19, ScalarType.BYTES),
  oldPicMd5: ProtoField(20, ScalarType.BOOL),
  thumbWidth: ProtoField(21, ScalarType.INT32),
  thumbHeight: ProtoField(22, ScalarType.INT32),
  fileId: ProtoField(23, ScalarType.INT32),
  showLen: ProtoField(24, ScalarType.UINT32),
  downloadLen: ProtoField(25, ScalarType.UINT32),
  x400Url: ProtoField(26, ScalarType.STRING),
  x400Width: ProtoField(27, ScalarType.INT32),
  x400Height: ProtoField(28, ScalarType.INT32),
  pbRes: ProtoField(29, () => NotOnlineImage_PbReserve)
};
const NotOnlineImage_PbReserve = {
  subType: ProtoField(1, ScalarType.INT32),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  summary: ProtoField(8, ScalarType.STRING),
  field10: ProtoField(10, ScalarType.INT32),
  field20: ProtoField(20, () => NotOnlineImage_PbReserve2),
  url: ProtoField(30, ScalarType.STRING),
  md5Str: ProtoField(31, ScalarType.STRING)
};
const NotOnlineImage_PbReserve2 = {
  field1: ProtoField(1, ScalarType.INT32),
  field2: ProtoField(2, ScalarType.STRING),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  field5: ProtoField(5, ScalarType.INT32),
  field7: ProtoField(7, ScalarType.STRING)
};
const TransElem = {
  elemType: ProtoField(1, ScalarType.INT32),
  elemValue: ProtoField(2, ScalarType.BYTES)
};
const MarketFace = {
  faceName: ProtoField(1, ScalarType.STRING),
  itemType: ProtoField(2, ScalarType.INT32),
  faceInfo: ProtoField(3, ScalarType.INT32),
  faceId: ProtoField(4, ScalarType.BYTES),
  tabId: ProtoField(5, ScalarType.INT32),
  subType: ProtoField(6, ScalarType.INT32),
  key: ProtoField(7, ScalarType.STRING),
  param: ProtoField(8, ScalarType.BYTES),
  mediaType: ProtoField(9, ScalarType.INT32),
  imageWidth: ProtoField(10, ScalarType.INT32),
  imageHeight: ProtoField(11, ScalarType.INT32),
  mobileparam: ProtoField(12, ScalarType.BYTES),
  pbReserve: ProtoField(13, () => MarketFacePbRes)
};
const MarketFacePbRes = {
  field8: ProtoField(8, ScalarType.INT32)
};
const CustomFace = {
  guid: ProtoField(1, ScalarType.BYTES),
  filePath: ProtoField(2, ScalarType.STRING),
  shortcut: ProtoField(3, ScalarType.STRING),
  buffer: ProtoField(4, ScalarType.BYTES),
  flag: ProtoField(5, ScalarType.BYTES),
  oldData: ProtoField(6, ScalarType.BYTES, true),
  fileId: ProtoField(7, ScalarType.UINT32),
  serverIp: ProtoField(8, ScalarType.INT32, true),
  serverPort: ProtoField(9, ScalarType.INT32, true),
  fileType: ProtoField(10, ScalarType.INT32),
  signature: ProtoField(11, ScalarType.BYTES),
  useful: ProtoField(12, ScalarType.INT32),
  md5: ProtoField(13, ScalarType.BYTES),
  thumbUrl: ProtoField(14, ScalarType.STRING),
  bigUrl: ProtoField(15, ScalarType.STRING),
  origUrl: ProtoField(16, ScalarType.STRING),
  bizType: ProtoField(17, ScalarType.INT32),
  repeatIndex: ProtoField(18, ScalarType.INT32),
  repeatImage: ProtoField(19, ScalarType.INT32),
  imageType: ProtoField(20, ScalarType.INT32),
  index: ProtoField(21, ScalarType.INT32),
  width: ProtoField(22, ScalarType.INT32),
  height: ProtoField(23, ScalarType.INT32),
  source: ProtoField(24, ScalarType.INT32),
  size: ProtoField(25, ScalarType.UINT32),
  origin: ProtoField(26, ScalarType.INT32),
  thumbWidth: ProtoField(27, ScalarType.INT32, true),
  thumbHeight: ProtoField(28, ScalarType.INT32, true),
  showLen: ProtoField(29, ScalarType.INT32),
  downloadLen: ProtoField(30, ScalarType.INT32),
  x400Url: ProtoField(31, ScalarType.STRING, true),
  x400Width: ProtoField(32, ScalarType.INT32),
  x400Height: ProtoField(33, ScalarType.INT32),
  pbRes: ProtoField(34, () => CustomFace_PbReserve, true)
};
const CustomFace_PbReserve = {
  subType: ProtoField(1, ScalarType.INT32),
  summary: ProtoField(9, ScalarType.STRING)
};
const ElemFlags2 = {
  colorTextId: ProtoField(1, ScalarType.UINT32),
  msgId: ProtoField(2, ScalarType.UINT64),
  whisperSessionId: ProtoField(3, ScalarType.UINT32),
  pttChangeBit: ProtoField(4, ScalarType.UINT32),
  vipStatus: ProtoField(5, ScalarType.UINT32),
  compatibleId: ProtoField(6, ScalarType.UINT32),
  insts: ProtoField(7, () => Instance, false, true),
  msgRptCnt: ProtoField(8, ScalarType.UINT32),
  srcInst: ProtoField(9, () => Instance),
  longtitude: ProtoField(10, ScalarType.UINT32),
  latitude: ProtoField(11, ScalarType.UINT32),
  customFont: ProtoField(12, ScalarType.UINT32),
  pcSupportDef: ProtoField(13, () => PcSupportDef),
  crmFlags: ProtoField(14, ScalarType.UINT32, true)
};
const PcSupportDef = {
  pcPtlBegin: ProtoField(1, ScalarType.UINT32),
  pcPtlEnd: ProtoField(2, ScalarType.UINT32),
  macPtlBegin: ProtoField(3, ScalarType.UINT32),
  macPtlEnd: ProtoField(4, ScalarType.UINT32),
  ptlsSupport: ProtoField(5, ScalarType.INT32, false, true),
  ptlsNotSupport: ProtoField(6, ScalarType.UINT32, false, true)
};
const Instance = {
  appId: ProtoField(1, ScalarType.UINT32),
  instId: ProtoField(2, ScalarType.UINT32)
};
const RichMsg = {
  template1: ProtoField(1, ScalarType.BYTES, true),
  serviceId: ProtoField(2, ScalarType.INT32, true),
  msgResId: ProtoField(3, ScalarType.BYTES, true),
  rand: ProtoField(4, ScalarType.INT32, true),
  seq: ProtoField(5, ScalarType.UINT32, true)
};
const GroupFile = {
  filename: ProtoField(1, ScalarType.BYTES),
  fileSize: ProtoField(2, ScalarType.UINT64),
  fileId: ProtoField(3, ScalarType.BYTES),
  batchId: ProtoField(4, ScalarType.BYTES),
  fileKey: ProtoField(5, ScalarType.BYTES),
  mark: ProtoField(6, ScalarType.BYTES),
  sequence: ProtoField(7, ScalarType.UINT64),
  batchItemId: ProtoField(8, ScalarType.BYTES),
  feedMsgTime: ProtoField(9, ScalarType.INT32),
  pbReserve: ProtoField(10, ScalarType.BYTES)
};
const ExtraInfo = {
  nick: ProtoField(1, ScalarType.BYTES),
  groupCard: ProtoField(2, ScalarType.BYTES),
  level: ProtoField(3, ScalarType.INT32),
  flags: ProtoField(4, ScalarType.INT32),
  groupMask: ProtoField(5, ScalarType.INT32),
  msgTailId: ProtoField(6, ScalarType.INT32),
  senderTitle: ProtoField(7, ScalarType.BYTES),
  apnsTips: ProtoField(8, ScalarType.BYTES),
  uin: ProtoField(9, ScalarType.UINT64),
  msgStateFlag: ProtoField(10, ScalarType.INT32),
  apnsSoundType: ProtoField(11, ScalarType.INT32),
  newGroupFlag: ProtoField(12, ScalarType.INT32)
};
const VideoFile = {
  fileUuid: ProtoField(1, ScalarType.STRING),
  fileMd5: ProtoField(2, ScalarType.BYTES),
  fileName: ProtoField(3, ScalarType.STRING),
  fileFormat: ProtoField(4, ScalarType.INT32),
  fileTime: ProtoField(5, ScalarType.INT32),
  fileSize: ProtoField(6, ScalarType.INT32),
  thumbWidth: ProtoField(7, ScalarType.INT32),
  thumbHeight: ProtoField(8, ScalarType.INT32),
  thumbFileMd5: ProtoField(9, ScalarType.BYTES),
  source: ProtoField(10, ScalarType.BYTES),
  thumbFileSize: ProtoField(11, ScalarType.INT32),
  busiType: ProtoField(12, ScalarType.INT32),
  fromChatType: ProtoField(13, ScalarType.INT32),
  toChatType: ProtoField(14, ScalarType.INT32),
  boolSupportProgressive: ProtoField(15, ScalarType.BOOL),
  fileWidth: ProtoField(16, ScalarType.INT32),
  fileHeight: ProtoField(17, ScalarType.INT32),
  subBusiType: ProtoField(18, ScalarType.INT32),
  videoAttr: ProtoField(19, ScalarType.INT32),
  bytesThumbFileUrls: ProtoField(20, ScalarType.BYTES, false, true),
  bytesVideoFileUrls: ProtoField(21, ScalarType.BYTES, false, true),
  thumbDownloadFlag: ProtoField(22, ScalarType.INT32),
  videoDownloadFlag: ProtoField(23, ScalarType.INT32),
  pbReserve: ProtoField(24, ScalarType.BYTES)
};
const AnonymousGroupMessage = {
  flags: ProtoField(1, ScalarType.INT32),
  anonId: ProtoField(2, ScalarType.BYTES),
  anonNick: ProtoField(3, ScalarType.BYTES),
  headPortrait: ProtoField(4, ScalarType.INT32),
  expireTime: ProtoField(5, ScalarType.INT32),
  bubbleId: ProtoField(6, ScalarType.INT32),
  rankColor: ProtoField(7, ScalarType.BYTES)
};
const CustomElem = {
  desc: ProtoField(1, ScalarType.BYTES),
  data: ProtoField(2, ScalarType.BYTES),
  enumType: ProtoField(3, ScalarType.INT32),
  ext: ProtoField(4, ScalarType.BYTES),
  sound: ProtoField(5, ScalarType.BYTES)
};
const GeneralFlags = {
  bubbleDiyTextId: ProtoField(1, ScalarType.INT32),
  groupFlagNew: ProtoField(2, ScalarType.INT32),
  uin: ProtoField(3, ScalarType.UINT64),
  rpId: ProtoField(4, ScalarType.BYTES),
  prpFold: ProtoField(5, ScalarType.INT32),
  longTextFlag: ProtoField(6, ScalarType.INT32),
  longTextResId: ProtoField(7, ScalarType.STRING, true),
  groupType: ProtoField(8, ScalarType.INT32),
  toUinFlag: ProtoField(9, ScalarType.INT32),
  glamourLevel: ProtoField(10, ScalarType.INT32),
  memberLevel: ProtoField(11, ScalarType.INT32),
  groupRankSeq: ProtoField(12, ScalarType.UINT64),
  olympicTorch: ProtoField(13, ScalarType.INT32),
  babyqGuideMsgCookie: ProtoField(14, ScalarType.BYTES),
  uin32ExpertFlag: ProtoField(15, ScalarType.INT32),
  bubbleSubId: ProtoField(16, ScalarType.INT32),
  pendantId: ProtoField(17, ScalarType.UINT64),
  rpIndex: ProtoField(18, ScalarType.BYTES),
  pbReserve: ProtoField(19, ScalarType.BYTES)
};
const SrcMsg = {
  origSeqs: ProtoField(1, ScalarType.UINT32, false, true),
  senderUin: ProtoField(2, ScalarType.UINT64),
  time: ProtoField(3, ScalarType.INT32, true),
  flag: ProtoField(4, ScalarType.INT32, true),
  elems: ProtoField(5, () => Elem, false, true),
  type: ProtoField(6, ScalarType.INT32, true),
  richMsg: ProtoField(7, ScalarType.BYTES, true),
  pbReserve: ProtoField(8, () => SrcMsgPbRes, true),
  sourceMsg: ProtoField(9, ScalarType.BYTES, true),
  toUin: ProtoField(10, ScalarType.UINT64, true),
  troopName: ProtoField(11, ScalarType.BYTES, true)
};
const SrcMsgPbRes = {
  messageId: ProtoField(3, ScalarType.UINT64),
  senderUid: ProtoField(6, ScalarType.STRING, true),
  receiverUid: ProtoField(7, ScalarType.STRING, true),
  friendSeq: ProtoField(8, ScalarType.UINT32, true)
};
const LightAppElem = {
  data: ProtoField(1, ScalarType.BYTES),
  msgResid: ProtoField(2, ScalarType.BYTES, true)
};
const CommonElem = {
  serviceType: ProtoField(1, ScalarType.INT32),
  pbElem: ProtoField(2, ScalarType.BYTES),
  businessType: ProtoField(3, ScalarType.UINT32)
};
({
  faceId: ProtoField(1, ScalarType.INT32, true)
});
const MentionExtra = {
  type: ProtoField(3, ScalarType.INT32, true),
  uin: ProtoField(4, ScalarType.UINT32, true),
  field5: ProtoField(5, ScalarType.INT32, true),
  uid: ProtoField(9, ScalarType.STRING, true)
};
const QBigFaceExtra = {
  AniStickerPackId: ProtoField(1, ScalarType.STRING, true),
  AniStickerId: ProtoField(2, ScalarType.STRING, true),
  faceId: ProtoField(3, ScalarType.INT32, true),
  Field4: ProtoField(4, ScalarType.INT32, true),
  AniStickerType: ProtoField(5, ScalarType.INT32, true),
  field6: ProtoField(6, ScalarType.STRING, true),
  preview: ProtoField(7, ScalarType.STRING, true),
  field9: ProtoField(9, ScalarType.INT32, true)
};
const QSmallFaceExtra = {
  faceId: ProtoField(1, ScalarType.UINT32),
  preview: ProtoField(2, ScalarType.STRING),
  preview2: ProtoField(3, ScalarType.STRING)
};
const MarkdownData = {
  content: ProtoField(1, ScalarType.STRING)
};

const Attr = {
  codePage: ProtoField(1, ScalarType.INT32),
  time: ProtoField(2, ScalarType.INT32),
  random: ProtoField(3, ScalarType.INT32),
  color: ProtoField(4, ScalarType.INT32),
  size: ProtoField(5, ScalarType.INT32),
  effect: ProtoField(6, ScalarType.INT32),
  charSet: ProtoField(7, ScalarType.INT32),
  pitchAndFamily: ProtoField(8, ScalarType.INT32),
  fontName: ProtoField(9, ScalarType.STRING),
  reserveData: ProtoField(10, ScalarType.BYTES)
};
const NotOnlineFile = {
  fileType: ProtoField(1, ScalarType.INT32, true),
  sig: ProtoField(2, ScalarType.BYTES, true),
  fileUuid: ProtoField(3, ScalarType.STRING, true),
  fileMd5: ProtoField(4, ScalarType.BYTES, true),
  fileName: ProtoField(5, ScalarType.STRING, true),
  fileSize: ProtoField(6, ScalarType.INT64, true),
  note: ProtoField(7, ScalarType.BYTES, true),
  reserved: ProtoField(8, ScalarType.INT32, true),
  subcmd: ProtoField(9, ScalarType.INT32, true),
  microCloud: ProtoField(10, ScalarType.INT32, true),
  bytesFileUrls: ProtoField(11, ScalarType.BYTES, false, true),
  downloadFlag: ProtoField(12, ScalarType.INT32, true),
  dangerEvel: ProtoField(50, ScalarType.INT32, true),
  lifeTime: ProtoField(51, ScalarType.INT32, true),
  uploadTime: ProtoField(52, ScalarType.INT32, true),
  absFileType: ProtoField(53, ScalarType.INT32, true),
  clientType: ProtoField(54, ScalarType.INT32, true),
  expireTime: ProtoField(55, ScalarType.INT32, true),
  pbReserve: ProtoField(56, ScalarType.BYTES, true),
  fileHash: ProtoField(57, ScalarType.STRING, true)
};
const Ptt = {
  fileType: ProtoField(1, ScalarType.INT32),
  srcUin: ProtoField(2, ScalarType.UINT64),
  fileUuid: ProtoField(3, ScalarType.STRING),
  fileMd5: ProtoField(4, ScalarType.BYTES),
  fileName: ProtoField(5, ScalarType.STRING),
  fileSize: ProtoField(6, ScalarType.INT32),
  reserve: ProtoField(7, ScalarType.BYTES),
  fileId: ProtoField(8, ScalarType.INT32),
  serverIp: ProtoField(9, ScalarType.INT32),
  serverPort: ProtoField(10, ScalarType.INT32),
  boolValid: ProtoField(11, ScalarType.BOOL),
  signature: ProtoField(12, ScalarType.BYTES),
  shortcut: ProtoField(13, ScalarType.BYTES),
  fileKey: ProtoField(14, ScalarType.BYTES),
  magicPttIndex: ProtoField(15, ScalarType.INT32),
  voiceSwitch: ProtoField(16, ScalarType.INT32),
  pttUrl: ProtoField(17, ScalarType.BYTES),
  groupFileKey: ProtoField(18, ScalarType.STRING),
  time: ProtoField(19, ScalarType.INT32),
  downPara: ProtoField(20, ScalarType.BYTES),
  format: ProtoField(29, ScalarType.INT32),
  pbReserve: ProtoField(30, ScalarType.BYTES),
  bytesPttUrls: ProtoField(31, ScalarType.BYTES, false, true),
  downloadFlag: ProtoField(32, ScalarType.INT32)
};
const RichText = {
  attr: ProtoField(1, () => Attr, true),
  elems: ProtoField(2, () => Elem, false, true),
  notOnlineFile: ProtoField(3, () => NotOnlineFile, true),
  ptt: ProtoField(4, () => Ptt, true)
};
({
  id: ProtoField(1, ScalarType.STRING),
  renderData: ProtoField(2, () => RenderData),
  action: ProtoField(3, () => Action)
});
const RenderData = {
  label: ProtoField(1, ScalarType.STRING),
  visitedLabel: ProtoField(2, ScalarType.STRING),
  style: ProtoField(3, ScalarType.INT32)
};
const Action = {
  type: ProtoField(1, ScalarType.INT32),
  permission: ProtoField(2, () => Permission),
  unsupportTips: ProtoField(4, ScalarType.STRING),
  data: ProtoField(5, ScalarType.STRING),
  reply: ProtoField(7, ScalarType.BOOL),
  enter: ProtoField(8, ScalarType.BOOL)
};
const Permission = {
  type: ProtoField(1, ScalarType.INT32),
  specifyRoleIds: ProtoField(2, ScalarType.STRING, false, true),
  specifyUserIds: ProtoField(3, ScalarType.STRING, false, true)
};
const FileExtra = {
  file: ProtoField(1, () => NotOnlineFile),
  field6: ProtoField(6, () => PrivateFileExtra)
};
const PrivateFileExtra = {
  field2: ProtoField(2, () => PrivateFileExtraField2)
};
const PrivateFileExtraField2 = {
  field1: ProtoField(1, ScalarType.UINT32),
  fileUuid: ProtoField(4, ScalarType.STRING),
  fileName: ProtoField(5, ScalarType.STRING),
  field6: ProtoField(6, ScalarType.UINT32),
  field7: ProtoField(7, ScalarType.BYTES),
  field8: ProtoField(8, ScalarType.BYTES),
  timestamp1: ProtoField(9, ScalarType.UINT32),
  fileHash: ProtoField(14, ScalarType.STRING),
  selfUid: ProtoField(15, ScalarType.STRING),
  destUid: ProtoField(16, ScalarType.STRING)
};
const GroupFileExtra = {
  field1: ProtoField(1, ScalarType.UINT32),
  fileName: ProtoField(2, ScalarType.STRING),
  display: ProtoField(3, ScalarType.STRING),
  inner: ProtoField(7, () => GroupFileExtraInner)
};
const GroupFileExtraInner = {
  info: ProtoField(2, () => GroupFileExtraInfo)
};
const GroupFileExtraInfo = {
  busId: ProtoField(1, ScalarType.UINT32),
  fileId: ProtoField(2, ScalarType.STRING),
  fileSize: ProtoField(3, ScalarType.UINT64),
  fileName: ProtoField(4, ScalarType.STRING),
  field5: ProtoField(5, ScalarType.UINT32),
  fileSha: ProtoField(6, ScalarType.BYTES),
  extInfoString: ProtoField(7, ScalarType.STRING),
  fileMd5: ProtoField(8, ScalarType.BYTES)
};
({
  origUrl: ProtoField(30, ScalarType.STRING)
});
({
  type: ProtoField(1, ScalarType.UINT32),
  field7: ProtoField(7, ScalarType.UINT32),
  field8: ProtoField(8, ScalarType.UINT32)
});

const C2C = {
  uin: ProtoField(1, ScalarType.UINT32, true),
  uid: ProtoField(2, ScalarType.STRING, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  sig: ProtoField(4, ScalarType.UINT32, true),
  receiverUin: ProtoField(5, ScalarType.UINT32, true),
  receiverUid: ProtoField(6, ScalarType.STRING, true)
};

const ContentHead = {
  type: ProtoField(1, ScalarType.UINT32),
  subType: ProtoField(2, ScalarType.UINT32, true),
  divSeq: ProtoField(3, ScalarType.UINT32, true),
  msgId: ProtoField(4, ScalarType.UINT32, true),
  sequence: ProtoField(5, ScalarType.UINT32, true),
  timeStamp: ProtoField(6, ScalarType.UINT32, true),
  field7: ProtoField(7, ScalarType.UINT64, true),
  field8: ProtoField(8, ScalarType.UINT32, true),
  field9: ProtoField(9, ScalarType.UINT32, true),
  newId: ProtoField(12, ScalarType.UINT64, true),
  forward: ProtoField(15, () => ForwardHead, true)
};
const MessageBody = {
  richText: ProtoField(1, () => RichText, true),
  msgContent: ProtoField(2, ScalarType.BYTES, true),
  msgEncryptContent: ProtoField(3, ScalarType.BYTES, true)
};
({
  routingHead: ProtoField(1, () => RoutingHead, true),
  contentHead: ProtoField(2, () => ContentHead, true),
  body: ProtoField(3, () => MessageBody, true),
  clientSequence: ProtoField(4, ScalarType.UINT32, true),
  random: ProtoField(5, ScalarType.UINT32, true),
  syncCookie: ProtoField(6, ScalarType.BYTES, true),
  via: ProtoField(8, ScalarType.UINT32, true),
  dataStatist: ProtoField(9, ScalarType.UINT32, true),
  ctrl: ProtoField(12, () => MessageControl, true),
  multiSendSeq: ProtoField(14, ScalarType.UINT32)
});
const MessageControl = {
  msgFlag: ProtoField(1, ScalarType.INT32)
};
({
  message: ProtoField(1, () => PushMsgBody),
  status: ProtoField(3, ScalarType.INT32, true),
  pingFlag: ProtoField(5, ScalarType.INT32, true),
  generalFlag: ProtoField(9, ScalarType.INT32, true)
});
const PushMsgBody = {
  responseHead: ProtoField(1, () => ResponseHead),
  contentHead: ProtoField(2, () => ContentHead),
  body: ProtoField(3, () => MessageBody, true)
};
const ResponseHead = {
  fromUin: ProtoField(1, ScalarType.UINT32),
  fromUid: ProtoField(2, ScalarType.STRING, true),
  type: ProtoField(3, ScalarType.UINT32),
  sigMap: ProtoField(4, ScalarType.UINT32),
  toUin: ProtoField(5, ScalarType.UINT32),
  toUid: ProtoField(6, ScalarType.STRING, true),
  forward: ProtoField(7, () => ResponseForward, true),
  grp: ProtoField(8, () => ResponseGrp, true)
};
const RoutingHead = {
  c2c: ProtoField(1, () => C2C, true),
  grp: ProtoField(2, () => Grp, true),
  grpTmp: ProtoField(3, () => GrpTmp, true),
  wpaTmp: ProtoField(6, () => WPATmp, true),
  trans0X211: ProtoField(15, () => Trans0X211, true)
};

({
  comm: ProtoField(1, () => PlatInfo, true),
  selfUin: ProtoField(2, ScalarType.UINT32),
  subCmd: ProtoField(3, ScalarType.UINT32),
  field6: ProtoField(6, ScalarType.UINT32)
});
const PlatInfo = {
  imPlat: ProtoField(1, ScalarType.UINT32),
  osVersion: ProtoField(2, ScalarType.STRING, true),
  qVersion: ProtoField(3, ScalarType.STRING, true)
};
({
  retCode: ProtoField(1, ScalarType.UINT32),
  errMsg: ProtoField(2, ScalarType.STRING),
  subCmd: ProtoField(3, ScalarType.UINT32),
  userInfo: ProtoField(6, () => FaceRoamUserInfo)
});
const FaceRoamUserInfo = {
  fileName: ProtoField(1, ScalarType.STRING, false, true),
  deleteFile: ProtoField(2, ScalarType.STRING, false, true),
  bid: ProtoField(3, ScalarType.STRING),
  maxRoamSize: ProtoField(4, ScalarType.UINT32),
  emojiType: ProtoField(5, ScalarType.UINT32, false, true)
};
({
  state: ProtoField(1, ScalarType.INT32),
  sizeCache: ProtoField(2, ScalarType.INT32),
  unknownFields: ProtoField(3, ScalarType.BYTES),
  routingHead: ProtoField(4, () => RoutingHead),
  contentHead: ProtoField(5, () => ContentHead),
  messageBody: ProtoField(6, () => MessageBody),
  msgSeq: ProtoField(7, ScalarType.INT32),
  msgRand: ProtoField(8, ScalarType.INT32),
  syncCookie: ProtoField(9, ScalarType.BYTES),
  msgVia: ProtoField(10, ScalarType.INT32),
  dataStatist: ProtoField(11, ScalarType.INT32),
  messageControl: ProtoField(12, () => MessageControl),
  multiSendSeq: ProtoField(13, ScalarType.INT32)
});
({
  result: ProtoField(1, ScalarType.INT32),
  errMsg: ProtoField(2, ScalarType.STRING, true),
  timestamp1: ProtoField(3, ScalarType.UINT32),
  field10: ProtoField(10, ScalarType.UINT32),
  groupSequence: ProtoField(11, ScalarType.UINT32, true),
  timestamp2: ProtoField(12, ScalarType.UINT32),
  privateSequence: ProtoField(14, ScalarType.UINT32)
});
({
  status: ProtoField(1, ScalarType.UINT32),
  extStatus: ProtoField(2, ScalarType.UINT32),
  batteryStatus: ProtoField(3, ScalarType.UINT32),
  customExt: ProtoField(4, () => SetStatusCustomExt, true)
});
const SetStatusCustomExt = {
  faceId: ProtoField(1, ScalarType.UINT32),
  text: ProtoField(2, ScalarType.STRING, true),
  field3: ProtoField(3, ScalarType.UINT32)
};
({
  message: ProtoField(2, ScalarType.STRING)
});
const HttpConn = {
  field1: ProtoField(1, ScalarType.INT32),
  field2: ProtoField(2, ScalarType.INT32),
  field3: ProtoField(3, ScalarType.INT32),
  field4: ProtoField(4, ScalarType.INT32),
  tgt: ProtoField(5, ScalarType.STRING),
  field6: ProtoField(6, ScalarType.INT32),
  serviceTypes: ProtoField(7, ScalarType.INT32, false, true),
  field9: ProtoField(9, ScalarType.INT32),
  field10: ProtoField(10, ScalarType.INT32),
  field11: ProtoField(11, ScalarType.INT32),
  ver: ProtoField(15, ScalarType.STRING)
};
const HttpConn0x6ff_501 = {
  httpConn: ProtoField(1281, () => HttpConn)
};
const HttpConn0x6ff_501Response = {
  httpConn: ProtoField(1281, () => HttpConnResponse)
};
const HttpConnResponse = {
  sigSession: ProtoField(1, ScalarType.BYTES),
  sessionKey: ProtoField(2, ScalarType.BYTES),
  serverInfos: ProtoField(3, () => ServerInfo, false, true)
};
const ServerAddr = {
  type: ProtoField(1, ScalarType.UINT32),
  ip: ProtoField(2, ScalarType.FIXED32),
  port: ProtoField(3, ScalarType.UINT32),
  area: ProtoField(4, ScalarType.UINT32)
};
const ServerInfo = {
  serviceType: ProtoField(1, ScalarType.UINT32),
  serverAddrs: ProtoField(2, () => ServerAddr, false, true)
};

const BUF7 = Buffer.alloc(7);
const deltas = [
  2654435769,
  1013904242,
  3668340011,
  2027808484,
  387276957,
  3041712726,
  1401181199,
  4055616968,
  2415085441,
  774553914,
  3428989683,
  1788458156,
  147926629,
  2802362398,
  1161830871,
  3816266640
];
function _toUInt32(num) {
  return num >>> 0;
}
function _encrypt(x, y, k0, k1, k2, k3) {
  for (let i = 0; i < 16; ++i) {
    let aa = (_toUInt32((y << 4 >>> 0) + k0) ^ _toUInt32(y + deltas[i])) >>> 0 ^ _toUInt32(~~(y / 32) + k1);
    aa >>>= 0;
    x = _toUInt32(x + aa);
    let bb = (_toUInt32((x << 4 >>> 0) + k2) ^ _toUInt32(x + deltas[i])) >>> 0 ^ _toUInt32(~~(x / 32) + k3);
    bb >>>= 0;
    y = _toUInt32(y + bb);
  }
  return [x, y];
}
function encrypt(data, key) {
  let n = 6 - data.length >>> 0;
  n = n % 8 + 2;
  const v = Buffer.concat([Buffer.from([n - 2 | 248]), Buffer.allocUnsafe(n), data, BUF7]);
  const k0 = key.readUInt32BE(0);
  const k1 = key.readUInt32BE(4);
  const k2 = key.readUInt32BE(8);
  const k3 = key.readUInt32BE(12);
  let r1 = 0, r2 = 0, t1 = 0, t2 = 0;
  for (let i = 0; i < v.length; i += 8) {
    const a1 = v.readUInt32BE(i);
    const a2 = v.readUInt32BE(i + 4);
    const b1 = a1 ^ r1;
    const b2 = a2 ^ r2;
    const [x, y] = _encrypt(b1 >>> 0, b2 >>> 0, k0, k1, k2, k3);
    r1 = x ^ t1;
    r2 = y ^ t2;
    t1 = b1;
    t2 = b2;
    v.writeInt32BE(r1, i);
    v.writeInt32BE(r2, i + 4);
  }
  return v;
}

const NTV2RichMediaReq = {
  ReqHead: ProtoField(1, () => MultiMediaReqHead),
  Upload: ProtoField(2, () => UploadReq),
  Download: ProtoField(3, () => DownloadReq),
  DownloadRKey: ProtoField(4, () => DownloadRKeyReq),
  Delete: ProtoField(5, () => DeleteReq),
  UploadCompleted: ProtoField(6, () => UploadCompletedReq),
  MsgInfoAuth: ProtoField(7, () => MsgInfoAuthReq),
  UploadKeyRenewal: ProtoField(8, () => UploadKeyRenewalReq),
  DownloadSafe: ProtoField(9, () => DownloadSafeReq),
  Extension: ProtoField(99, ScalarType.BYTES, true)
};
const MultiMediaReqHead = {
  Common: ProtoField(1, () => CommonHead),
  Scene: ProtoField(2, () => SceneInfo),
  Client: ProtoField(3, () => ClientMeta)
};
const CommonHead = {
  RequestId: ProtoField(1, ScalarType.UINT32),
  Command: ProtoField(2, ScalarType.UINT32)
};
const SceneInfo = {
  RequestType: ProtoField(101, ScalarType.UINT32),
  BusinessType: ProtoField(102, ScalarType.UINT32),
  SceneType: ProtoField(200, ScalarType.UINT32),
  C2C: ProtoField(201, () => C2CUserInfo, true),
  Group: ProtoField(202, () => NTGroupInfo, true)
};
const C2CUserInfo = {
  AccountType: ProtoField(1, ScalarType.UINT32),
  TargetUid: ProtoField(2, ScalarType.STRING)
};
const NTGroupInfo = {
  GroupUin: ProtoField(1, ScalarType.UINT32)
};
const ClientMeta = {
  AgentType: ProtoField(1, ScalarType.UINT32)
};
const DownloadReq = {
  Node: ProtoField(1, () => IndexNode),
  Download: ProtoField(2, () => DownloadExt)
};
const IndexNode = {
  Info: ProtoField(1, () => FileInfo),
  FileUuid: ProtoField(2, ScalarType.STRING),
  StoreId: ProtoField(3, ScalarType.UINT32),
  UploadTime: ProtoField(4, ScalarType.UINT32),
  Ttl: ProtoField(5, ScalarType.UINT32),
  SubType: ProtoField(6, ScalarType.UINT32)
};
const FileInfo = {
  FileSize: ProtoField(1, ScalarType.UINT32),
  FileHash: ProtoField(2, ScalarType.STRING),
  FileSha1: ProtoField(3, ScalarType.STRING),
  FileName: ProtoField(4, ScalarType.STRING),
  Type: ProtoField(5, () => FileType),
  Width: ProtoField(6, ScalarType.UINT32),
  Height: ProtoField(7, ScalarType.UINT32),
  Time: ProtoField(8, ScalarType.UINT32),
  Original: ProtoField(9, ScalarType.UINT32)
};
const FileType = {
  Type: ProtoField(1, ScalarType.UINT32),
  PicFormat: ProtoField(2, ScalarType.UINT32),
  VideoFormat: ProtoField(3, ScalarType.UINT32),
  VoiceFormat: ProtoField(4, ScalarType.UINT32)
};
const DownloadExt = {
  Pic: ProtoField(1, () => PicDownloadExt),
  Video: ProtoField(2, () => VideoDownloadExt),
  Ptt: ProtoField(3, () => PttDownloadExt)
};
const VideoDownloadExt = {
  BusiType: ProtoField(1, ScalarType.UINT32),
  SceneType: ProtoField(2, ScalarType.UINT32),
  SubBusiType: ProtoField(3, ScalarType.UINT32)
};
const PicDownloadExt = {};
const PttDownloadExt = {};
const DownloadRKeyReq = {
  Types: ProtoField(1, ScalarType.INT32, false, true)
};
const DeleteReq = {
  Index: ProtoField(1, () => IndexNode, false, true),
  NeedRecallMsg: ProtoField(2, ScalarType.BOOL),
  MsgSeq: ProtoField(3, ScalarType.UINT64),
  MsgRandom: ProtoField(4, ScalarType.UINT64),
  MsgTime: ProtoField(5, ScalarType.UINT64)
};
const UploadCompletedReq = {
  SrvSendMsg: ProtoField(1, ScalarType.BOOL),
  ClientRandomId: ProtoField(2, ScalarType.UINT64),
  MsgInfo: ProtoField(3, () => MsgInfo),
  ClientSeq: ProtoField(4, ScalarType.UINT32)
};
const MsgInfoAuthReq = {
  Msg: ProtoField(1, ScalarType.BYTES),
  AuthTime: ProtoField(2, ScalarType.UINT64)
};
const DownloadSafeReq = {
  Index: ProtoField(1, () => IndexNode)
};
const UploadKeyRenewalReq = {
  OldUKey: ProtoField(1, ScalarType.STRING),
  SubType: ProtoField(2, ScalarType.UINT32)
};
const MsgInfo = {
  MsgInfoBody: ProtoField(1, () => MsgInfoBody, false, true),
  ExtBizInfo: ProtoField(2, () => ExtBizInfo)
};
const MsgInfoBody = {
  Index: ProtoField(1, () => IndexNode),
  Picture: ProtoField(2, () => PictureInfo),
  Video: ProtoField(3, () => VideoInfo),
  Audio: ProtoField(4, () => AudioInfo),
  FileExist: ProtoField(5, ScalarType.BOOL),
  HashSum: ProtoField(6, ScalarType.BYTES)
};
const VideoInfo = {};
const AudioInfo = {};
const PictureInfo = {
  UrlPath: ProtoField(1, ScalarType.STRING),
  Ext: ProtoField(2, () => PicUrlExtInfo),
  Domain: ProtoField(3, ScalarType.STRING)
};
const PicUrlExtInfo = {
  OriginalParameter: ProtoField(1, ScalarType.STRING),
  BigParameter: ProtoField(2, ScalarType.STRING),
  ThumbParameter: ProtoField(3, ScalarType.STRING)
};
const VideoExtInfo = {
  VideoCodecFormat: ProtoField(1, ScalarType.UINT32)
};
const ExtBizInfo = {
  Pic: ProtoField(1, () => PicExtBizInfo),
  Video: ProtoField(2, () => VideoExtBizInfo),
  Ptt: ProtoField(3, () => PttExtBizInfo),
  BusiType: ProtoField(10, ScalarType.UINT32)
};
const PttExtBizInfo = {
  SrcUin: ProtoField(1, ScalarType.UINT64),
  PttScene: ProtoField(2, ScalarType.UINT32),
  PttType: ProtoField(3, ScalarType.UINT32),
  ChangeVoice: ProtoField(4, ScalarType.UINT32),
  Waveform: ProtoField(5, ScalarType.BYTES),
  AutoConvertText: ProtoField(6, ScalarType.UINT32),
  BytesReserve: ProtoField(11, ScalarType.BYTES),
  BytesPbReserve: ProtoField(12, ScalarType.BYTES),
  BytesGeneralFlags: ProtoField(13, ScalarType.BYTES)
};
const VideoExtBizInfo = {
  FromScene: ProtoField(1, ScalarType.UINT32),
  ToScene: ProtoField(2, ScalarType.UINT32),
  BytesPbReserve: ProtoField(3, ScalarType.BYTES)
};
const PicExtBizInfo = {
  BizType: ProtoField(1, ScalarType.UINT32),
  TextSummary: ProtoField(2, ScalarType.STRING),
  BytesPbReserveC2c: ProtoField(11, ScalarType.BYTES),
  BytesPbReserveTroop: ProtoField(12, ScalarType.BYTES),
  FromScene: ProtoField(1001, ScalarType.UINT32),
  ToScene: ProtoField(1002, ScalarType.UINT32),
  OldFileId: ProtoField(1003, ScalarType.UINT32)
};
const UploadReq = {
  UploadInfo: ProtoField(1, () => UploadInfo, false, true),
  TryFastUploadCompleted: ProtoField(2, ScalarType.BOOL),
  SrvSendMsg: ProtoField(3, ScalarType.BOOL),
  ClientRandomId: ProtoField(4, ScalarType.UINT64),
  CompatQMsgSceneType: ProtoField(5, ScalarType.UINT32),
  ExtBizInfo: ProtoField(6, () => ExtBizInfo),
  ClientSeq: ProtoField(7, ScalarType.UINT32),
  NoNeedCompatMsg: ProtoField(8, ScalarType.BOOL)
};
const UploadInfo = {
  FileInfo: ProtoField(1, () => FileInfo),
  SubFileType: ProtoField(2, ScalarType.UINT32)
};

const DataHighwayHead = {
  version: ProtoField(1, ScalarType.UINT32),
  uin: ProtoField(2, ScalarType.STRING, true),
  command: ProtoField(3, ScalarType.STRING, true),
  seq: ProtoField(4, ScalarType.UINT32, true),
  retryTimes: ProtoField(5, ScalarType.UINT32, true),
  appId: ProtoField(6, ScalarType.UINT32),
  dataFlag: ProtoField(7, ScalarType.UINT32),
  commandId: ProtoField(8, ScalarType.UINT32),
  buildVer: ProtoField(9, ScalarType.BYTES, true)
};
const FileUploadExt = {
  unknown1: ProtoField(1, ScalarType.INT32),
  unknown2: ProtoField(2, ScalarType.INT32),
  unknown3: ProtoField(3, ScalarType.INT32),
  entry: ProtoField(100, () => FileUploadEntry),
  unknown200: ProtoField(200, ScalarType.INT32)
};
const FileUploadEntry = {
  busiBuff: ProtoField(100, () => ExcitingBusiInfo),
  fileEntry: ProtoField(200, () => ExcitingFileEntry),
  clientInfo: ProtoField(300, () => ExcitingClientInfo),
  fileNameInfo: ProtoField(400, () => ExcitingFileNameInfo),
  host: ProtoField(500, () => ExcitingHostConfig)
};
const ExcitingBusiInfo = {
  busId: ProtoField(1, ScalarType.INT32),
  senderUin: ProtoField(100, ScalarType.UINT64),
  receiverUin: ProtoField(200, ScalarType.UINT64),
  groupCode: ProtoField(400, ScalarType.UINT64)
};
const ExcitingFileEntry = {
  fileSize: ProtoField(100, ScalarType.UINT64),
  md5: ProtoField(200, ScalarType.BYTES),
  checkKey: ProtoField(300, ScalarType.BYTES),
  md5S2: ProtoField(400, ScalarType.BYTES),
  fileId: ProtoField(600, ScalarType.STRING),
  uploadKey: ProtoField(700, ScalarType.BYTES)
};
const ExcitingClientInfo = {
  clientType: ProtoField(100, ScalarType.INT32),
  appId: ProtoField(200, ScalarType.STRING),
  terminalType: ProtoField(300, ScalarType.INT32),
  clientVer: ProtoField(400, ScalarType.STRING),
  unknown: ProtoField(600, ScalarType.INT32)
};
const ExcitingFileNameInfo = {
  fileName: ProtoField(100, ScalarType.STRING)
};
const ExcitingHostConfig = {
  hosts: ProtoField(200, () => ExcitingHostInfo, false, true)
};
const ExcitingHostInfo = {
  url: ProtoField(1, () => ExcitingUrlInfo),
  port: ProtoField(2, ScalarType.UINT32)
};
const ExcitingUrlInfo = {
  unknown: ProtoField(1, ScalarType.INT32),
  host: ProtoField(2, ScalarType.STRING)
};
const LoginSigHead = {
  uint32LoginSigType: ProtoField(1, ScalarType.UINT32),
  bytesLoginSig: ProtoField(2, ScalarType.BYTES),
  appId: ProtoField(3, ScalarType.UINT32)
};
const NTV2RichMediaHighwayExt = {
  fileUuid: ProtoField(1, ScalarType.STRING),
  uKey: ProtoField(2, ScalarType.STRING),
  network: ProtoField(5, () => NTHighwayNetwork),
  msgInfoBody: ProtoField(6, () => MsgInfoBody, false, true),
  blockSize: ProtoField(10, ScalarType.UINT32),
  hash: ProtoField(11, () => NTHighwayHash)
};
const NTHighwayHash = {
  fileSha1: ProtoField(1, ScalarType.BYTES, false, true)
};
const NTHighwayNetwork = {
  ipv4s: ProtoField(1, () => NTHighwayIPv4, false, true)
};
const NTHighwayIPv4 = {
  domain: ProtoField(1, () => NTHighwayDomain),
  port: ProtoField(2, ScalarType.UINT32)
};
const NTHighwayDomain = {
  isEnable: ProtoField(1, ScalarType.BOOL),
  ip: ProtoField(2, ScalarType.STRING)
};
const ReqDataHighwayHead = {
  msgBaseHead: ProtoField(1, () => DataHighwayHead, true),
  msgSegHead: ProtoField(2, () => SegHead, true),
  bytesReqExtendInfo: ProtoField(3, ScalarType.BYTES, true),
  timestamp: ProtoField(4, ScalarType.UINT64),
  msgLoginSigHead: ProtoField(5, () => LoginSigHead, true)
};
const RespDataHighwayHead = {
  msgBaseHead: ProtoField(1, () => DataHighwayHead, true),
  msgSegHead: ProtoField(2, () => SegHead, true),
  errorCode: ProtoField(3, ScalarType.UINT32),
  allowRetry: ProtoField(4, ScalarType.UINT32),
  cacheCost: ProtoField(5, ScalarType.UINT32),
  htCost: ProtoField(6, ScalarType.UINT32),
  bytesRspExtendInfo: ProtoField(7, ScalarType.BYTES, true),
  timestamp: ProtoField(8, ScalarType.UINT64),
  range: ProtoField(9, ScalarType.UINT64),
  isReset: ProtoField(10, ScalarType.UINT32)
};
const SegHead = {
  serviceId: ProtoField(1, ScalarType.UINT32, true),
  filesize: ProtoField(2, ScalarType.UINT64),
  dataOffset: ProtoField(3, ScalarType.UINT64, true),
  dataLength: ProtoField(4, ScalarType.UINT32),
  retCode: ProtoField(5, ScalarType.UINT32, true),
  serviceTicket: ProtoField(6, ScalarType.BYTES),
  flag: ProtoField(7, ScalarType.UINT32, true),
  md5: ProtoField(8, ScalarType.BYTES),
  fileMd5: ProtoField(9, ScalarType.BYTES),
  cacheAddr: ProtoField(10, ScalarType.UINT32, true),
  queryTimes: ProtoField(11, ScalarType.UINT32),
  updateCacheIp: ProtoField(12, ScalarType.UINT32),
  cachePort: ProtoField(13, ScalarType.UINT32, true)
};
({
  type: ProtoField(1, ScalarType.UINT32),
  groupUin: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, () => GroupAvatarExtraField3),
  field5: ProtoField(5, ScalarType.UINT32),
  field6: ProtoField(6, ScalarType.UINT32)
});
const GroupAvatarExtraField3 = {
  field1: ProtoField(1, ScalarType.UINT32)
};

class Frame {
  static pack(head, body) {
    const totalLength = 9 + head.length + body.length + 1;
    const buffer = Buffer.allocUnsafe(totalLength);
    buffer[0] = 40;
    buffer.writeUInt32BE(head.length, 1);
    buffer.writeUInt32BE(body.length, 5);
    head.copy(buffer, 9);
    body.copy(buffer, 9 + head.length);
    buffer[totalLength - 1] = 41;
    return buffer;
  }
  static unpack(frame) {
    assert$1(frame[0] === 40 && frame[frame.length - 1] === 41, "Invalid frame!");
    const headLen = frame.readUInt32BE(1);
    const bodyLen = frame.readUInt32BE(5);
    return [frame.subarray(9, 9 + headLen), frame.subarray(9 + headLen, 9 + headLen + bodyLen)];
  }
}

class HighwayUploader {
  trans;
  logger;
  constructor(trans, logger) {
    this.trans = trans;
    this.logger = logger;
  }
  encryptTransExt(key) {
    if (!this.trans.encrypt) return;
    this.trans.ext = encrypt(Buffer.from(this.trans.ext), Buffer.from(key));
  }
  timeout() {
    return new Promise((_, reject) => {
      setTimeout(
        () => {
          reject(new Error(`[Highway] timeout after ${this.trans.timeout}s`));
        },
        (this.trans.timeout ?? Infinity) * 1e3
      );
    });
  }
  buildPicUpHead(offset, bodyLength, bodyMd5) {
    return new NapProtoMsg(ReqDataHighwayHead).encode({
      msgBaseHead: {
        version: 1,
        uin: this.trans.uin,
        command: "PicUp.DataUp",
        seq: 0,
        retryTimes: 0,
        appId: 1600001604,
        dataFlag: 16,
        commandId: this.trans.cmd
      },
      msgSegHead: {
        serviceId: 0,
        filesize: BigInt(this.trans.size),
        dataOffset: BigInt(offset),
        dataLength: bodyLength,
        serviceTicket: this.trans.ticket,
        md5: bodyMd5,
        fileMd5: this.trans.sum,
        cacheAddr: 0,
        cachePort: 0
      },
      bytesReqExtendInfo: this.trans.ext,
      timestamp: BigInt(0),
      msgLoginSigHead: {
        uint32LoginSigType: 8,
        appId: 1600001604
      }
    });
  }
}
class HighwayTcpUploaderTransform extends stream.Transform {
  uploader;
  offset;
  constructor(uploader) {
    super();
    this.uploader = uploader;
    this.offset = 0;
  }
  _transform(data, _, callback) {
    let chunkOffset = 0;
    while (chunkOffset < data.length) {
      const chunkSize = Math.min(BlockSize, data.length - chunkOffset);
      const chunk = data.subarray(chunkOffset, chunkOffset + chunkSize);
      const chunkMd5 = crypto.createHash("md5").update(chunk).digest();
      const head = this.uploader.buildPicUpHead(this.offset, chunk.length, chunkMd5);
      chunkOffset += chunk.length;
      this.offset += chunk.length;
      this.push(Frame.pack(Buffer.from(head), chunk));
    }
    callback(null);
  }
}
class HighwayTcpUploader extends HighwayUploader {
  async upload() {
    const controller = new AbortController();
    const { signal } = controller;
    const upload = new Promise((resolve, reject) => {
      const highwayTransForm = new HighwayTcpUploaderTransform(this);
      const socket = net.connect(this.trans.port, this.trans.server, () => {
        this.trans.data.pipe(highwayTransForm).pipe(socket, { end: false });
      });
      const handleRspHeader = (header) => {
        const rsp = new NapProtoMsg(RespDataHighwayHead).decode(header);
        if (rsp.errorCode !== 0) {
          socket.end();
          reject(new Error(`[Highway] tcpUpload failed (code=${rsp.errorCode})`));
        }
        const percent = ((Number(rsp.msgSegHead?.dataOffset) + Number(rsp.msgSegHead?.dataLength)) / Number(rsp.msgSegHead?.filesize)).toFixed(2);
        this.logger.logDebug(`[Highway] tcpUpload ${rsp.errorCode} | ${percent} | ${Buffer.from(header).toString("hex")}`);
        if (Number(rsp.msgSegHead?.dataOffset) + Number(rsp.msgSegHead?.dataLength) >= Number(rsp.msgSegHead?.filesize)) {
          this.logger.logDebug("[Highway] tcpUpload finished.");
          socket.end();
          resolve();
        }
      };
      socket.on("data", (chunk) => {
        if (signal.aborted) {
          socket.end();
          reject(new Error("Upload aborted due to timeout"));
        }
        const [head, _] = Frame.unpack(chunk);
        handleRspHeader(head);
      });
      socket.on("close", () => {
        this.logger.logDebug("[Highway] tcpUpload socket closed.");
        resolve();
      });
      socket.on("error", (err) => {
        socket.end();
        reject(new Error(`[Highway] tcpUpload socket.on error: ${err}`));
      });
      this.trans.data.on("error", (err) => {
        socket.end();
        reject(new Error(`[Highway] tcpUpload readable error: ${err}`));
      });
    });
    const timeout = this.timeout().catch((err) => {
      controller.abort();
      throw new Error(err.message);
    });
    await Promise.race([upload, timeout]);
  }
}
class HighwayHttpUploader extends HighwayUploader {
  async upload() {
    const controller = new AbortController();
    const { signal } = controller;
    const upload = (async () => {
      let offset = 0;
      for await (const chunk of this.trans.data) {
        if (signal.aborted) {
          throw new Error("Upload aborted due to timeout");
        }
        const block = chunk;
        try {
          await this.uploadBlock(block, offset);
        } catch (err) {
          throw new Error(`[Highway] httpUpload Error uploading block at offset ${offset}: ${err}`);
        }
        offset += block.length;
      }
    })();
    const timeout = this.timeout().catch((err) => {
      controller.abort();
      throw new Error(err.message);
    });
    await Promise.race([upload, timeout]);
  }
  async uploadBlock(block, offset) {
    const chunkMD5 = crypto.createHash("md5").update(block).digest();
    const payload = this.buildPicUpHead(offset, block.length, chunkMD5);
    const frame = Frame.pack(Buffer.from(payload), block);
    const resp = await this.httpPostHighwayContent(frame, `http://${this.trans.server}:${this.trans.port}/cgi-bin/httpconn?htcmd=0x6FF0087&uin=${this.trans.uin}`);
    const [head, body] = Frame.unpack(resp);
    const headData = new NapProtoMsg(RespDataHighwayHead).decode(head);
    this.logger.logDebug(`[Highway] httpUploadBlock: ${headData.errorCode} | ${headData.msgSegHead?.retCode} | ${headData.bytesRspExtendInfo} | ${head.toString("hex")} | ${body.toString("hex")}`);
    if (headData.errorCode !== 0) throw new Error(`[Highway] httpUploadBlock failed (code=${headData.errorCode})`);
  }
  async httpPostHighwayContent(frame, serverURL) {
    return new Promise((resolve, reject) => {
      try {
        const options = {
          method: "POST",
          headers: {
            "Connection": "keep-alive",
            "Accept-Encoding": "identity",
            "User-Agent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2)",
            "Content-Length": frame.length.toString()
          }
        };
        const req = http$1.request(serverURL, options, (res) => {
          const data = [];
          res.on("data", (chunk) => {
            data.push(chunk);
          });
          res.on("end", () => {
            resolve(Buffer.concat(data));
          });
        });
        req.write(frame);
        req.on("error", (error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    });
  }
}

class PacketHighwayClient {
  sig;
  server = "htdata3.qq.com";
  port = 80;
  logger;
  constructor(sig, logger, server = "htdata3.qq.com", port = 80) {
    this.sig = sig;
    this.logger = logger;
  }
  changeServer(server, port) {
    this.server = server;
    this.port = port;
  }
  buildDataUpTrans(cmd, data, fileSize, md5, extendInfo, timeout = 1200) {
    return {
      uin: this.sig.uin,
      cmd,
      command: "PicUp.DataUp",
      data,
      sum: md5,
      size: fileSize,
      ticket: this.sig.sigSession,
      ext: extendInfo,
      encrypt: false,
      timeout,
      server: this.server,
      port: this.port
    };
  }
  async upload(cmd, data, fileSize, md5, extendInfo) {
    const trans = this.buildDataUpTrans(cmd, data, fileSize, md5, extendInfo);
    try {
      const tcpUploader = new HighwayTcpUploader(trans, this.logger);
      await tcpUploader.upload();
    } catch (e) {
      this.logger.logError(`[Highway] upload failed: ${e}, fallback to http upload`);
      try {
        const httpUploader = new HighwayHttpUploader(trans, this.logger);
        await httpUploader.upload();
      } catch (e2) {
        this.logger.logError(`[Highway] http upload failed: ${e2}`);
        throw e2;
      }
    }
  }
}

const NTV2RichMediaResp = {
  respHead: ProtoField(1, () => MultiMediaRespHead),
  upload: ProtoField(2, () => UploadResp),
  download: ProtoField(3, () => DownloadResp),
  downloadRKey: ProtoField(4, () => DownloadRKeyResp),
  delete: ProtoField(5, () => DeleteResp),
  uploadCompleted: ProtoField(6, () => UploadCompletedResp),
  msgInfoAuth: ProtoField(7, () => MsgInfoAuthResp),
  uploadKeyRenewal: ProtoField(8, () => UploadKeyRenewalResp),
  downloadSafe: ProtoField(9, () => DownloadSafeResp),
  extension: ProtoField(99, ScalarType.BYTES, true)
};
const MultiMediaRespHead = {
  common: ProtoField(1, () => CommonHead),
  retCode: ProtoField(2, ScalarType.UINT32),
  message: ProtoField(3, ScalarType.STRING)
};
const DownloadResp = {
  rKeyParam: ProtoField(1, ScalarType.STRING),
  rKeyTtlSecond: ProtoField(2, ScalarType.UINT32),
  info: ProtoField(3, () => DownloadInfo),
  rKeyCreateTime: ProtoField(4, ScalarType.UINT32)
};
const DownloadInfo = {
  domain: ProtoField(1, ScalarType.STRING),
  urlPath: ProtoField(2, ScalarType.STRING),
  httpsPort: ProtoField(3, ScalarType.UINT32),
  ipv4s: ProtoField(4, () => IPv4, false, true),
  ipv6s: ProtoField(5, () => IPv6, false, true),
  picUrlExtInfo: ProtoField(6, () => PicUrlExtInfo),
  videoExtInfo: ProtoField(7, () => VideoExtInfo)
};
const IPv4 = {
  outIP: ProtoField(1, ScalarType.UINT32),
  outPort: ProtoField(2, ScalarType.UINT32),
  inIP: ProtoField(3, ScalarType.UINT32),
  inPort: ProtoField(4, ScalarType.UINT32),
  ipType: ProtoField(5, ScalarType.UINT32)
};
const IPv6 = {
  outIP: ProtoField(1, ScalarType.BYTES),
  outPort: ProtoField(2, ScalarType.UINT32),
  inIP: ProtoField(3, ScalarType.BYTES),
  inPort: ProtoField(4, ScalarType.UINT32),
  ipType: ProtoField(5, ScalarType.UINT32)
};
const UploadResp = {
  uKey: ProtoField(1, ScalarType.STRING, true),
  uKeyTtlSecond: ProtoField(2, ScalarType.UINT32),
  ipv4s: ProtoField(3, () => IPv4, false, true),
  ipv6s: ProtoField(4, () => IPv6, false, true),
  msgSeq: ProtoField(5, ScalarType.UINT64),
  msgInfo: ProtoField(6, () => MsgInfo),
  ext: ProtoField(7, () => RichMediaStorageTransInfo, false, true),
  compatQMsg: ProtoField(8, ScalarType.BYTES),
  subFileInfos: ProtoField(10, () => SubFileInfo, false, true)
};
const RichMediaStorageTransInfo = {
  subType: ProtoField(1, ScalarType.UINT32),
  extType: ProtoField(2, ScalarType.UINT32),
  extValue: ProtoField(3, ScalarType.BYTES)
};
const SubFileInfo = {
  subType: ProtoField(1, ScalarType.UINT32),
  uKey: ProtoField(2, ScalarType.STRING),
  uKeyTtlSecond: ProtoField(3, ScalarType.UINT32),
  ipv4s: ProtoField(4, () => IPv4, false, true),
  ipv6s: ProtoField(5, () => IPv6, false, true)
};
const DownloadSafeResp = {};
const UploadKeyRenewalResp = {
  ukey: ProtoField(1, ScalarType.STRING),
  ukeyTtlSec: ProtoField(2, ScalarType.UINT64)
};
const MsgInfoAuthResp = {
  authCode: ProtoField(1, ScalarType.UINT32),
  msg: ProtoField(2, ScalarType.BYTES),
  resultTime: ProtoField(3, ScalarType.UINT64)
};
const UploadCompletedResp = {
  msgSeq: ProtoField(1, ScalarType.UINT64)
};
const DeleteResp = {};
const DownloadRKeyResp = {
  rKeys: ProtoField(1, () => RKeyInfo, false, true)
};
const RKeyInfo = {
  rkey: ProtoField(1, ScalarType.STRING),
  rkeyTtlSec: ProtoField(2, ScalarType.UINT64),
  storeId: ProtoField(3, ScalarType.UINT32),
  rkeyCreateTime: ProtoField(4, ScalarType.UINT32, true),
  type: ProtoField(5, ScalarType.UINT32, true)
};

const OidbSvcTrpcTcpBase = {
  command: ProtoField(1, ScalarType.UINT32),
  subCommand: ProtoField(2, ScalarType.UINT32),
  body: ProtoField(4, ScalarType.BYTES),
  errorMsg: ProtoField(5, ScalarType.STRING, true),
  isReserved: ProtoField(12, ScalarType.UINT32)
};
const OidbSvcTrpcTcpBaseRsp = {
  body: ProtoField(4, ScalarType.BYTES)
};

const int32ip2str = (ip) => {
  ip = ip & 4294967295;
  return [ip & 255, (ip & 65280) >> 8, (ip & 16711680) >> 16, (ip & 4278190080) >> 24 & 255].join(".");
};
const oidbIpv4s2HighwayIpv4s = (ipv4s) => {
  return ipv4s.map((ip) => {
    return {
      domain: {
        isEnable: true,
        ip: int32ip2str(ip.outIP)
      },
      port: ip.outPort
    };
  });
};

class Sha1Stream {
  Sha1BlockSize = 64;
  Sha1DigestSize = 20;
  _padding = Buffer.concat([Buffer.from([128]), Buffer.alloc(63)]);
  _state = new Uint32Array(5);
  _count = new Uint32Array(2);
  _buffer = Buffer.allocUnsafe(this.Sha1BlockSize);
  _w = new Uint32Array(80);
  constructor() {
    this.reset();
  }
  reset() {
    this._state[0] = 1732584193;
    this._state[1] = 4023233417;
    this._state[2] = 2562383102;
    this._state[3] = 271733878;
    this._state[4] = 3285377520;
    this._count[0] = 0;
    this._count[1] = 0;
    this._buffer.fill(0);
  }
  rotateLeft(v, o) {
    return (v << o | v >>> 32 - o) >>> 0;
  }
  transform(chunk, offset) {
    const w = this._w;
    const view = new DataView(chunk.buffer, chunk.byteOffset + offset, 64);
    for (let i = 0; i < 16; i++) {
      w[i] = view.getUint32(i * 4, false);
    }
    for (let i = 16; i < 80; i++) {
      w[i] = this.rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1) >>> 0;
    }
    let a = this._state[0];
    let b = this._state[1];
    let c = this._state[2];
    let d = this._state[3];
    let e = this._state[4];
    for (let i = 0; i < 80; i++) {
      const [f, k] = i < 20 ? [b & c | ~b & d, 1518500249] : i < 40 ? [b ^ c ^ d, 1859775393] : i < 60 ? [b & c | b & d | c & d, 2400959708] : [b ^ c ^ d, 3395469782];
      const temp = this.rotateLeft(a, 5) + f + k + e + w[i] >>> 0;
      e = d;
      d = c;
      c = this.rotateLeft(b, 30) >>> 0;
      b = a;
      a = temp;
    }
    this._state[0] = this._state[0] + a >>> 0;
    this._state[1] = this._state[1] + b >>> 0;
    this._state[2] = this._state[2] + c >>> 0;
    this._state[3] = this._state[3] + d >>> 0;
    this._state[4] = this._state[4] + e >>> 0;
  }
  update(data, len) {
    let index = (this._count[0] >>> 3 & 63) >>> 0;
    const dataLen = len ?? data.length;
    this._count[0] = this._count[0] + (dataLen << 3) >>> 0;
    if (this._count[0] < dataLen << 3) this._count[1] = this._count[1] + 1 >>> 0;
    this._count[1] = this._count[1] + (dataLen >>> 29) >>> 0;
    const partLen = this.Sha1BlockSize - index >>> 0;
    let i = 0;
    if (dataLen >= partLen) {
      data.copy(this._buffer, index, 0, partLen);
      this.transform(this._buffer, 0);
      for (i = partLen; i + this.Sha1BlockSize <= dataLen; i = i + this.Sha1BlockSize >>> 0) {
        this.transform(data, i);
      }
      index = 0;
    }
    data.copy(this._buffer, index, i, dataLen);
  }
  hash(bigEndian = true) {
    const digest = Buffer.allocUnsafe(this.Sha1DigestSize);
    if (bigEndian) {
      for (let i = 0; i < 5; i++) digest.writeUInt32BE(this._state[i], i * 4);
    } else {
      for (let i = 0; i < 5; i++) digest.writeUInt32LE(this._state[i], i * 4);
    }
    return digest;
  }
  final() {
    const digest = Buffer.allocUnsafe(this.Sha1DigestSize);
    const bits = Buffer.allocUnsafe(8);
    bits.writeUInt32BE(this._count[1], 0);
    bits.writeUInt32BE(this._count[0], 4);
    const index = (this._count[0] >>> 3 & 63) >>> 0;
    const padLen = (index < 56 ? 56 - index : 120 - index) >>> 0;
    this.update(this._padding, padLen);
    this.update(bits);
    for (let i = 0; i < 5; i++) {
      digest.writeUInt32BE(this._state[i], i * 4);
    }
    return digest;
  }
}

class CalculateStreamBytesTransform extends stream.Transform {
  blockSize = 1024 * 1024;
  sha1;
  buffer;
  bytesRead;
  byteArrayList;
  constructor() {
    super();
    this.sha1 = new Sha1Stream();
    this.buffer = Buffer.alloc(0);
    this.bytesRead = 0;
    this.byteArrayList = [];
  }
  _transform(chunk, _, callback) {
    try {
      this.buffer = Buffer.concat([this.buffer, chunk]);
      let offset = 0;
      while (this.buffer.length - offset >= this.sha1.Sha1BlockSize) {
        const block = this.buffer.subarray(offset, offset + this.sha1.Sha1BlockSize);
        this.sha1.update(block);
        offset += this.sha1.Sha1BlockSize;
        this.bytesRead += this.sha1.Sha1BlockSize;
        if (this.bytesRead % this.blockSize === 0) {
          const digest = this.sha1.hash(false);
          this.byteArrayList.push(Buffer.from(digest));
        }
      }
      this.buffer = this.buffer.subarray(offset);
      callback(null);
    } catch (err) {
      callback(err);
    }
  }
  _flush(callback) {
    try {
      if (this.buffer.length > 0) this.sha1.update(this.buffer);
      const finalDigest = this.sha1.final();
      this.byteArrayList.push(Buffer.from(finalDigest));
      for (const digest of this.byteArrayList) {
        this.push(digest);
      }
      callback(null);
    } catch (err) {
      callback(err);
    }
  }
}

function sha1Stream(readable) {
  return new Promise((resolve, reject) => {
    readable.on("error", reject);
    readable.pipe(crypto$1.createHash("sha1").on("error", reject).on("data", resolve));
  });
}
function md5Stream(readable) {
  return new Promise((resolve, reject) => {
    readable.on("error", reject);
    readable.pipe(crypto$1.createHash("md5").on("error", reject).on("data", resolve));
  });
}
function calculateSha1(filePath) {
  const readable = fs$2.createReadStream(filePath);
  return sha1Stream(readable);
}
function computeMd5AndLengthWithLimit(filePath, limit) {
  const readStream = fs$2.createReadStream(filePath, limit ? { start: 0, end: limit - 1 } : {});
  return md5Stream(readStream);
}
function calculateSha1StreamBytes(filePath) {
  return new Promise((resolve, reject) => {
    const readable = fs$2.createReadStream(filePath);
    const calculateStreamBytes = new CalculateStreamBytesTransform();
    const byteArrayList = [];
    calculateStreamBytes.on("data", (chunk) => {
      byteArrayList.push(chunk);
    });
    calculateStreamBytes.on("end", () => {
      resolve(byteArrayList);
    });
    calculateStreamBytes.on("error", (err) => {
      reject(err);
    });
    readable.pipe(calculateStreamBytes);
  });
}

const OidbSvcTrpcTcp0x6D6 = {
  file: ProtoField(1, () => OidbSvcTrpcTcp0x6D6Upload, true),
  download: ProtoField(3, () => OidbSvcTrpcTcp0x6D6Download, true),
  delete: ProtoField(4, () => OidbSvcTrpcTcp0x6D6Delete, true),
  rename: ProtoField(5, () => OidbSvcTrpcTcp0x6D6Rename, true),
  move: ProtoField(6, () => OidbSvcTrpcTcp0x6D6Move, true)
};
const OidbSvcTrpcTcp0x6D6Upload = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  entrance: ProtoField(4, ScalarType.UINT32),
  targetDirectory: ProtoField(5, ScalarType.STRING),
  fileName: ProtoField(6, ScalarType.STRING),
  localDirectory: ProtoField(7, ScalarType.STRING),
  fileSize: ProtoField(8, ScalarType.UINT64),
  fileSha1: ProtoField(9, ScalarType.BYTES),
  fileSha3: ProtoField(10, ScalarType.BYTES),
  fileMd5: ProtoField(11, ScalarType.BYTES),
  field15: ProtoField(15, ScalarType.BOOL)
};
const OidbSvcTrpcTcp0x6D6Download = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Delete = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(5, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Rename = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING),
  parentFolder: ProtoField(5, ScalarType.STRING),
  newFileName: ProtoField(6, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Move = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  appId: ProtoField(2, ScalarType.UINT32),
  busId: ProtoField(3, ScalarType.UINT32),
  fileId: ProtoField(4, ScalarType.STRING),
  parentDirectory: ProtoField(5, ScalarType.STRING),
  targetDirectory: ProtoField(6, ScalarType.STRING)
};
const OidbSvcTrpcTcp0x6D6Response = {
  upload: ProtoField(1, () => OidbSvcTrpcTcp0x6D6_0Response),
  download: ProtoField(3, () => OidbSvcTrpcTcp0x6D6_2Response),
  delete: ProtoField(4, () => OidbSvcTrpcTcp0x6D6_3_4_5Response),
  rename: ProtoField(5, () => OidbSvcTrpcTcp0x6D6_3_4_5Response),
  move: ProtoField(6, () => OidbSvcTrpcTcp0x6D6_3_4_5Response)
};
const OidbSvcTrpcTcp0x6D6_0Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING),
  uploadIp: ProtoField(4, ScalarType.STRING),
  serverDns: ProtoField(5, ScalarType.STRING),
  busId: ProtoField(6, ScalarType.INT32),
  fileId: ProtoField(7, ScalarType.STRING),
  checkKey: ProtoField(8, ScalarType.BYTES),
  fileKey: ProtoField(9, ScalarType.BYTES),
  boolFileExist: ProtoField(10, ScalarType.BOOL),
  uploadIpLanV4: ProtoField(12, ScalarType.STRING, false, true),
  uploadIpLanV6: ProtoField(13, ScalarType.STRING, false, true),
  uploadPort: ProtoField(14, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0x6D6_2Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING),
  downloadIp: ProtoField(4, ScalarType.STRING),
  downloadDns: ProtoField(5, ScalarType.STRING),
  downloadUrl: ProtoField(6, ScalarType.BYTES),
  fileSha1: ProtoField(7, ScalarType.BYTES),
  fileSha3: ProtoField(8, ScalarType.BYTES),
  fileMd5: ProtoField(9, ScalarType.BYTES),
  cookieVal: ProtoField(10, ScalarType.BYTES),
  saveFileName: ProtoField(11, ScalarType.STRING),
  previewPort: ProtoField(12, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0x6D6_3_4_5Response = {
  retCode: ProtoField(1, ScalarType.INT32),
  retMsg: ProtoField(2, ScalarType.STRING),
  clientWording: ProtoField(3, ScalarType.STRING)
};

const OidbSvcTrpcTcp0XE37_1200 = {
  subCommand: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.INT32, true),
  body: ProtoField(14, () => OidbSvcTrpcTcp0XE37_1200Body, true),
  field101: ProtoField(101, ScalarType.INT32, true),
  field102: ProtoField(102, ScalarType.INT32, true),
  field200: ProtoField(200, ScalarType.INT32, true),
  field99999: ProtoField(99999, ScalarType.BYTES, true)
};
const OidbSvcTrpcTcp0XE37_1200Body = {
  receiverUid: ProtoField(10, ScalarType.STRING, true),
  fileUuid: ProtoField(20, ScalarType.STRING, true),
  type: ProtoField(30, ScalarType.INT32, true),
  fileHash: ProtoField(60, ScalarType.STRING, true),
  t2: ProtoField(601, ScalarType.INT32, true)
};
({
  command: ProtoField(1, ScalarType.UINT32, true),
  subCommand: ProtoField(2, ScalarType.UINT32, true),
  body: ProtoField(14, () => OidbSvcTrpcTcp0XE37_1200ResponseBody, true),
  field50: ProtoField(50, ScalarType.UINT32, true)
});
const OidbSvcTrpcTcp0XE37_1200ResponseBody = {
  field10: ProtoField(10, ScalarType.UINT32, true),
  state: ProtoField(20, ScalarType.STRING, true),
  result: ProtoField(30, () => OidbSvcTrpcTcp0XE37_1200Result, true),
  metadata: ProtoField(40, () => OidbSvcTrpcTcp0XE37_800_1200Metadata, true)
};
const OidbSvcTrpcTcp0XE37_1200Result = {
  server: ProtoField(20, ScalarType.STRING, true),
  port: ProtoField(40, ScalarType.UINT32, true),
  url: ProtoField(50, ScalarType.STRING, true),
  additionalServer: ProtoField(60, ScalarType.STRING, false, true),
  ssoPort: ProtoField(80, ScalarType.UINT32, true),
  ssoUrl: ProtoField(90, ScalarType.STRING, true),
  extra: ProtoField(120, ScalarType.BYTES, true)
};
const OidbSvcTrpcTcp0XE37_800_1200Metadata = {
  uin: ProtoField(1, ScalarType.UINT32, true),
  field2: ProtoField(2, ScalarType.UINT32, true),
  field3: ProtoField(3, ScalarType.UINT32, true),
  size: ProtoField(4, ScalarType.UINT32, true),
  timestamp: ProtoField(5, ScalarType.UINT32, true),
  fileUuid: ProtoField(6, ScalarType.STRING, true),
  fileName: ProtoField(7, ScalarType.STRING, true),
  field100: ProtoField(100, ScalarType.BYTES, true),
  field101: ProtoField(101, ScalarType.BYTES, true),
  field110: ProtoField(110, ScalarType.UINT32, true),
  timestamp1: ProtoField(130, ScalarType.UINT32, true),
  fileHash: ProtoField(140, ScalarType.STRING, true),
  field141: ProtoField(141, ScalarType.BYTES, true),
  field142: ProtoField(142, ScalarType.BYTES, true)
};

const OidbSvcTrpcTcp0XE37_800 = {
  subCommand: ProtoField(1, ScalarType.UINT32),
  field2: ProtoField(2, ScalarType.INT32),
  body: ProtoField(10, () => OidbSvcTrpcTcp0XE37_800Body, true),
  field101: ProtoField(101, ScalarType.INT32),
  field102: ProtoField(102, ScalarType.INT32),
  field200: ProtoField(200, ScalarType.INT32)
};
const OidbSvcTrpcTcp0XE37_800Body = {
  senderUid: ProtoField(10, ScalarType.STRING, true),
  receiverUid: ProtoField(20, ScalarType.STRING, true),
  fileUuid: ProtoField(30, ScalarType.STRING, true),
  fileHash: ProtoField(40, ScalarType.STRING, true)
};
const OidbSvcTrpcTcp0XE37Response = {
  command: ProtoField(1, ScalarType.UINT32),
  seq: ProtoField(2, ScalarType.INT32),
  upload: ProtoField(19, () => ApplyUploadRespV3, true),
  businessId: ProtoField(101, ScalarType.INT32),
  clientType: ProtoField(102, ScalarType.INT32),
  flagSupportMediaPlatform: ProtoField(200, ScalarType.INT32)
};
const ApplyUploadRespV3 = {
  retCode: ProtoField(10, ScalarType.INT32),
  retMsg: ProtoField(20, ScalarType.STRING, true),
  totalSpace: ProtoField(30, ScalarType.INT64),
  usedSpace: ProtoField(40, ScalarType.INT64),
  uploadedSize: ProtoField(50, ScalarType.INT64),
  uploadIp: ProtoField(60, ScalarType.STRING, true),
  uploadDomain: ProtoField(70, ScalarType.STRING, true),
  uploadPort: ProtoField(80, ScalarType.UINT32),
  uuid: ProtoField(90, ScalarType.STRING, true),
  uploadKey: ProtoField(100, ScalarType.BYTES, true),
  boolFileExist: ProtoField(110, ScalarType.BOOL),
  packSize: ProtoField(120, ScalarType.INT32),
  uploadIpList: ProtoField(130, ScalarType.STRING, false, true),
  // repeated
  uploadHttpsPort: ProtoField(140, ScalarType.INT32),
  uploadHttpsDomain: ProtoField(150, ScalarType.STRING, true),
  uploadDns: ProtoField(160, ScalarType.STRING, true),
  uploadLanip: ProtoField(170, ScalarType.STRING, true),
  fileAddon: ProtoField(200, ScalarType.STRING, true),
  mediaPlatformUploadKey: ProtoField(220, ScalarType.BYTES, true)
};
const OidbSvcTrpcTcp0XE37_800Response = {
  command: ProtoField(1, ScalarType.UINT32, true),
  subCommand: ProtoField(2, ScalarType.UINT32, true),
  body: ProtoField(10, () => OidbSvcTrpcTcp0XE37_800ResponseBody, true),
  field50: ProtoField(50, ScalarType.UINT32, true)
};
const OidbSvcTrpcTcp0XE37_800ResponseBody = {
  field10: ProtoField(10, ScalarType.UINT32, true),
  field30: ProtoField(30, () => OidbSvcTrpcTcp0XE37_800_1200Metadata, true)
};

const BlockSize = 1024 * 1024;
class PacketHighwaySession {
  packetClient;
  packetHighwayClient;
  sig;
  logger;
  packer;
  cachedPrepareReq = null;
  constructor(logger, client, packer) {
    this.packetClient = client;
    this.logger = logger;
    this.sig = {
      uin: this.packetClient.napCatCore.selfInfo.uin,
      uid: this.packetClient.napCatCore.selfInfo.uid,
      sigSession: null,
      sessionKey: null,
      serverAddr: []
    };
    this.packer = packer;
    this.packetHighwayClient = new PacketHighwayClient(this.sig, this.logger);
  }
  async checkAvailable() {
    if (!this.packetClient.available) {
      throw new Error("packetServer不可用，请参照文档 https://napneko.github.io/config/advanced 检查packetServer状态或进行配置");
    }
    if (this.sig.sigSession === null || this.sig.sessionKey === null) {
      this.logger.logWarn("[Highway] sigSession or sessionKey not available!");
      if (this.cachedPrepareReq === null) {
        this.cachedPrepareReq = this.prepareUpload().finally(() => {
          this.cachedPrepareReq = null;
        });
      }
      await this.cachedPrepareReq;
    }
  }
  async prepareUpload() {
    const packet = this.packer.packHttp0x6ff_501();
    const req = await this.packetClient.sendPacket("HttpConn.0x6ff_501", packet, true);
    const rsp = new NapProtoMsg(HttpConn0x6ff_501Response).decode(
      Buffer.from(req.hex_data, "hex")
    );
    this.sig.sigSession = rsp.httpConn.sigSession;
    this.sig.sessionKey = rsp.httpConn.sessionKey;
    for (const info of rsp.httpConn.serverInfos) {
      if (info.serviceType !== 1) continue;
      for (const addr of info.serverAddrs) {
        this.logger.logDebug(`[Highway PrepareUpload] server addr add: ${int32ip2str(addr.ip)}:${addr.port}`);
        this.sig.serverAddr.push({
          ip: int32ip2str(addr.ip),
          port: addr.port
        });
      }
    }
  }
  async uploadImage(peer, img) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupImageReq(+peer.peerUid, img);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CImageReq(peer.peerUid, img);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadVideo(peer, video) {
    await this.checkAvailable();
    if (+(video.fileSize ?? 0) > 1024 * 1024 * 100) {
      throw new Error(`[Highway] 视频文件过大: ${(+(video.fileSize ?? 0) / (1024 * 1024)).toFixed(2)} MB > 100 MB，请使用文件上传！`);
    }
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupVideoReq(+peer.peerUid, video);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CVideoReq(peer.peerUid, video);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadPtt(peer, ptt) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupPttReq(+peer.peerUid, ptt);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CPttReq(peer.peerUid, ptt);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadFile(peer, file) {
    await this.checkAvailable();
    if (peer.chatType === ChatType.KCHATTYPEGROUP) {
      await this.uploadGroupFileReq(+peer.peerUid, file);
    } else if (peer.chatType === ChatType.KCHATTYPEC2C) {
      await this.uploadC2CFileReq(peer.peerUid, file);
    } else {
      throw new Error(`[Highway] unsupported chatType: ${peer.chatType}`);
    }
  }
  async uploadGroupImageReq(groupUin, img) {
    img.sha1 = Buffer.from(await calculateSha1(img.path)).toString("hex");
    const preReq = await this.packer.packUploadGroupImgReq(groupUin, img);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadGroupImageReq get upload ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1004,
        fs$3.createReadStream(img.path, { highWaterMark: BlockSize }),
        img.size,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadGroupImageReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    img.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CImageReq(peerUid, img) {
    img.sha1 = Buffer.from(await calculateSha1(img.path)).toString("hex");
    const preReq = await this.packer.packUploadC2CImgReq(peerUid, img);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadC2CImageReq get upload ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1003,
        fs$3.createReadStream(img.path, { highWaterMark: BlockSize }),
        img.size,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadC2CImageReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    img.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupVideoReq(groupUin, video) {
    if (!video.filePath || !video.thumbPath) throw new Error("video.filePath or video.thumbPath is empty");
    video.fileSha1 = Buffer.from(await calculateSha1(video.filePath)).toString("hex");
    video.thumbSha1 = Buffer.from(await calculateSha1(video.thumbPath)).toString("hex");
    const preReq = await this.packer.packUploadGroupVideoReq(groupUin, video);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadGroupVideoReq get upload video ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: await calculateSha1StreamBytes(video.filePath)
        }
      });
      await this.packetHighwayClient.upload(
        1005,
        fs$3.createReadStream(video.filePath, { highWaterMark: BlockSize }),
        +video.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadGroupVideoReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    const subFile = preRespData.upload.subFileInfos[0];
    if (subFile.uKey && subFile.uKey != "") {
      this.logger.logDebug(`[Highway] uploadGroupVideoReq get upload video thumb ukey: ${subFile.uKey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[1].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: subFile.uKey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(subFile.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1006,
        fs$3.createReadStream(video.thumbPath, { highWaterMark: BlockSize }),
        +video.thumbSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadGroupVideoReq get upload invalid thumb ukey ${subFile.uKey}, don't need upload!`);
    }
    video.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CVideoReq(peerUid, video) {
    if (!video.filePath || !video.thumbPath) throw new Error("video.filePath or video.thumbPath is empty");
    video.fileSha1 = Buffer.from(await calculateSha1(video.filePath)).toString("hex");
    video.thumbSha1 = Buffer.from(await calculateSha1(video.thumbPath)).toString("hex");
    const preReq = await this.packer.packUploadC2CVideoReq(peerUid, video);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadC2CVideoReq get upload video ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: await calculateSha1StreamBytes(video.filePath)
        }
      });
      await this.packetHighwayClient.upload(
        1001,
        fs$3.createReadStream(video.filePath, { highWaterMark: BlockSize }),
        +video.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadC2CVideoReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    const subFile = preRespData.upload.subFileInfos[0];
    if (subFile.uKey && subFile.uKey != "") {
      this.logger.logDebug(`[Highway] uploadC2CVideoReq get upload video thumb ukey: ${subFile.uKey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[1].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: subFile.uKey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(subFile.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1002,
        fs$3.createReadStream(video.thumbPath, { highWaterMark: BlockSize }),
        +video.thumbSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadC2CVideoReq get upload invalid thumb ukey ${subFile.uKey}, don't need upload!`);
    }
    video.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupPttReq(groupUin, ptt) {
    ptt.fileSha1 = Buffer.from(await calculateSha1(ptt.filePath)).toString("hex");
    const preReq = await this.packer.packUploadGroupPttReq(groupUin, ptt);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadGroupPttReq get upload ptt ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1008,
        fs$3.createReadStream(ptt.filePath, { highWaterMark: BlockSize }),
        ptt.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadGroupPttReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    ptt.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadC2CPttReq(peerUid, ptt) {
    ptt.fileSha1 = Buffer.from(await calculateSha1(ptt.filePath)).toString("hex");
    const preReq = await this.packer.packUploadC2CPttReq(peerUid, ptt);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(NTV2RichMediaResp).decode(preResp.body);
    const ukey = preRespData.upload.uKey;
    if (ukey && ukey != "") {
      this.logger.logDebug(`[Highway] uploadC2CPttReq get upload ptt ukey: ${ukey}, need upload!`);
      const index = preRespData.upload.msgInfo.msgInfoBody[0].index;
      const md5 = Buffer.from(index.info.fileHash, "hex");
      const sha1 = Buffer.from(index.info.fileSha1, "hex");
      const extend = new NapProtoMsg(NTV2RichMediaHighwayExt).encode({
        fileUuid: index.fileUuid,
        uKey: ukey,
        network: {
          ipv4S: oidbIpv4s2HighwayIpv4s(preRespData.upload.ipv4S)
        },
        msgInfoBody: preRespData.upload.msgInfo.msgInfoBody,
        blockSize: BlockSize,
        hash: {
          fileSha1: [sha1]
        }
      });
      await this.packetHighwayClient.upload(
        1007,
        fs$3.createReadStream(ptt.filePath, { highWaterMark: BlockSize }),
        ptt.fileSize,
        md5,
        extend
      );
    } else {
      this.logger.logDebug(`[Highway] uploadC2CPttReq get upload invalid ukey ${ukey}, don't need upload!`);
    }
    ptt.msgInfo = preRespData.upload.msgInfo;
  }
  async uploadGroupFileReq(groupUin, file) {
    file.isGroupFile = true;
    file.fileMd5 = await computeMd5AndLengthWithLimit(file.filePath);
    file.fileSha1 = await calculateSha1(file.filePath);
    const preReq = await this.packer.packUploadGroupFileReq(groupUin, file);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(OidbSvcTrpcTcp0x6D6Response).decode(preResp.body);
    if (!preRespData?.upload?.boolFileExist) {
      this.logger.logDebug(`[Highway] uploadGroupFileReq file not exist, need upload!`);
      const ext = new NapProtoMsg(FileUploadExt).encode({
        unknown1: 100,
        unknown2: 1,
        entry: {
          busiBuff: {
            senderUin: BigInt(this.sig.uin),
            receiverUin: BigInt(groupUin),
            groupCode: BigInt(groupUin)
          },
          fileEntry: {
            fileSize: BigInt(file.fileSize),
            md5: file.fileMd5,
            md5S2: file.fileMd5,
            checkKey: preRespData.upload.checkKey,
            fileId: preRespData.upload.fileId,
            uploadKey: preRespData.upload.fileKey
          },
          clientInfo: {
            clientType: 3,
            appId: "100",
            terminalType: 3,
            clientVer: "1.1.1",
            unknown: 4
          },
          fileNameInfo: {
            fileName: file.fileName
          },
          host: {
            hosts: [
              {
                url: {
                  host: preRespData.upload.uploadIp,
                  unknown: 1
                },
                port: preRespData.upload.uploadPort
              }
            ]
          }
        },
        unknown200: 0
      });
      await this.packetHighwayClient.upload(
        71,
        fs$3.createReadStream(file.filePath, { highWaterMark: BlockSize }),
        file.fileSize,
        file.fileMd5,
        ext
      );
    } else {
      this.logger.logDebug(`[Highway] uploadGroupFileReq file exist, don't need upload!`);
    }
    file.fileUuid = preRespData.upload.fileId;
  }
  async uploadC2CFileReq(peerUid, file) {
    file.isGroupFile = false;
    file.fileMd5 = await computeMd5AndLengthWithLimit(file.filePath);
    file.fileSha1 = await calculateSha1(file.filePath);
    const preReq = await this.packer.packUploadC2CFileReq(this.sig.uid, peerUid, file);
    const preRespRaw = await this.packetClient.sendOidbPacket(preReq, true);
    const preResp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(
      Buffer.from(preRespRaw.hex_data, "hex")
    );
    const preRespData = new NapProtoMsg(OidbSvcTrpcTcp0XE37Response).decode(preResp.body);
    if (!preRespData.upload?.boolFileExist) {
      this.logger.logDebug(`[Highway] uploadC2CFileReq file not exist, need upload!`);
      const ext = new NapProtoMsg(FileUploadExt).encode({
        unknown1: 100,
        unknown2: 1,
        entry: {
          busiBuff: {
            senderUin: BigInt(this.sig.uin)
          },
          fileEntry: {
            fileSize: BigInt(file.fileSize),
            md5: file.fileMd5,
            md5S2: file.fileMd5,
            checkKey: file.fileSha1,
            fileId: preRespData.upload?.uuid,
            uploadKey: preRespData.upload?.mediaPlatformUploadKey
          },
          clientInfo: {
            clientType: 3,
            appId: "100",
            terminalType: 3,
            clientVer: "1.1.1",
            unknown: 4
          },
          fileNameInfo: {
            fileName: file.fileName
          },
          host: {
            hosts: [
              {
                url: {
                  host: preRespData.upload?.uploadIp,
                  unknown: 1
                },
                port: preRespData.upload?.uploadPort
              }
            ]
          }
        },
        unknown200: 1,
        unknown3: 0
      });
      await this.packetHighwayClient.upload(
        95,
        fs$3.createReadStream(file.filePath, { highWaterMark: BlockSize }),
        file.fileSize,
        file.fileMd5,
        ext
      );
    }
    file.fileUuid = preRespData.upload?.uuid;
    file.fileHash = preRespData.upload?.fileAddon;
    const FetchExistFileReq = this.packer.packOfflineFileDownloadReq(file.fileUuid, file.fileHash, this.sig.uid, peerUid);
    const resp = await this.packetClient.sendOidbPacket(FetchExistFileReq, true);
    const oidb_resp = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(Buffer.from(resp.hex_data, "hex"));
    file._e37_800_rsp = new NapProtoMsg(OidbSvcTrpcTcp0XE37_800Response).decode(oidb_resp.body);
    file._private_send_uid = this.sig.uid;
    file._private_recv_uid = peerUid;
  }
}

const OidbSvcTrpcTcp0X9067_202 = {
  ReqHead: ProtoField(1, () => MultiMediaReqHead),
  DownloadRKeyReq: ProtoField(4, () => OidbSvcTrpcTcp0X9067_202Key)
};
const OidbSvcTrpcTcp0X9067_202Key = {
  key: ProtoField(1, ScalarType.INT32, false, true)
};
const OidbSvcTrpcTcp0X9067_202_RkeyList = {
  rkey: ProtoField(1, ScalarType.STRING),
  ttl: ProtoField(2, ScalarType.UINT64),
  time: ProtoField(4, ScalarType.UINT32),
  type: ProtoField(5, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0X9067_202_Data = {
  rkeyList: ProtoField(1, () => OidbSvcTrpcTcp0X9067_202_RkeyList, false, true)
};
const OidbSvcTrpcTcp0X9067_202_Rsp_Body = {
  data: ProtoField(4, () => OidbSvcTrpcTcp0X9067_202_Data)
};

const OidbSvcTrpcTcp0X8FC_2_Body = {
  targetUid: ProtoField(1, ScalarType.STRING),
  specialTitle: ProtoField(5, ScalarType.STRING),
  expiredTime: ProtoField(6, ScalarType.SINT32),
  uinName: ProtoField(7, ScalarType.STRING),
  targetName: ProtoField(8, ScalarType.STRING)
};
const OidbSvcTrpcTcp0X8FC_2 = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  body: ProtoField(3, ScalarType.BYTES)
};

const OidbSvcTrpcTcp0XFE1_2 = {
  uin: ProtoField(1, ScalarType.UINT32),
  key: ProtoField(3, () => OidbSvcTrpcTcp0XFE1_2Key, false, true)
};
const OidbSvcTrpcTcp0XFE1_2Key = {
  key: ProtoField(1, ScalarType.UINT32)
};
const OidbSvcTrpcTcp0XFE1_2RSP_Status = {
  key: ProtoField(1, ScalarType.UINT32),
  value: ProtoField(2, ScalarType.UINT64)
};
const OidbSvcTrpcTcp0XFE1_2RSP_Data = {
  status: ProtoField(2, () => OidbSvcTrpcTcp0XFE1_2RSP_Status)
};
const OidbSvcTrpcTcp0XFE1_2RSP = {
  data: ProtoField(1, () => OidbSvcTrpcTcp0XFE1_2RSP_Data)
};

const OidbSvcTrpcTcp0XED3_1 = {
  uin: ProtoField(1, ScalarType.UINT32),
  groupUin: ProtoField(2, ScalarType.UINT32),
  friendUin: ProtoField(5, ScalarType.UINT32),
  ext: ProtoField(6, ScalarType.UINT32, true)
};

const LongMsgResult = {
  action: ProtoField(2, () => LongMsgAction)
};
const LongMsgAction = {
  actionCommand: ProtoField(1, ScalarType.STRING),
  actionData: ProtoField(2, () => LongMsgContent)
};
const LongMsgContent = {
  msgBody: ProtoField(1, () => PushMsgBody, false, true)
};
({
  uid: ProtoField(1, () => LongMsgUid, true),
  resId: ProtoField(2, ScalarType.STRING, true),
  acquire: ProtoField(3, ScalarType.BOOL)
});
const LongMsgUid = {
  uid: ProtoField(2, ScalarType.STRING, true)
};
const LongMsgSettings = {
  field1: ProtoField(1, ScalarType.UINT32),
  field2: ProtoField(2, ScalarType.UINT32),
  field3: ProtoField(3, ScalarType.UINT32),
  field4: ProtoField(4, ScalarType.UINT32)
};
({
  resId: ProtoField(3, ScalarType.STRING),
  payload: ProtoField(4, ScalarType.BYTES)
});
const SendLongMsgReq = {
  info: ProtoField(2, () => SendLongMsgInfo),
  settings: ProtoField(15, () => LongMsgSettings)
};
const SendLongMsgInfo = {
  type: ProtoField(1, ScalarType.UINT32),
  uid: ProtoField(2, () => LongMsgUid, true),
  groupUin: ProtoField(3, ScalarType.UINT32, true),
  payload: ProtoField(4, ScalarType.BYTES, true)
};
const SendLongMsgResp = {
  result: ProtoField(2, () => SendLongMsgResult),
  settings: ProtoField(15, () => LongMsgSettings)
};
const SendLongMsgResult = {
  resId: ProtoField(3, ScalarType.STRING)
};
({
  info: ProtoField(1, () => SsoGetGroupMsgInfo),
  direction: ProtoField(2, ScalarType.BOOL)
});
const SsoGetGroupMsgInfo = {
  groupUin: ProtoField(1, ScalarType.UINT32),
  startSequence: ProtoField(2, ScalarType.UINT32),
  endSequence: ProtoField(3, ScalarType.UINT32)
};
({
  groupUin: ProtoField(3, ScalarType.UINT32),
  startSequence: ProtoField(4, ScalarType.UINT32),
  endSequence: ProtoField(5, ScalarType.UINT32),
  messages: ProtoField(6, () => PushMsgBody, false, true)
});
({
  friendUid: ProtoField(1, ScalarType.STRING, true),
  time: ProtoField(2, ScalarType.UINT32),
  random: ProtoField(3, ScalarType.UINT32),
  count: ProtoField(4, ScalarType.UINT32),
  direction: ProtoField(5, ScalarType.BOOL)
});
({
  friendUid: ProtoField(3, ScalarType.STRING),
  timestamp: ProtoField(5, ScalarType.UINT32),
  random: ProtoField(6, ScalarType.UINT32),
  messages: ProtoField(7, () => PushMsgBody, false, true)
});
({
  friendUid: ProtoField(2, ScalarType.STRING, true),
  startSequence: ProtoField(3, ScalarType.UINT32),
  endSequence: ProtoField(4, ScalarType.UINT32)
});
({
  friendUid: ProtoField(4, ScalarType.STRING),
  messages: ProtoField(7, () => PushMsgBody, false, true)
});

class ForwardMsgBuilder {
  static build(resId, msg, source, news, summary, prompt) {
    const id = crypto.randomUUID();
    const isGroupMsg = msg.some((m) => m.isGroupMsg);
    if (!source) {
      source = isGroupMsg ? "群聊的聊天记录" : msg.length ? Array.from(new Set(msg.slice(0, 4).map((m) => m.senderName))).join("和") + "的聊天记录" : "聊天记录";
    }
    if (!news) {
      news = msg.length === 0 ? [{
        text: "Nya~ This message is send from NapCat.Packet!"
      }] : msg.map((m) => ({
        text: `${m.senderName}: ${m.msg?.map((msg2) => msg2.preview).join("")}`
      }));
    }
    if (!summary) {
      summary = `查看${msg.length}条转发消息`;
    }
    if (!prompt) {
      prompt = "[聊天记录]";
    }
    return {
      app: "com.tencent.multimsg",
      config: {
        autosize: 1,
        forward: 1,
        round: 1,
        type: "normal",
        width: 300
      },
      desc: prompt,
      extra: {
        filename: id,
        tsum: msg.length
      },
      meta: {
        detail: {
          news,
          resid: resId,
          source,
          summary,
          uniseq: id
        }
      },
      prompt,
      ver: "0.0.0.5",
      view: "contact"
    };
  }
  static fromResId(resId) {
    return this.build(resId, []);
  }
  static fromPacketMsg(resId, packetMsg, source, news, summary, prompt) {
    return this.build(resId, packetMsg.map((msg) => ({
      senderName: msg.senderName,
      isGroupMsg: msg.groupId !== void 0,
      msg: msg.msg.map((m) => ({
        preview: m.valid ? m.toPreview() : "[该消息类型暂不支持查看]"
      }))
    })), source, news, summary, prompt);
  }
}

class IPacketMsgElement {
  constructor(rawElement) {
  }
  get valid() {
    return true;
  }
  buildContent() {
    return void 0;
  }
  buildElement() {
    return [];
  }
  toPreview() {
    return "[暂不支持该消息类型喵~]";
  }
}
class PacketMsgTextElement extends IPacketMsgElement {
  text;
  constructor(element) {
    super(element);
    this.text = element.textElement.content;
  }
  buildElement() {
    return [{
      text: {
        str: this.text
      }
    }];
  }
  toPreview() {
    return this.text;
  }
}
class PacketMsgAtElement extends PacketMsgTextElement {
  targetUid;
  atAll;
  constructor(element) {
    super(element);
    this.targetUid = element.textElement.atNtUid;
    this.atAll = element.textElement.atType === AtType.atAll;
  }
  buildElement() {
    return [{
      text: {
        str: this.text,
        pbReserve: new NapProtoMsg(MentionExtra).encode(
          {
            type: this.atAll ? 1 : 2,
            uin: 0,
            field5: 0,
            uid: this.targetUid
          }
        )
      }
    }];
  }
}
class PacketMsgReplyElement extends IPacketMsgElement {
  messageId;
  messageSeq;
  messageClientSeq;
  targetUin;
  targetUid;
  time;
  elems;
  constructor(element) {
    super(element);
    this.messageId = BigInt(element.replyElement.replayMsgId ?? 0);
    this.messageSeq = +(element.replyElement.replayMsgSeq ?? 0);
    this.messageClientSeq = +(element.replyElement.replyMsgClientSeq ?? 0);
    this.targetUin = +(element.replyElement.senderUin ?? 0);
    this.targetUid = element.replyElement.senderUidStr ?? "";
    this.time = +(element.replyElement.replyMsgTime ?? 0);
    this.elems = [];
  }
  get isGroupReply() {
    return this.messageClientSeq !== 0;
  }
  buildElement() {
    return [{
      srcMsg: {
        origSeqs: [this.isGroupReply ? this.messageClientSeq : this.messageSeq],
        senderUin: BigInt(this.targetUin),
        time: this.time,
        elems: [],
        // TODO: in replyElement.sourceMsgTextElems
        pbReserve: {
          messageId: this.messageId
        },
        toUin: BigInt(0)
      }
    }, {
      text: this.isGroupReply ? {
        str: "nya~",
        pbReserve: new NapProtoMsg(MentionExtra).encode({
          type: this.targetUin === 0 ? 1 : 2,
          uin: 0,
          field5: 0,
          uid: String(this.targetUid)
        })
      } : void 0
    }];
  }
  toPreview() {
    return "[回复消息]";
  }
}
class PacketMsgFaceElement extends IPacketMsgElement {
  faceId;
  isLargeFace;
  constructor(element) {
    super(element);
    this.faceId = element.faceElement.faceIndex;
    this.isLargeFace = element.faceElement.faceType === 3;
  }
  buildElement() {
    if (this.isLargeFace) {
      return [{
        commonElem: {
          serviceType: 37,
          pbElem: new NapProtoMsg(QBigFaceExtra).encode({
            aniStickerPackId: "1",
            aniStickerId: "8",
            faceId: this.faceId,
            field4: 1,
            field6: "",
            preview: "",
            field9: 1
          }),
          businessType: 1
        }
      }];
    } else if (this.faceId < 260) {
      return [{
        face: {
          index: this.faceId
        }
      }];
    } else {
      return [{
        commonElem: {
          serviceType: 33,
          pbElem: new NapProtoMsg(QSmallFaceExtra).encode({
            faceId: this.faceId,
            preview: "",
            preview2: ""
          }),
          businessType: 1
        }
      }];
    }
  }
  toPreview() {
    return "[表情]";
  }
}
class PacketMsgMarkFaceElement extends IPacketMsgElement {
  emojiName;
  emojiId;
  emojiPackageId;
  emojiKey;
  constructor(element) {
    super(element);
    this.emojiName = element.marketFaceElement.faceName;
    this.emojiId = element.marketFaceElement.emojiId;
    this.emojiPackageId = element.marketFaceElement.emojiPackageId;
    this.emojiKey = element.marketFaceElement.key;
  }
  buildElement() {
    return [{
      marketFace: {
        faceName: this.emojiName,
        itemType: 6,
        faceInfo: 1,
        faceId: Buffer.from(this.emojiId, "hex"),
        tabId: this.emojiPackageId,
        subType: 3,
        key: this.emojiKey,
        imageWidth: 300,
        imageHeight: 300,
        pbReserve: {
          field8: 1
        }
      }
    }];
  }
  toPreview() {
    return `[${this.emojiName}]`;
  }
}
class PacketMsgPicElement extends IPacketMsgElement {
  path;
  name;
  size;
  md5;
  width;
  height;
  picType;
  sha1 = null;
  msgInfo = null;
  groupPicExt = null;
  c2cPicExt = null;
  constructor(element) {
    super(element);
    this.path = element.picElement.sourcePath;
    this.name = element.picElement.fileName;
    this.size = +element.picElement.fileSize;
    this.md5 = element.picElement.md5HexStr ?? "";
    this.width = element.picElement.picWidth;
    this.height = element.picElement.picHeight;
    this.picType = element.picElement.picType;
  }
  get valid() {
    return !!this.msgInfo;
  }
  buildElement() {
    if (!this.msgInfo) return [];
    return [{
      commonElem: {
        serviceType: 48,
        pbElem: new NapProtoMsg(MsgInfo).encode(this.msgInfo),
        businessType: 10
      }
    }];
  }
  toPreview() {
    return "[图片]";
  }
}
class PacketMsgVideoElement extends IPacketMsgElement {
  fileSize;
  filePath;
  thumbSize;
  thumbPath;
  fileMd5;
  fileSha1;
  thumbMd5;
  thumbSha1;
  thumbWidth;
  thumbHeight;
  msgInfo = null;
  constructor(element) {
    super(element);
    this.fileSize = element.videoElement.fileSize;
    this.filePath = element.videoElement.filePath;
    this.thumbSize = element.videoElement.thumbSize;
    this.thumbPath = element.videoElement.thumbPath?.get(0);
    this.fileMd5 = element.videoElement.videoMd5;
    this.thumbMd5 = element.videoElement.thumbMd5;
    this.thumbWidth = element.videoElement.thumbWidth;
    this.thumbHeight = element.videoElement.thumbHeight;
  }
  get valid() {
    return !!this.msgInfo;
  }
  buildElement() {
    if (!this.msgInfo) return [];
    return [{
      commonElem: {
        serviceType: 48,
        pbElem: new NapProtoMsg(MsgInfo).encode(this.msgInfo),
        businessType: 21
      }
    }];
  }
  toPreview() {
    return "[视频]";
  }
}
class PacketMsgPttElement extends IPacketMsgElement {
  filePath;
  fileSize;
  fileMd5;
  fileSha1;
  fileDuration;
  msgInfo = null;
  constructor(element) {
    super(element);
    this.filePath = element.pttElement.filePath;
    this.fileSize = +element.pttElement.fileSize;
    this.fileMd5 = element.pttElement.md5HexStr;
    this.fileDuration = Math.round(element.pttElement.duration);
  }
  get valid() {
    return false;
  }
  buildElement() {
    return [];
  }
  toPreview() {
    return "[语音]";
  }
}
class PacketMsgFileElement extends IPacketMsgElement {
  fileName;
  filePath;
  fileSize;
  fileSha1;
  fileMd5;
  fileUuid;
  fileHash;
  isGroupFile;
  _private_send_uid;
  _private_recv_uid;
  _e37_800_rsp;
  constructor(element) {
    super(element);
    this.fileName = element.fileElement.fileName;
    this.filePath = element.fileElement.filePath;
    this.fileSize = +element.fileElement.fileSize;
  }
  get valid() {
    return this.isGroupFile || Boolean(this._e37_800_rsp);
  }
  buildContent() {
    if (this.isGroupFile || !this._e37_800_rsp) return void 0;
    return new NapProtoMsg(FileExtra).encode({
      file: {
        fileType: 0,
        fileUuid: this.fileUuid,
        fileMd5: this.fileMd5,
        fileName: this.fileName,
        fileSize: BigInt(this.fileSize),
        subcmd: 1,
        dangerEvel: 0,
        expireTime: Math.floor(Date.now() / 1e3) + 7 * 24 * 60 * 60,
        fileHash: this.fileHash
      },
      field6: {
        field2: {
          field1: this._e37_800_rsp?.body?.field30?.field110,
          fileUuid: this.fileUuid,
          fileName: this.fileName,
          field6: this._e37_800_rsp?.body?.field30?.field3,
          field7: this._e37_800_rsp?.body?.field30?.field101,
          field8: this._e37_800_rsp?.body?.field30?.field100,
          timestamp1: this._e37_800_rsp?.body?.field30?.timestamp1,
          fileHash: this.fileHash,
          selfUid: this._private_send_uid,
          destUid: this._private_recv_uid
        }
      }
    });
  }
  buildElement() {
    if (!this.isGroupFile) return [];
    const lb = Buffer.alloc(2);
    const transElemVal = new NapProtoMsg(GroupFileExtra).encode({
      field1: 6,
      fileName: this.fileName,
      inner: {
        info: {
          busId: 102,
          fileId: this.fileUuid,
          fileSize: BigInt(this.fileSize),
          fileName: this.fileName,
          fileSha: this.fileSha1,
          extInfoString: "",
          fileMd5: this.fileMd5
        }
      }
    });
    lb.writeUInt16BE(transElemVal.length);
    return [{
      transElem: {
        elemType: 24,
        elemValue: Buffer.concat([Buffer.from([1]), lb, transElemVal])
        // TLV
      }
    }];
  }
  toPreview() {
    return `[文件]${this.fileName}`;
  }
}
class PacketMsgLightAppElement extends IPacketMsgElement {
  payload;
  constructor(element) {
    super(element);
    this.payload = element.arkElement.bytesData;
  }
  buildElement() {
    return [{
      lightAppElem: {
        data: Buffer.concat([
          Buffer.from([1]),
          zlib.deflateSync(Buffer.from(this.payload, "utf-8"))
        ])
      }
    }];
  }
  toPreview() {
    return "[卡片消息]";
  }
}
class PacketMsgMarkDownElement extends IPacketMsgElement {
  content;
  constructor(element) {
    super(element);
    this.content = element.markdownElement.content;
  }
  buildElement() {
    return [{
      commonElem: {
        serviceType: 45,
        pbElem: new NapProtoMsg(MarkdownData).encode({
          content: this.content
        }),
        businessType: 1
      }
    }];
  }
  toPreview() {
    return `[Markdown消息 ${this.content}]`;
  }
}
class PacketMultiMsgElement extends IPacketMsgElement {
  resid;
  message;
  constructor(rawElement, message) {
    super(rawElement);
    this.resid = rawElement.structLongMsgElement.resId;
    this.message = message ?? [];
  }
  buildElement() {
    return [{
      lightAppElem: {
        data: Buffer.concat([
          Buffer.from([1]),
          zlib.deflateSync(Buffer.from(JSON.stringify(ForwardMsgBuilder.fromPacketMsg(this.resid, this.message)), "utf-8"))
        ])
      }
    }];
  }
  toPreview() {
    return "[聊天记录]";
  }
}

class PacketMsgBuilder {
  logger;
  constructor(logger) {
    this.logger = logger;
  }
  static failBackText = new PacketMsgTextElement(
    {
      textElement: { content: "[该消息类型暂不支持查看]" }
    }
  );
  buildFakeMsg(selfUid, element) {
    return element.map((node) => {
      const avatar = `https://q.qlogo.cn/headimg_dl?dst_uin=${node.senderUin}&spec=640&img_type=jpg`;
      const msgContent = node.msg.reduceRight((acc, msg) => {
        return acc !== void 0 ? acc : msg.buildContent();
      }, void 0);
      const msgElement = node.msg.flatMap((msg) => msg.buildElement() ?? []);
      if (!msgContent && !msgElement.length) {
        this.logger.logWarn(`[PacketMsgBuilder] buildFakeMsg: 空的msgContent和msgElement！`);
        msgElement.push(PacketMsgBuilder.failBackText.buildElement());
      }
      return {
        responseHead: {
          fromUid: "",
          fromUin: node.senderUin,
          toUid: node.groupId ? void 0 : selfUid,
          forward: node.groupId ? void 0 : {
            friendName: node.senderName
          },
          grp: node.groupId ? {
            groupUin: node.groupId,
            memberName: node.senderName,
            unknown5: 2
          } : void 0
        },
        contentHead: {
          type: node.groupId ? 82 : 9,
          subType: node.groupId ? void 0 : 4,
          divSeq: node.groupId ? void 0 : 4,
          msgId: crypto$1.randomBytes(4).readUInt32LE(0),
          sequence: crypto$1.randomBytes(4).readUInt32LE(0),
          timeStamp: +node.time.toString().substring(0, 10),
          field7: BigInt(1),
          field8: 0,
          field9: 0,
          forward: {
            field1: 0,
            field2: 0,
            field3: node.groupId ? 0 : 2,
            unknownBase64: avatar,
            avatar
          }
        },
        body: {
          richText: {
            elems: msgElement
          },
          msgContent
        }
      };
    });
  }
}

const SupportedElementTypes = [
  ElementType.TEXT,
  ElementType.PIC,
  ElementType.REPLY,
  ElementType.FACE,
  ElementType.MFACE,
  ElementType.VIDEO,
  ElementType.FILE,
  ElementType.PTT,
  ElementType.ARK,
  ElementType.MARKDOWN,
  ElementType.STRUCTLONGMSG
];
class PacketMsgConverter {
  logger;
  constructor(logger) {
    this.logger = logger;
  }
  isValidElementType(type) {
    return SupportedElementTypes.includes(type);
  }
  rawMsgWithSendMsgToPacketMsg(msg) {
    return {
      senderUid: msg.senderUid ?? "",
      senderUin: msg.senderUin,
      senderName: msg.senderName,
      groupId: msg.groupId,
      time: msg.time,
      msg: msg.msg.map((element) => {
        if (!this.isValidElementType(element.elementType)) return null;
        return this.rawToPacketMsgConverters[element.elementType](element);
      }).filter((e) => e !== null)
    };
  }
  rawMsgToPacketMsg(msg, ctxPeer) {
    return {
      seq: +msg.msgSeq,
      groupId: ctxPeer.chatType === ChatType.KCHATTYPEGROUP ? +msg.peerUid : void 0,
      senderUid: msg.senderUid,
      senderUin: +msg.senderUin,
      senderName: msg.sendMemberName && msg.sendMemberName !== "" ? msg.sendMemberName : msg.sendNickName && msg.sendNickName !== "" ? msg.sendNickName : "QQ用户",
      time: +msg.msgTime,
      msg: msg.elements.map((element) => {
        if (!this.isValidElementType(element.elementType)) return null;
        return this.rawToPacketMsgConverters[element.elementType](element);
      }).filter((e) => e !== null)
    };
  }
  rawToPacketMsgConverters = {
    [ElementType.TEXT]: (element) => {
      if (element.textElement?.atType) {
        return new PacketMsgAtElement(element);
      }
      return new PacketMsgTextElement(element);
    },
    [ElementType.PIC]: (element) => {
      return new PacketMsgPicElement(element);
    },
    [ElementType.REPLY]: (element) => {
      return new PacketMsgReplyElement(element);
    },
    [ElementType.FACE]: (element) => {
      return new PacketMsgFaceElement(element);
    },
    [ElementType.MFACE]: (element) => {
      return new PacketMsgMarkFaceElement(element);
    },
    [ElementType.VIDEO]: (element) => {
      return new PacketMsgVideoElement(element);
    },
    [ElementType.FILE]: (element) => {
      return new PacketMsgFileElement(element);
    },
    [ElementType.PTT]: (element) => {
      return new PacketMsgPttElement(element);
    },
    [ElementType.ARK]: (element) => {
      return new PacketMsgLightAppElement(element);
    },
    [ElementType.MARKDOWN]: (element) => {
      return new PacketMsgMarkDownElement(element);
    },
    // TODO: check this logic, move it in arkElement?
    [ElementType.STRUCTLONGMSG]: (element) => {
      return new PacketMultiMsgElement(element);
    }
  };
}

const OidbSvcTrpcTcp0XE37_1700 = {
  command: ProtoField(1, ScalarType.UINT32, true),
  seq: ProtoField(2, ScalarType.INT32, true),
  upload: ProtoField(19, () => ApplyUploadReqV3, true),
  businessId: ProtoField(101, ScalarType.INT32, true),
  clientType: ProtoField(102, ScalarType.INT32, true),
  flagSupportMediaPlatform: ProtoField(200, ScalarType.INT32, true)
};
const ApplyUploadReqV3 = {
  senderUid: ProtoField(10, ScalarType.STRING, true),
  receiverUid: ProtoField(20, ScalarType.STRING, true),
  fileSize: ProtoField(30, ScalarType.UINT32, true),
  fileName: ProtoField(40, ScalarType.STRING, true),
  md510MCheckSum: ProtoField(50, ScalarType.BYTES, true),
  sha1CheckSum: ProtoField(60, ScalarType.BYTES, true),
  localPath: ProtoField(70, ScalarType.STRING, true),
  md5CheckSum: ProtoField(110, ScalarType.BYTES, true),
  sha3CheckSum: ProtoField(120, ScalarType.BYTES, true)
};

const OidbSvcTrpcTcp0XEB7_Body = {
  uin: ProtoField(1, ScalarType.STRING),
  groupUin: ProtoField(2, ScalarType.STRING),
  version: ProtoField(3, ScalarType.STRING)
};
const OidbSvcTrpcTcp0XEB7 = {
  body: ProtoField(2, () => OidbSvcTrpcTcp0XEB7_Body)
};

class PacketPacker {
  logger;
  client;
  packetBuilder;
  packetConverter;
  constructor(logger, client) {
    this.logger = logger;
    this.client = client;
    this.packetBuilder = new PacketMsgBuilder(logger);
    this.packetConverter = new PacketMsgConverter(logger);
  }
  packetPacket(byteArray) {
    return Buffer.from(byteArray).toString("hex");
  }
  packOidbPacket(cmd, subCmd, body, isUid = true, isLafter = false) {
    const data = new NapProtoMsg(OidbSvcTrpcTcpBase).encode({
      command: cmd,
      subCommand: subCmd,
      body,
      isReserved: isUid ? 1 : 0
    });
    return {
      cmd: `OidbSvcTrpcTcp.0x${cmd.toString(16).toUpperCase()}_${subCmd}`,
      data: this.packetPacket(data)
    };
  }
  packPokePacket(peer, group) {
    const oidb_0xed3 = new NapProtoMsg(OidbSvcTrpcTcp0XED3_1).encode({
      uin: peer,
      groupUin: group,
      friendUin: group ?? peer,
      ext: 0
    });
    return this.packOidbPacket(3795, 1, oidb_0xed3);
  }
  packRkeyPacket() {
    const oidb_0x9067_202 = new NapProtoMsg(OidbSvcTrpcTcp0X9067_202).encode({
      reqHead: {
        common: {
          requestId: 1,
          command: 202
        },
        scene: {
          requestType: 2,
          businessType: 1,
          sceneType: 0
        },
        client: {
          agentType: 2
        }
      },
      downloadRKeyReq: {
        key: [10, 20, 2]
      }
    });
    return this.packOidbPacket(36967, 202, oidb_0x9067_202);
  }
  packSetSpecialTittlePacket(groupCode, uid, tittle) {
    const oidb_0x8FC_2_body = new NapProtoMsg(OidbSvcTrpcTcp0X8FC_2_Body).encode({
      targetUid: uid,
      specialTitle: tittle,
      expiredTime: -1,
      uinName: tittle
    });
    const oidb_0x8FC_2 = new NapProtoMsg(OidbSvcTrpcTcp0X8FC_2).encode({
      groupUin: +groupCode,
      body: oidb_0x8FC_2_body
    });
    return this.packOidbPacket(2300, 2, oidb_0x8FC_2, false, false);
  }
  packStatusPacket(uin) {
    const oidb_0xfe1_2 = new NapProtoMsg(OidbSvcTrpcTcp0XFE1_2).encode({
      uin,
      key: [{ key: 27372 }]
    });
    return this.packOidbPacket(4065, 2, oidb_0xfe1_2);
  }
  async packUploadForwardMsg(selfUid, msg, groupUin = 0) {
    const msgBody = this.packetBuilder.buildFakeMsg(selfUid, msg);
    const longMsgResultData = new NapProtoMsg(LongMsgResult).encode(
      {
        action: {
          actionCommand: "MultiMsg",
          actionData: {
            msgBody
          }
        }
      }
    );
    const payload = zlib.gzipSync(Buffer.from(longMsgResultData));
    const req = new NapProtoMsg(SendLongMsgReq).encode(
      {
        info: {
          type: groupUin === 0 ? 1 : 3,
          uid: {
            uid: groupUin === 0 ? selfUid : groupUin.toString()
          },
          groupUin,
          payload
        },
        settings: {
          field1: 4,
          field2: 1,
          field3: 7,
          field4: 0
        }
      }
    );
    return this.packetPacket(req);
  }
  // highway part
  packHttp0x6ff_501() {
    return this.packetPacket(new NapProtoMsg(HttpConn0x6ff_501).encode({
      httpConn: {
        field1: 0,
        field2: 0,
        field3: 16,
        field4: 1,
        field6: 3,
        serviceTypes: [1, 5, 10, 21],
        // tgt: "",  // TODO: do we really need tgt? seems not
        field9: 2,
        field10: 9,
        field11: 8,
        ver: "1.0.1"
      }
    }));
  }
  async packUploadGroupImgReq(groupUin, img) {
    const req = new NapProtoMsg(NTV2RichMediaReq).encode(
      {
        reqHead: {
          common: {
            requestId: 1,
            command: 100
          },
          scene: {
            requestType: 2,
            businessType: 1,
            sceneType: 2,
            group: {
              groupUin
            }
          },
          client: {
            agentType: 2
          }
        },
        upload: {
          uploadInfo: [
            {
              fileInfo: {
                fileSize: +img.size,
                fileHash: img.md5,
                fileSha1: img.sha1,
                fileName: img.name,
                type: {
                  type: 1,
                  picFormat: img.picType,
                  //TODO: extend NapCat imgType /cc @MliKiowa
                  videoFormat: 0,
                  voiceFormat: 0
                },
                width: img.width,
                height: img.height,
                time: 0,
                original: 1
              },
              subFileType: 0
            }
          ],
          tryFastUploadCompleted: true,
          srvSendMsg: false,
          clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
          compatQMsgSceneType: 2,
          extBizInfo: {
            pic: {
              bytesPbReserveTroop: Buffer.from("0800180020004200500062009201009a0100a2010c080012001800200028003a00", "hex"),
              textSummary: "Nya~"
              // TODO:
            },
            video: {
              bytesPbReserve: Buffer.alloc(0)
            },
            ptt: {
              bytesPbReserve: Buffer.alloc(0),
              bytesReserve: Buffer.alloc(0),
              bytesGeneralFlags: Buffer.alloc(0)
            }
          },
          clientSeq: 0,
          noNeedCompatMsg: false
        }
      }
    );
    return this.packOidbPacket(4548, 100, req, true, false);
  }
  async packUploadC2CImgReq(peerUin, img) {
    const req = new NapProtoMsg(NTV2RichMediaReq).encode(
      {
        reqHead: {
          common: {
            requestId: 1,
            command: 100
          },
          scene: {
            requestType: 2,
            businessType: 1,
            sceneType: 1,
            c2C: {
              accountType: 2,
              targetUid: peerUin
            }
          },
          client: {
            agentType: 2
          }
        },
        upload: {
          uploadInfo: [
            {
              fileInfo: {
                fileSize: +img.size,
                fileHash: img.md5,
                fileSha1: img.sha1,
                fileName: img.name,
                type: {
                  type: 1,
                  picFormat: img.picType,
                  //TODO: extend NapCat imgType /cc @MliKiowa
                  videoFormat: 0,
                  voiceFormat: 0
                },
                width: img.width,
                height: img.height,
                time: 0,
                original: 1
              },
              subFileType: 0
            }
          ],
          tryFastUploadCompleted: true,
          srvSendMsg: false,
          clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
          compatQMsgSceneType: 1,
          extBizInfo: {
            pic: {
              bytesPbReserveTroop: Buffer.from("0800180020004200500062009201009a0100a2010c080012001800200028003a00", "hex"),
              textSummary: "Nya~"
              // TODO:
            },
            video: {
              bytesPbReserve: Buffer.alloc(0)
            },
            ptt: {
              bytesPbReserve: Buffer.alloc(0),
              bytesReserve: Buffer.alloc(0),
              bytesGeneralFlags: Buffer.alloc(0)
            }
          },
          clientSeq: 0,
          noNeedCompatMsg: false
        }
      }
    );
    return this.packOidbPacket(4549, 100, req, true, false);
  }
  async packUploadGroupVideoReq(groupUin, video) {
    if (!video.fileSize || !video.thumbSize) throw new Error("video.fileSize or video.thumbSize is empty");
    const req = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 3,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 2,
          sceneType: 2,
          group: {
            groupUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: +video.fileSize,
              fileHash: video.fileMd5,
              fileSha1: video.fileSha1,
              fileName: "nya.mp4",
              type: {
                type: 2,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: 0,
              width: 0,
              time: 0,
              original: 0
            },
            subFileType: 0
          },
          {
            fileInfo: {
              fileSize: +video.thumbSize,
              fileHash: video.thumbMd5,
              fileSha1: video.thumbSha1,
              fileName: "nya.jpg",
              type: {
                type: 1,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: video.thumbHeight,
              width: video.thumbWidth,
              time: 0,
              original: 0
            },
            subFileType: 100
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            bizType: 0,
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.from([128, 1, 0])
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.alloc(0),
            bytesGeneralFlags: Buffer.alloc(0)
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return this.packOidbPacket(4586, 100, req, true, false);
  }
  async packUploadC2CVideoReq(peerUin, video) {
    if (!video.fileSize || !video.thumbSize) throw new Error("video.fileSize or video.thumbSize is empty");
    const req = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 3,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 2,
          sceneType: 1,
          c2C: {
            accountType: 2,
            targetUid: peerUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: +video.fileSize,
              fileHash: video.fileMd5,
              fileSha1: video.fileSha1,
              fileName: "nya.mp4",
              type: {
                type: 2,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: 0,
              width: 0,
              time: 0,
              original: 0
            },
            subFileType: 0
          },
          {
            fileInfo: {
              fileSize: +video.thumbSize,
              fileHash: video.thumbMd5,
              fileSha1: video.thumbSha1,
              fileName: "nya.jpg",
              type: {
                type: 1,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 0
              },
              height: video.thumbHeight,
              width: video.thumbWidth,
              time: 0,
              original: 0
            },
            subFileType: 100
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            bizType: 0,
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.from([128, 1, 0])
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.alloc(0),
            bytesGeneralFlags: Buffer.alloc(0)
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return this.packOidbPacket(4585, 100, req, true, false);
  }
  async packUploadGroupPttReq(groupUin, ptt) {
    const req = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 1,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 3,
          sceneType: 2,
          group: {
            groupUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: ptt.fileSize,
              fileHash: ptt.fileMd5,
              fileSha1: ptt.fileSha1,
              fileName: `${ptt.fileMd5}.amr`,
              type: {
                type: 3,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 1
              },
              height: 0,
              width: 0,
              time: ptt.fileDuration,
              original: 0
            },
            subFileType: 0
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 2,
        extBizInfo: {
          pic: {
            textSummary: "Nya~"
          },
          video: {
            bytesPbReserve: Buffer.alloc(0)
          },
          ptt: {
            bytesPbReserve: Buffer.alloc(0),
            bytesReserve: Buffer.from([8, 0, 56, 0]),
            bytesGeneralFlags: Buffer.from([154, 1, 7, 170, 3, 4, 8, 8, 18, 0])
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return this.packOidbPacket(4718, 100, req, true, false);
  }
  async packUploadC2CPttReq(peerUin, ptt) {
    const req = new NapProtoMsg(NTV2RichMediaReq).encode({
      reqHead: {
        common: {
          requestId: 4,
          command: 100
        },
        scene: {
          requestType: 2,
          businessType: 3,
          sceneType: 1,
          c2C: {
            accountType: 2,
            targetUid: peerUin
          }
        },
        client: {
          agentType: 2
        }
      },
      upload: {
        uploadInfo: [
          {
            fileInfo: {
              fileSize: ptt.fileSize,
              fileHash: ptt.fileMd5,
              fileSha1: ptt.fileSha1,
              fileName: `${ptt.fileMd5}.amr`,
              type: {
                type: 3,
                picFormat: 0,
                videoFormat: 0,
                voiceFormat: 1
              },
              height: 0,
              width: 0,
              time: ptt.fileDuration,
              original: 0
            },
            subFileType: 0
          }
        ],
        tryFastUploadCompleted: true,
        srvSendMsg: false,
        clientRandomId: crypto.randomBytes(8).readBigUInt64BE() & BigInt("0x7FFFFFFFFFFFFFFF"),
        compatQMsgSceneType: 1,
        extBizInfo: {
          pic: {
            textSummary: "Nya~"
          },
          ptt: {
            bytesReserve: Buffer.from([8, 0, 56, 0]),
            bytesGeneralFlags: Buffer.from([154, 1, 11, 170, 3, 8, 8, 4, 18, 4, 0, 0, 0, 0])
          }
        },
        clientSeq: 0,
        noNeedCompatMsg: false
      }
    });
    return this.packOidbPacket(4717, 100, req, true, false);
  }
  async packUploadGroupFileReq(groupUin, file) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0x6D6).encode({
      file: {
        groupUin,
        appId: 4,
        busId: 102,
        entrance: 6,
        targetDirectory: "/",
        // TODO:
        fileName: file.fileName,
        localDirectory: `/${file.fileName}`,
        fileSize: BigInt(file.fileSize),
        fileMd5: file.fileMd5,
        fileSha1: file.fileSha1,
        fileSha3: Buffer.alloc(0),
        field15: true
      }
    });
    return this.packOidbPacket(1750, 0, body, true, false);
  }
  async packUploadC2CFileReq(selfUid, peerUid, file) {
    const body = new NapProtoMsg(OidbSvcTrpcTcp0XE37_1700).encode({
      command: 1700,
      seq: 0,
      upload: {
        senderUid: selfUid,
        receiverUid: peerUid,
        fileSize: file.fileSize,
        fileName: file.fileName,
        md510MCheckSum: await computeMd5AndLengthWithLimit(file.filePath, 10 * 1024 * 1024),
        sha1CheckSum: file.fileSha1,
        localPath: "/",
        md5CheckSum: file.fileMd5,
        sha3CheckSum: Buffer.alloc(0)
      },
      businessId: 3,
      clientType: 1,
      flagSupportMediaPlatform: 1
    });
    return this.packOidbPacket(3639, 1700, body, false, false);
  }
  packOfflineFileDownloadReq(fileUUID, fileHash, senderUid, receiverUid) {
    return this.packOidbPacket(3639, 800, new NapProtoMsg(OidbSvcTrpcTcp0XE37_800).encode({
      subCommand: 800,
      field2: 0,
      body: {
        senderUid,
        receiverUid,
        fileUuid: fileUUID,
        fileHash
      },
      field101: 3,
      field102: 1,
      field200: 1
    }), false, false);
  }
  packGroupFileDownloadReq(groupUin, fileUUID) {
    return this.packOidbPacket(
      1750,
      2,
      new NapProtoMsg(OidbSvcTrpcTcp0x6D6).encode({
        download: {
          groupUin,
          appId: 7,
          busId: 102,
          fileId: fileUUID
        }
      }),
      true,
      false
    );
  }
  packC2CFileDownloadReq(selfUid, fileUUID, fileHash) {
    return this.packetPacket(
      new NapProtoMsg(OidbSvcTrpcTcp0XE37_1200).encode({
        subCommand: 1200,
        field2: 1,
        body: {
          receiverUid: selfUid,
          fileUuid: fileUUID,
          type: 2,
          fileHash,
          t2: 0
        },
        field101: 3,
        field102: 103,
        field200: 1,
        field99999: Buffer.from([192, 133, 44, 1])
      })
    );
  }
  packGroupSignReq(uin, groupCode) {
    return this.packOidbPacket(3767, 1, new NapProtoMsg(OidbSvcTrpcTcp0XEB7).encode(
      {
        body: {
          uin,
          groupUin: groupCode,
          version: "9.0.90"
        }
      }
    ), false, false);
  }
}

class PacketSession {
  logger;
  client;
  packer;
  highwaySession;
  constructor(logger, client) {
    this.logger = logger;
    this.client = client;
    this.packer = new PacketPacker(this.logger, this.client);
    this.highwaySession = new PacketHighwaySession(this.logger, this.client, this.packer);
  }
}

class NTQQPacketApi {
  context;
  core;
  logger;
  serverUrl;
  qqVersion;
  packetSession;
  constructor(context, core) {
    this.context = context;
    this.core = core;
    this.logger = core.context.logger;
    this.packetSession = void 0;
    const config = this.core.configLoader.configData;
    if (config && config.packetServer && config.packetServer.length > 0) {
      const serverUrl = this.core.configLoader.configData.packetServer ?? "127.0.0.1:8086";
      this.InitSendPacket(serverUrl, this.context.basicInfoWrapper.getFullQQVesion()).then().catch(this.core.context.logger.logError.bind(this.core.context.logger));
    } else {
      this.core.context.logger.logWarn("PacketServer未配置，NapCat.Packet将不会加载！");
    }
  }
  get available() {
    return this.packetSession?.client.available ?? false;
  }
  async InitSendPacket(serverUrl, qqversion) {
    this.serverUrl = serverUrl;
    this.qqVersion = qqversion;
    const offsetTable = offset;
    const table = offsetTable[qqversion + "-" + os.arch()];
    if (!table) {
      this.logger.logError("PacketServer Offset table not found for QQVersion: ", qqversion + "-" + os.arch());
      return false;
    }
    const url = "ws://" + this.serverUrl + "/ws";
    this.packetSession = new PacketSession(this.core.context.logger, new PacketClient(url, this.core));
    const cb = () => {
      if (this.packetSession && this.packetSession.client) {
        this.packetSession.client.init(process.pid, table.recv, table.send).then().catch(this.logger.logError.bind(this.logger));
      }
    };
    await this.packetSession.client.connect(cb);
    return true;
  }
  async sendPacket(cmd, data, rsp = false) {
    return this.packetSession.client.sendPacket(cmd, data, rsp);
  }
  async sendOidbPacket(pkt, rsp = false) {
    return this.sendPacket(pkt.cmd, pkt.data, rsp);
  }
  async sendPokePacket(peer, group) {
    const data = this.packetSession?.packer.packPokePacket(peer, group);
    await this.sendOidbPacket(data, false);
  }
  async sendRkeyPacket() {
    const packet = this.packetSession?.packer.packRkeyPacket();
    const ret = await this.sendOidbPacket(packet, true);
    if (!ret?.hex_data) return [];
    const body = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(Buffer.from(ret.hex_data, "hex")).body;
    const retData = new NapProtoMsg(OidbSvcTrpcTcp0X9067_202_Rsp_Body).decode(body);
    return retData.data.rkeyList;
  }
  async sendGroupSignPacket(groupCode) {
    const packet = this.packetSession?.packer.packGroupSignReq(this.core.selfInfo.uin, groupCode);
    await this.sendOidbPacket(packet, true);
  }
  async sendStatusPacket(uin) {
    let status = 0;
    try {
      const packet = this.packetSession?.packer.packStatusPacket(uin);
      const ret = await this.sendOidbPacket(packet, true);
      const data = Buffer.from(ret.hex_data, "hex");
      const ext = new NapProtoMsg(OidbSvcTrpcTcp0XFE1_2RSP).decode(new NapProtoMsg(OidbSvcTrpcTcpBase).decode(data).body).data.status.value;
      const extBigInt = BigInt(ext);
      if (extBigInt <= 10n) {
        return { status: Number(extBigInt) * 10, ext_status: 0 };
      }
      status = Number((extBigInt & 0xff00n) + (extBigInt >> 16n & 0xffn));
      return { status: 10, ext_status: status };
    } catch (error) {
      return void 0;
    }
  }
  async sendSetSpecialTittlePacket(groupCode, uid, tittle) {
    const data = this.packetSession?.packer.packSetSpecialTittlePacket(groupCode, uid, tittle);
    await this.sendOidbPacket(data, true);
  }
  // TODO: can simplify this
  async uploadResources(msg, groupUin = 0) {
    const reqList = [];
    for (const m of msg) {
      for (const e of m.msg) {
        if (e instanceof PacketMsgPicElement) {
          reqList.push(this.packetSession?.highwaySession.uploadImage({
            chatType: groupUin ? ChatType.KCHATTYPEGROUP : ChatType.KCHATTYPEC2C,
            peerUid: groupUin ? String(groupUin) : this.core.selfInfo.uid
          }, e));
        }
        if (e instanceof PacketMsgVideoElement) {
          reqList.push(this.packetSession?.highwaySession.uploadVideo({
            chatType: groupUin ? ChatType.KCHATTYPEGROUP : ChatType.KCHATTYPEC2C,
            peerUid: groupUin ? String(groupUin) : this.core.selfInfo.uid
          }, e));
        }
        if (e instanceof PacketMsgPttElement) {
          reqList.push(this.packetSession?.highwaySession.uploadPtt({
            chatType: groupUin ? ChatType.KCHATTYPEGROUP : ChatType.KCHATTYPEC2C,
            peerUid: groupUin ? String(groupUin) : this.core.selfInfo.uid
          }, e));
        }
        if (e instanceof PacketMsgFileElement) {
          reqList.push(this.packetSession?.highwaySession.uploadFile({
            chatType: groupUin ? ChatType.KCHATTYPEGROUP : ChatType.KCHATTYPEC2C,
            peerUid: groupUin ? String(groupUin) : this.core.selfInfo.uid
          }, e));
        }
      }
    }
    const res = await Promise.allSettled(reqList);
    this.logger.log(`上传资源${res.length}个，失败${res.filter((r) => r.status === "rejected").length}个`);
    res.forEach((result, index) => {
      if (result.status === "rejected") {
        this.logger.logError(`上传第${index + 1}个资源失败：${result.reason}`);
      }
    });
  }
  async sendUploadForwardMsg(msg, groupUin = 0) {
    await this.uploadResources(msg, groupUin);
    const data = await this.packetSession?.packer.packUploadForwardMsg(this.core.selfInfo.uid, msg, groupUin);
    const ret = await this.sendPacket("trpc.group.long_msg_interface.MsgService.SsoSendLongMsg", data, true);
    this.logger.logDebug("sendUploadForwardMsg", ret);
    const resp = new NapProtoMsg(SendLongMsgResp).decode(Buffer.from(ret.hex_data, "hex"));
    return resp.result.resId;
  }
  async sendGroupFileDownloadReq(groupUin, fileUUID) {
    const data = this.packetSession?.packer.packGroupFileDownloadReq(groupUin, fileUUID);
    const ret = await this.sendOidbPacket(data, true);
    const body = new NapProtoMsg(OidbSvcTrpcTcpBaseRsp).decode(Buffer.from(ret.hex_data, "hex")).body;
    const resp = new NapProtoMsg(OidbSvcTrpcTcp0x6D6Response).decode(body);
    if (resp.download.retCode !== 0) {
      throw new Error(`sendGroupFileDownloadReq error: ${resp.download.clientWording}`);
    }
    return `https://${resp.download.downloadDns}/ftn_handler/${Buffer.from(resp.download.downloadUrl).toString("hex")}/?fname=`;
  }
}

var NapCatCoreWorkingEnv = /* @__PURE__ */ ((NapCatCoreWorkingEnv2) => {
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Unknown"] = 0] = "Unknown";
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Shell"] = 1] = "Shell";
  NapCatCoreWorkingEnv2[NapCatCoreWorkingEnv2["Framework"] = 2] = "Framework";
  return NapCatCoreWorkingEnv2;
})(NapCatCoreWorkingEnv || {});
function loadQQWrapper(QQVersion) {
  let appPath;
  if (os$1.platform() === "darwin") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "../Resources/app");
  } else if (os$1.platform() === "linux") {
    appPath = path$1.resolve(path$1.dirname(process.execPath), "./resources/app");
  } else {
    appPath = path$1.resolve(path$1.dirname(process.execPath), `./versions/${QQVersion}/`);
  }
  let wrapperNodePath = path$1.resolve(appPath, "wrapper.node");
  if (!fs__default$1.existsSync(wrapperNodePath)) {
    wrapperNodePath = path$1.join(appPath, `./resources/app/wrapper.node`);
  }
  if (!fs__default$1.existsSync(wrapperNodePath)) {
    wrapperNodePath = path$1.join(path$1.dirname(process.execPath), `./resources/app/versions/${QQVersion}/wrapper.node`);
  }
  const nativemodule = { exports: {} };
  process.dlopen(nativemodule, wrapperNodePath);
  return nativemodule.exports;
}
class NapCatCore {
  context;
  apis;
  eventWrapper;
  // readonly eventChannel: NTEventChannel;
  NapCatDataPath;
  NapCatTempPath;
  // runtime info, not readonly
  selfInfo;
  util;
  configLoader;
  // 通过构造器递过去的 runtime info 应该尽量少
  constructor(context, selfInfo) {
    this.selfInfo = selfInfo;
    this.context = context;
    this.util = this.context.wrapper.NodeQQNTWrapperUtil;
    this.eventWrapper = new NTEventWrapper(context.session);
    this.configLoader = new NapCatConfigLoader(this, this.context.pathWrapper.configPath);
    this.apis = {
      FileApi: new NTQQFileApi(this.context, this),
      SystemApi: new NTQQSystemApi(this.context, this),
      CollectionApi: new NTQQCollectionApi(this.context, this),
      PacketApi: new NTQQPacketApi(this.context, this),
      WebApi: new NTQQWebApi(this.context, this),
      FriendApi: new NTQQFriendApi(this.context, this),
      MsgApi: new NTQQMsgApi(this.context, this),
      UserApi: new NTQQUserApi(this.context, this),
      GroupApi: new NTQQGroupApi(this.context, this)
    };
    this.NapCatDataPath = path$1.join(this.dataPath, "NapCat");
    fs__default$1.mkdirSync(this.NapCatDataPath, { recursive: true });
    this.NapCatTempPath = path$1.join(this.NapCatDataPath, "temp");
    if (!fs__default$1.existsSync(this.NapCatTempPath)) {
      fs__default$1.mkdirSync(this.NapCatTempPath, { recursive: true });
    }
    this.initNapCatCoreListeners().then().catch(this.context.logger.logError.bind(this.context.logger));
    this.context.logger.setFileLogEnabled(
      this.configLoader.configData.fileLog
    );
    this.context.logger.setConsoleLogEnabled(
      this.configLoader.configData.consoleLog
    );
    this.context.logger.setFileAndConsoleLogLevel(
      this.configLoader.configData.fileLogLevel,
      this.configLoader.configData.consoleLogLevel
    );
  }
  get dataPath() {
    let result = this.context.wrapper.NodeQQNTWrapperUtil.getNTUserDataInfoConfig();
    if (!result) {
      result = path$1.resolve(os$1.homedir(), "./.config/QQ");
      fs__default$1.mkdirSync(result, { recursive: true });
    }
    return result;
  }
  // Renamed from 'InitDataListener'
  async initNapCatCoreListeners() {
    const msgListener = new NodeIKernelMsgListener();
    msgListener.onKickedOffLine = (Info) => {
      this.context.logger.logError.bind(this.context.logger)("[KickedOffLine] [" + Info.tipsTitle + "] " + Info.tipsDesc);
      this.selfInfo.online = false;
    };
    msgListener.onRecvMsg = (msgs) => {
      msgs.forEach((msg) => this.context.logger.logMessage(msg, this.selfInfo));
    };
    msgListener.onAddSendMsg = (msg) => {
      this.context.logger.logMessage(msg, this.selfInfo);
    };
    this.context.session.getMsgService().addKernelMsgListener(
      proxiedListenerOf(msgListener, this.context.logger)
    );
    const profileListener = new NodeIKernelProfileListener();
    profileListener.onProfileDetailInfoChanged = (profile) => {
      if (profile.uid === this.selfInfo.uid) {
        Object.assign(this.selfInfo, profile);
      }
    };
    profileListener.onSelfStatusChanged = (Info) => {
      if (Info.status == 20) {
        this.selfInfo.online = false;
        this.context.logger.log("账号状态变更为离线");
      } else {
        this.selfInfo.online = true;
      }
    };
    this.context.session.getProfileService().addKernelProfileListener(
      proxiedListenerOf(profileListener, this.context.logger)
    );
    const groupListener = new NodeIKernelGroupListener();
    groupListener.onGroupListUpdate = (updateType, groupList) => {
      groupList.map((g) => {
        const existGroup = this.apis.GroupApi.groupCache.get(g.groupCode);
        if (existGroup && g.memberCount === existGroup.memberCount) {
          Object.assign(existGroup, g);
        } else {
          this.apis.GroupApi.groupCache.set(g.groupCode, g);
        }
        const sceneId = this.context.session.getGroupService().createMemberListScene(g.groupCode, "groupMemberList_MainWindow");
        this.context.session.getGroupService().getNextMemberList(sceneId, void 0, 3e3).then(
          /* r => {
              // console.log(`get group ${g.groupCode} members`, r);
              // r.result.infos.forEach(member => {
              // });
              // groupMembers.set(g.groupCode, r.result.infos);
          } */
        );
        this.context.session.getGroupService().destroyMemberListScene(sceneId);
      });
    };
    groupListener.onMemberListChange = (arg) => {
      const groupCode = arg.sceneId.split("_")[0];
      if (this.apis.GroupApi.groupMemberCache.has(groupCode)) {
        const existMembers = this.apis.GroupApi.groupMemberCache.get(groupCode);
        arg.infos.forEach((member, uid) => {
          const existMember = existMembers.get(uid);
          if (existMember) {
            Object.assign(existMember, member);
          } else {
            existMembers.set(uid, member);
          }
          if (member.isDelete) {
            existMembers.delete(uid);
          }
        });
      } else {
        this.apis.GroupApi.groupMemberCache.set(groupCode, arg.infos);
      }
    };
    groupListener.onMemberInfoChange = (groupCode, dataSource, members) => {
      if (dataSource === DataSource.LOCAL && members.get(this.selfInfo.uid)?.isDelete) {
        setTimeout(() => {
          this.apis.GroupApi.groupCache.delete(groupCode);
        }, 5e3);
      }
      const existMembers = this.apis.GroupApi.groupMemberCache.get(groupCode);
      if (existMembers) {
        members.forEach((member, uid) => {
          const existMember = existMembers.get(uid);
          if (existMember) {
            member.isChangeRole = this.checkAdminEvent(groupCode, member, existMember);
            Object.assign(existMember, member);
          } else {
            existMembers.set(uid, member);
          }
          if (member.isDelete) {
            existMembers.delete(uid);
          }
        });
      } else {
        this.apis.GroupApi.groupMemberCache.set(groupCode, members);
      }
    };
    this.context.session.getGroupService().addKernelGroupListener(
      proxiedListenerOf(groupListener, this.context.logger)
    );
  }
  checkAdminEvent(groupCode, memberNew, memberOld) {
    if (memberNew.role !== memberOld?.role) {
      this.context.logger.logDebug(`群 ${groupCode} ${memberNew.nick} 角色变更为 ${memberNew.role === 3 ? "管理员" : "群员"}`);
      return true;
    }
    return false;
  }
}
async function genSessionConfig(guid, QQVersionAppid, QQVersion, selfUin, selfUid, account_path) {
  const downloadPath = path$1.join(account_path, "NapCat", "temp");
  fs__default$1.mkdirSync(downloadPath, { recursive: true });
  const platformMapping = {
    win32: PlatformType.KWINDOWS,
    darwin: PlatformType.KMAC,
    linux: PlatformType.KLINUX
  };
  const systemPlatform = platformMapping[os$1.platform()] ?? PlatformType.KWINDOWS;
  return {
    selfUin,
    selfUid,
    desktopPathConfig: {
      account_path
      // 可以通过NodeQQNTWrapperUtil().getNTUserDataInfoConfig()获取
    },
    clientVer: QQVersion,
    a2: "",
    d2: "",
    d2Key: "",
    machineId: "",
    platform: systemPlatform,
    // 3是Windows? 
    platVer: systemVersion,
    // 系统版本号, 应该可以固定
    appid: QQVersionAppid,
    rdeliveryConfig: {
      appKey: "",
      systemId: 0,
      appId: "",
      logicEnvironment: "",
      platform: systemPlatform,
      language: "",
      sdkVersion: "",
      userId: "",
      appVersion: "",
      osVersion: "",
      bundleId: "",
      serverUrl: "",
      fixedAfterHitKeys: [""]
    },
    defaultFileDownloadPath: downloadPath,
    deviceInfo: {
      guid,
      buildVer: QQVersion,
      localId: 2052,
      devName: hostname,
      devType: systemName,
      vendorName: "",
      osVer: systemVersion,
      vendorOsName: systemName,
      setMute: false,
      vendorType: VendorType.KNOSETONIOS
    },
    deviceConfig: '{"appearance":{"isSplitViewMode":true},"msg":{}}'
  };
}

function getFormattedTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = (now.getMonth() + 1).toString().padStart(2, "0");
  const day = now.getDate().toString().padStart(2, "0");
  const hours = now.getHours().toString().padStart(2, "0");
  const minutes = now.getMinutes().toString().padStart(2, "0");
  const seconds = now.getSeconds().toString().padStart(2, "0");
  const milliseconds = now.getMilliseconds().toString().padStart(3, "0");
  return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}.${milliseconds}`;
}
class LogWrapper {
  fileLogEnabled = true;
  consoleLogEnabled = true;
  logConfig;
  loggerConsole;
  loggerFile;
  loggerDefault;
  // eslint-disable-next-line no-control-regex
  colorEscape = /\x1B[@-_][0-?]*[ -/]*[@-~]/g;
  constructor(logDir) {
    const filename = `${getFormattedTimestamp()}.log`;
    const logPath = path$1.join(logDir, filename);
    this.logConfig = {
      appenders: {
        FileAppender: {
          // 输出到文件的appender
          type: "file",
          filename: logPath,
          // 指定日志文件的位置和文件名
          maxLogSize: 10485760,
          // 日志文件的最大大小（单位：字节），这里设置为10MB
          layout: {
            type: "pattern",
            pattern: "%d{yyyy-MM-dd hh:mm:ss} [%p] %X{userInfo} | %m"
          }
        },
        ConsoleAppender: {
          // 输出到控制台的appender
          type: "console",
          layout: {
            type: "pattern",
            pattern: `%d{yyyy-MM-dd hh:mm:ss} [%[%p%]] ${chalk.magenta("%X{userInfo}")} | %m`
          }
        }
      },
      categories: {
        default: { appenders: ["FileAppender", "ConsoleAppender"], level: "debug" },
        // 默认情况下同时输出到文件和控制台
        file: { appenders: ["FileAppender"], level: "debug" },
        console: { appenders: ["ConsoleAppender"], level: "debug" }
      }
    };
    log4js.configure(this.logConfig);
    this.loggerConsole = log4js.getLogger("console");
    this.loggerFile = log4js.getLogger("file");
    this.loggerDefault = log4js.getLogger("default");
    this.setLogSelfInfo({ nick: "", uin: "", uid: "" });
  }
  setFileAndConsoleLogLevel(fileLogLevel, consoleLogLevel) {
    this.logConfig.categories.file.level = fileLogLevel;
    this.logConfig.categories.console.level = consoleLogLevel;
    log4js.configure(this.logConfig);
  }
  setLogSelfInfo(selfInfo) {
    const userInfo = `${selfInfo.nick}(${selfInfo.uin})`;
    this.loggerConsole.addContext("userInfo", userInfo);
    this.loggerFile.addContext("userInfo", userInfo);
    this.loggerDefault.addContext("userInfo", userInfo);
  }
  setFileLogEnabled(isEnabled) {
    this.fileLogEnabled = isEnabled;
  }
  setConsoleLogEnabled(isEnabled) {
    this.consoleLogEnabled = isEnabled;
  }
  formatMsg(msg) {
    let logMsg = "";
    for (const msgItem of msg) {
      if (msgItem instanceof Error) {
        logMsg += msgItem.stack + " ";
        continue;
      } else if (typeof msgItem === "object") {
        const obj = JSON.parse(JSON.stringify(msgItem, null, 2));
        logMsg += JSON.stringify(truncateString(obj)) + " ";
        continue;
      }
      logMsg += msgItem + " ";
    }
    return logMsg;
  }
  _log(level, ...args) {
    if (this.consoleLogEnabled) {
      this.loggerConsole[level](this.formatMsg(args));
    }
    if (this.fileLogEnabled) {
      this.loggerFile[level](this.formatMsg(args).replace(this.colorEscape, ""));
    }
  }
  log(...args) {
    this._log("info" /* INFO */, ...args);
  }
  logDebug(...args) {
    this._log("debug" /* DEBUG */, ...args);
  }
  logError(...args) {
    this._log("error" /* ERROR */, ...args);
  }
  logWarn(...args) {
    this._log("warn" /* WARN */, ...args);
  }
  logFatal(...args) {
    this._log("fatal" /* FATAL */, ...args);
  }
  logMessage(msg, selfInfo) {
    const isSelfSent = msg.senderUin === selfInfo.uin;
    if (msg.elements[0]?.elementType === ElementType.GreyTip) {
      return;
    }
    this.log(`${isSelfSent ? "发送 ->" : "接收 <-"} ${rawMessageToText(msg)}`);
  }
}
function rawMessageToText(msg, recursiveLevel = 0) {
  if (recursiveLevel > 2) {
    return "...";
  }
  const tokens = [];
  if (msg.chatType == ChatType.KCHATTYPEC2C) {
    tokens.push(`私聊 (${msg.peerUin})`);
  } else if (msg.chatType == ChatType.KCHATTYPEGROUP) {
    if (recursiveLevel < 1) {
      tokens.push(`群聊 [${msg.peerName}(${msg.peerUin})]`);
    }
    if (msg.senderUin !== "0") {
      tokens.push(`[${msg.sendMemberName || msg.sendRemarkName || msg.sendNickName}(${msg.senderUin})]`);
    }
  } else if (msg.chatType == ChatType.KCHATTYPEDATALINE) {
    tokens.push("移动设备");
  } else {
    tokens.push(`临时消息 (${msg.peerUin})`);
  }
  function msgElementToText(element) {
    if (element.textElement) {
      if (element.textElement.atType === AtType.notAt) {
        const originalContentLines = element.textElement.content.split("\n");
        return `${originalContentLines[0]}${originalContentLines.length > 1 ? " ..." : ""}`;
      } else if (element.textElement.atType === AtType.atAll) {
        return `@全体成员`;
      } else if (element.textElement.atType === AtType.atUser) {
        return `${element.textElement.content} (${element.textElement.atUid})`;
      }
    }
    if (element.replyElement) {
      const recordMsgOrNull = msg.records.find(
        (record) => element.replyElement.sourceMsgIdInRecords === record.msgId
      );
      return `[回复消息 ${recordMsgOrNull && recordMsgOrNull.peerUin != "284840486" && recordMsgOrNull.peerUin != "1094950020" ? rawMessageToText(recordMsgOrNull, recursiveLevel + 1) : `未找到消息记录 (MsgId = ${element.replyElement.sourceMsgIdInRecords})`}]`;
    }
    if (element.picElement) {
      return "[图片]";
    }
    if (element.fileElement) {
      return `[文件 ${element.fileElement.fileName}]`;
    }
    if (element.videoElement) {
      return "[视频]";
    }
    if (element.pttElement) {
      return `[语音 ${element.pttElement.duration}s]`;
    }
    if (element.arkElement) {
      return "[卡片消息]";
    }
    if (element.faceElement) {
      return `[表情 ${element.faceElement.faceText ?? ""}]`;
    }
    if (element.marketFaceElement) {
      return element.marketFaceElement.faceName;
    }
    if (element.markdownElement) {
      return "[Markdown 消息]";
    }
    if (element.multiForwardMsgElement) {
      return "[转发消息]";
    }
    if (element.elementType === ElementType.GreyTip) {
      return "[灰条消息]";
    }
    return `[未实现 (ElementType = ${element.elementType})]`;
  }
  for (const element of msg.elements) {
    tokens.push(msgElementToText(element));
  }
  return tokens.join(" ");
}

class NodeIDependsAdapter {
  onMSFStatusChange(statusType, changeReasonType) {
  }
  onMSFSsoError(args) {
  }
  getGroupCode(args) {
  }
}

class NodeIDispatcherAdapter {
  dispatchRequest(arg) {
  }
  dispatchCall(arg) {
  }
  dispatchCallWithJson(arg) {
  }
}

class NodeIGlobalAdapter {
  onLog(...args) {
  }
  onGetSrvCalTime(...args) {
  }
  onShowErrUITips(...args) {
  }
  fixPicImgType(...args) {
  }
  getAppSetting(...args) {
  }
  onInstallFinished(...args) {
  }
  onUpdateGeneralFlag(...args) {
  }
  onGetOfflineMsg(...args) {
  }
}

class NapCatPathWrapper {
  binaryPath;
  logsPath;
  configPath;
  cachePath;
  staticPath;
  constructor(mainPath = dirname(fileURLToPath(import.meta.url))) {
    this.binaryPath = mainPath;
    let writePath;
    if (os__default.platform() === "darwin") {
      writePath = path$2.join(os__default.homedir(), "Library", "Application Support", "QQ", "NapCat");
    } else {
      writePath = this.binaryPath;
    }
    this.logsPath = path$2.join(writePath, "logs");
    this.configPath = path$2.join(writePath, "config");
    this.cachePath = path$2.join(writePath, "cache");
    this.staticPath = path$2.join(this.binaryPath, "static");
    if (!fs__default.existsSync(this.logsPath)) {
      fs__default.mkdirSync(this.logsPath, { recursive: true });
    }
    if (!fs__default.existsSync(this.configPath)) {
      fs__default.mkdirSync(this.configPath, { recursive: true });
    }
    if (!fs__default.existsSync(this.cachePath)) {
      fs__default.mkdirSync(this.cachePath, { recursive: true });
    }
  }
}

const AppidTable = {
	"9.9.15-28060": {
	appid: 537246092,
	qua: "V1_WIN_NQ_9.9.15_28060_GW_B"
},
	"9.9.15-28131": {
	appid: 537246092,
	qua: "V1_WIN_NQ_9.9.15_28131_GW_B"
},
	"3.2.12-28060": {
	appid: 537246140,
	qua: "V1_LNX_NQ_3.2.12_28060_GW_B"
},
	"3.2.12-28131": {
	appid: 537246140,
	qua: "V1_LNX_NQ_3.2.12_28131_GW_B"
},
	"6.9.55-28131": {
	appid: 537246115,
	qua: "V1_MAC_NQ_6.9.55_28131_GW_B"
},
	"9.9.15-28327": {
	appid: 537249321,
	qua: "V1_WIN_NQ_9.9.15_28327_GW_B"
},
	"3.2.12-28327": {
	appid: 537249393,
	qua: "V1_LNX_NQ_3.2.12_28327_GW_B"
},
	"9.9.15-28418": {
	appid: 537249321,
	qua: "V1_WIN_NQ_9.9.15_28418_GW_B"
},
	"3.2.12-28418": {
	appid: 537249393,
	qua: "V1_LNX_NQ_3.2.12_28418_GW_B"
},
	"6.9.56-28418": {
	appid: 537249367,
	qua: "V1_MAC_NQ_6.9.56_28418_GW_B"
},
	"9.9.15-28498": {
	appid: 537249321,
	qua: "V1_WIN_NQ_9.9.15_28498_GW_B"
},
	"3.2.13-28788": {
	appid: 537249787,
	qua: "V1_LNX_NQ_3.2.13_28788_GW_B"
},
	"9.9.16-28788": {
	appid: 537249739,
	qua: "V1_WIN_NQ_9.9.16_28788_GW_B"
},
	"9.9.16-28971": {
	appid: 537249775,
	qua: "V1_WIN_NQ_9.9.16_28971_GW_B"
},
	"3.2.13-28971": {
	appid: 537249848,
	qua: "V1_LNX_NQ_3.2.13_28971_GW_B"
}
};

class QQBasicInfoWrapper {
  QQMainPath;
  QQPackageInfoPath;
  QQVersionConfigPath;
  isQuickUpdate;
  QQVersionConfig;
  QQPackageInfo;
  QQVersionAppid;
  QQVersionQua;
  context;
  constructor(context) {
    this.context = context;
    this.QQMainPath = process.execPath;
    this.QQVersionConfigPath = getQQVersionConfigPath(this.QQMainPath);
    this.isQuickUpdate = !!this.QQVersionConfigPath;
    this.QQVersionConfig = this.isQuickUpdate ? JSON.parse(fs__default$1.readFileSync(this.QQVersionConfigPath).toString()) : getDefaultQQVersionConfigInfo();
    this.QQPackageInfoPath = getQQPackageInfoPath(this.QQMainPath, this.QQVersionConfig?.curVersion);
    this.QQPackageInfo = JSON.parse(fs__default$1.readFileSync(this.QQPackageInfoPath).toString());
    const { appid: IQQVersionAppid, qua: IQQVersionQua } = this.getAppidV2();
    this.QQVersionAppid = IQQVersionAppid;
    this.QQVersionQua = IQQVersionQua;
  }
  //基础函数
  getQQBuildStr() {
    return this.isQuickUpdate ? this.QQVersionConfig?.buildId : this.QQPackageInfo?.buildVersion;
  }
  getFullQQVesion() {
    const version = this.isQuickUpdate ? this.QQVersionConfig?.curVersion : this.QQPackageInfo?.version;
    if (!version) throw new Error("QQ版本获取失败");
    return version;
  }
  requireMinNTQQBuild(buildStr) {
    const currentBuild = +(this.getQQBuildStr() ?? "0");
    if (currentBuild == 0) throw new Error("QQBuildStr获取失败");
    return currentBuild >= parseInt(buildStr);
  }
  //此方法不要直接使用
  getQUAFallback() {
    const platformMapping = {
      win32: `V1_WIN_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`,
      darwin: `V1_MAC_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`,
      linux: `V1_LNX_${this.getFullQQVesion()}_${this.getQQBuildStr()}_GW_B`
    };
    return platformMapping[systemPlatform] ?? platformMapping.win32;
  }
  getAppIdFallback() {
    const platformMapping = {
      win32: "537246092",
      darwin: "537246140",
      linux: "537246140"
    };
    return platformMapping[systemPlatform] ?? "537246092";
  }
  getAppidV2() {
    const appidTbale = AppidTable;
    const fullVersion = this.getFullQQVesion();
    if (fullVersion) {
      const data = appidTbale[fullVersion];
      if (data) {
        return data;
      }
    }
    this.context.logger.log(`[QQ版本兼容性检测] 获取Appid异常 请检测NapCat/QQNT是否正常`);
    this.context.logger.log(`[QQ版本兼容性检测] ${fullVersion} 版本兼容性不佳，可能会导致一些功能无法正常使用`);
    return { appid: this.getAppIdFallback(), qua: this.getQUAFallback() };
  }
}

var commander = {};

var argument = {};

var error$j = {};

/**
 * CommanderError class
 */

let CommanderError$3 = class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
};

/**
 * InvalidArgumentError class
 */
let InvalidArgumentError$4 = class InvalidArgumentError extends CommanderError$3 {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
};

error$j.CommanderError = CommanderError$3;
error$j.InvalidArgumentError = InvalidArgumentError$4;

const { InvalidArgumentError: InvalidArgumentError$3 } = error$j;

let Argument$3 = class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Only allow argument value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError$3(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Make argument required.
   *
   * @returns {Argument}
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make argument optional.
   *
   * @returns {Argument}
   */
  argOptional() {
    this.required = false;
    return this;
  }
};

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @private
 */

function humanReadableArgName$2(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

argument.Argument = Argument$3;
argument.humanReadableArgName = humanReadableArgName$2;

var command = {};

var help = {};

const { humanReadableArgName: humanReadableArgName$1 } = argument;

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// Although this is a class, methods are static in style to allow override using subclass or just functions.
let Help$3 = class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
    this.showGlobalOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
    const helpCommand = cmd._getHelpCommand();
    if (helpCommand && !helpCommand._hidden) {
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: because overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Compare options for sort.
   *
   * @param {Option} a
   * @param {Option} b
   * @returns {number}
   */
  compareOptions(a, b) {
    const getSortKey = (option) => {
      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
      return option.short
        ? option.short.replace(/^-/, '')
        : option.long.replace(/^--/, '');
    };
    return getSortKey(a).localeCompare(getSortKey(b));
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Built-in help option.
    const helpOption = cmd._getHelpOption();
    if (helpOption && !helpOption.hidden) {
      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
      if (!removeShort && !removeLong) {
        visibleOptions.push(helpOption); // no changes needed
      } else if (helpOption.long && !removeLong) {
        visibleOptions.push(
          cmd.createOption(helpOption.long, helpOption.description),
        );
      } else if (helpOption.short && !removeShort) {
        visibleOptions.push(
          cmd.createOption(helpOption.short, helpOption.description),
        );
      }
    }
    if (this.sortOptions) {
      visibleOptions.sort(this.compareOptions);
    }
    return visibleOptions;
  }

  /**
   * Get an array of the visible global options. (Not including help.)
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleGlobalOptions(cmd) {
    if (!this.showGlobalOptions) return [];

    const globalOptions = [];
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      const visibleOptions = ancestorCmd.options.filter(
        (option) => !option.hidden,
      );
      globalOptions.push(...visibleOptions);
    }
    if (this.sortOptions) {
      globalOptions.sort(this.compareOptions);
    }
    return globalOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd.registeredArguments.forEach((argument) => {
        argument.description =
          argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd.registeredArguments.find((argument) => argument.description)) {
      return cmd.registeredArguments;
    }
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd.registeredArguments
      .map((arg) => humanReadableArgName$1(arg))
      .join(' ');
    return (
      cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '')
    );
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
  }

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest global option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestGlobalOptionTermLength(cmd, helper) {
    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    }, 0);
  }

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let ancestorCmdNames = '';
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
    }
    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.description();
  }

  /**
   * Get the subcommand summary to show in the list of subcommands.
   * (Fallback to description for backwards compatibility.)
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.summary() || cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];

    if (option.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (option.defaultValue !== undefined) {
      // default for boolean and negated more for programmer than end user,
      // but show true/false for boolean option as may be for hand-rolled env or config processing.
      const showDefault =
        option.required ||
        option.optional ||
        (option.isBoolean() && typeof option.defaultValue === 'boolean');
      if (showDefault) {
        extraInfo.push(
          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,
        );
      }
    }
    // preset for boolean and negated are more for programmer than end user
    if (option.presetArg !== undefined && option.optional) {
      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  }

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(
        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,
      );
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
    }
    return argument.description;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
        return helper.wrap(
          fullText,
          helpWidth - itemIndentWidth,
          termWidth + itemSeparatorWidth,
        );
      }
      return term;
    }
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([
        helper.wrap(commandDescription, helpWidth, 0),
        '',
      ]);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(
        helper.argumentTerm(argument),
        helper.argumentDescription(argument),
      );
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(
        helper.optionTerm(option),
        helper.optionDescription(option),
      );
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    if (this.showGlobalOptions) {
      const globalOptionList = helper
        .visibleGlobalOptions(cmd)
        .map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option),
          );
        });
      if (globalOptionList.length > 0) {
        output = output.concat([
          'Global Options:',
          formatList(globalOptionList),
          '',
        ]);
      }
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(
        helper.subcommandTerm(cmd),
        helper.subcommandDescription(cmd),
      );
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestGlobalOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper),
    );
  }

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Full \s characters, minus the linefeeds.
    const indents =
      ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
    const manualIndent = new RegExp(`[\\n][${indents}]+`);
    if (str.match(manualIndent)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.slice(0, indent);
    const columnText = str.slice(indent).replace('\r\n', '\n');
    const indentString = ' '.repeat(indent);
    const zeroWidthSpace = '\u200B';
    const breaks = `\\s${zeroWidthSpace}`;
    // Match line end (so empty lines don't collapse),
    // or as much text as will fit in column, or excess text up to first break.
    const regex = new RegExp(
      `\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
      'g',
    );
    const lines = columnText.match(regex) || [];
    return (
      leadingStr +
      lines
        .map((line, i) => {
          if (line === '\n') return ''; // preserve empty lines
          return (i > 0 ? indentString : '') + line.trimEnd();
        })
        .join('\n')
    );
  }
};

help.Help = Help$3;

var option = {};

const { InvalidArgumentError: InvalidArgumentError$2 } = error$j;

let Option$3 = class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
   *
   * @example
   * new Option('--color').default('GREYSCALE').preset('RGB');
   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
   *
   * @param {*} arg
   * @return {Option}
   */

  preset(arg) {
    this.presetArg = arg;
    return this;
  }

  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
   * new Option('--js').conflicts(['ts', 'jsx']);
   *
   * @param {(string | string[])} names
   * @return {Option}
   */

  conflicts(names) {
    this.conflictsWith = this.conflictsWith.concat(names);
    return this;
  }

  /**
   * Specify implied option values for when this option is set and the implied options are not.
   *
   * The custom processing (parseArg) is not called on the implied values.
   *
   * @example
   * program
   *   .addOption(new Option('--log', 'write logging information to file'))
   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
   *
   * @param {object} impliedOptionValues
   * @return {Option}
   */
  implies(impliedOptionValues) {
    let newImplied = impliedOptionValues;
    if (typeof impliedOptionValues === 'string') {
      // string is not documented, but easy mistake and we can do what user probably intended.
      newImplied = { [impliedOptionValues]: true };
    }
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  }

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  }

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError$2(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  }

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   */

  attributeName() {
    return camelcase(this.name().replace(/^no-/, ''));
  }

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @package
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  }

  /**
   * Return whether a boolean option.
   *
   * Options are one of boolean, negated, required argument, or optional argument.
   *
   * @return {boolean}
   * @package
   */

  isBoolean() {
    return !this.required && !this.optional && !this.negate;
  }
};

/**
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
let DualOptions$1 = class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach((option) => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
   * @param {*} value
   * @param {Option} option
   * @returns {boolean}
   */
  valueFromOption(value, option) {
    const optionKey = option.attributeName();
    if (!this.dualOptions.has(optionKey)) return true;

    // Use the value to deduce if (probably) came from the option.
    const preset = this.negativeOptions.get(optionKey).presetArg;
    const negativeValue = preset !== undefined ? preset : false;
    return option.negate === (negativeValue === value);
  }
};

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
    shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

option.Option = Option$3;
option.DualOptions = DualOptions$1;

var suggestSimilar$2 = {};

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance)
    return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost, // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar$1(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map((candidate) => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map((candidate) => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

suggestSimilar$2.suggestSimilar = suggestSimilar$1;

const EventEmitter = require$$0.EventEmitter;
const childProcess = require$$1$1;
const path = path$1;
const fs = fs__default$1;
const process$1 = process$2;

const { Argument: Argument$2, humanReadableArgName } = argument;
const { CommanderError: CommanderError$2 } = error$j;
const { Help: Help$2 } = help;
const { Option: Option$2, DualOptions } = option;
const { suggestSimilar } = suggestSimilar$2;

let Command$2 = class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {(boolean | string)} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process$1.stdout.write(str),
      writeErr: (str) => process$1.stderr.write(str),
      getOutHelpWidth: () =>
        process$1.stdout.isTTY ? process$1.stdout.columns : undefined,
      getErrHelpWidth: () =>
        process$1.stderr.isTTY ? process$1.stderr.columns : undefined,
      outputError: (str, write) => write(str),
    };

    this._hidden = false;
    /** @type {(Option | null | undefined)} */
    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
    /** @type {Command} */
    this._helpCommand = undefined; // lazy initialised, inherited
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._helpOption = sourceCommand._helpOption;
    this._helpCommand = sourceCommand._helpCommand;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue =
      sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @private
   */

  _getCommandAndAncestors() {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this._registerCommand(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help$2(), this.configureHelp());
  }

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {(boolean|string)} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this._registerCommand(cmd);
    cmd.parent = this;
    cmd._checkForBrokenPassThrough();

    return this;
  }

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument$2(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {(Function|*)} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names
      .trim()
      .split(/ +/)
      .forEach((detail) => {
        this.argument(detail);
      });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this.registeredArguments.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(
        `only the last argument can be variadic '${previousArgument.name()}'`,
      );
    }
    if (
      argument.required &&
      argument.defaultValue !== undefined &&
      argument.parseArg === undefined
    ) {
      throw new Error(
        `a default value for a required argument is never used: '${argument.name()}'`,
      );
    }
    this.registeredArguments.push(argument);
    return this;
  }

  /**
   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
   *
   * @example
   *    program.helpCommand('help [cmd]');
   *    program.helpCommand('help [cmd]', 'show help');
   *    program.helpCommand(false); // suppress default help command
   *    program.helpCommand(true); // add help command even if no subcommands
   *
   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
   * @param {string} [description] - custom description
   * @return {Command} `this` command for chaining
   */

  helpCommand(enableOrNameAndArgs, description) {
    if (typeof enableOrNameAndArgs === 'boolean') {
      this._addImplicitHelpCommand = enableOrNameAndArgs;
      return this;
    }

    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
    const helpDescription = description ?? 'display help for command';

    const helpCommand = this.createCommand(helpName);
    helpCommand.helpOption(false);
    if (helpArgs) helpCommand.arguments(helpArgs);
    if (helpDescription) helpCommand.description(helpDescription);

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;

    return this;
  }

  /**
   * Add prepared custom help command.
   *
   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
   * @return {Command} `this` command for chaining
   */
  addHelpCommand(helpCommand, deprecatedDescription) {
    // If not passed an object, call through to helpCommand for backwards compatibility,
    // as addHelpCommand was originally used like helpCommand is now.
    if (typeof helpCommand !== 'object') {
      this.helpCommand(helpCommand, deprecatedDescription);
      return this;
    }

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;
    return this;
  }

  /**
   * Lazy create help command.
   *
   * @return {(Command|null)}
   * @package
   */
  _getHelpCommand() {
    const hasImplicitHelpCommand =
      this._addImplicitHelpCommand ??
      (this.commands.length &&
        !this._actionHandler &&
        !this._findCommand('help'));

    if (hasImplicitHelpCommand) {
      if (this._helpCommand === undefined) {
        this.helpCommand(undefined, undefined); // use default name and description
      }
      return this._helpCommand;
    }
    return null;
  }

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        }
      };
    }
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError$2(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process$1.exit(exitCode);
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option$2(flags, description);
  }

  /**
   * Wrap parseArgs to catch 'commander.invalidArgument'.
   *
   * @param {(Option | Argument)} target
   * @param {string} value
   * @param {*} previous
   * @param {string} invalidArgumentMessage
   * @private
   */

  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
      return target.parseArg(value, previous);
    } catch (err) {
      if (err.code === 'commander.invalidArgument') {
        const message = `${invalidArgumentMessage} ${err.message}`;
        this.error(message, { exitCode: err.exitCode, code: err.code });
      }
      throw err;
    }
  }

  /**
   * Check for option flag conflicts.
   * Register option if no conflicts found, or throw on conflict.
   *
   * @param {Option} option
   * @private
   */

  _registerOption(option) {
    const matchingOption =
      (option.short && this._findOption(option.short)) ||
      (option.long && this._findOption(option.long));
    if (matchingOption) {
      const matchingFlag =
        option.long && this._findOption(option.long)
          ? option.long
          : option.short;
      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
    }

    this.options.push(option);
  }

  /**
   * Check for command name and alias conflicts with existing commands.
   * Register command if no conflicts found, or throw on conflict.
   *
   * @param {Command} command
   * @private
   */

  _registerCommand(command) {
    const knownBy = (cmd) => {
      return [cmd.name()].concat(cmd.aliases());
    };

    const alreadyUsed = knownBy(command).find((name) =>
      this._findCommand(name),
    );
    if (alreadyUsed) {
      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
      const newCmd = knownBy(command).join('|');
      throw new Error(
        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,
      );
    }

    this.commands.push(command);
  }

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    this._registerOption(option);

    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(
          name,
          option.defaultValue === undefined ? true : option.defaultValue,
          'default',
        );
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
        val = option.presetArg;
      }

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @return {Command} `this` command for chaining
   * @private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option$2) {
      throw new Error(
        'To add an Option object use addOption() instead of option() or requiredOption()',
      );
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
    return this._optionEx({}, flags, description, parseArg, defaultValue);
  }

  /**
   * Add a required option which must have a value after parsing. This usually means
   * the option must be specified on the command line. (Otherwise the same as .option().)
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx(
      { mandatory: true },
      flags,
      description,
      parseArg,
      defaultValue,
    );
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
   * @return {Command} `this` command for chaining
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }

  /**
   * Allow unknown options on the command line.
   *
   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
   * @return {Command} `this` command for chaining
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  }

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
   * @return {Command} `this` command for chaining
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  }

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {boolean} [positional]
   * @return {Command} `this` command for chaining
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {boolean} [passThrough] for unknown options.
   * @return {Command} `this` command for chaining
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    this._checkForBrokenPassThrough();
    return this;
  }

  /**
   * @private
   */

  _checkForBrokenPassThrough() {
    if (
      this.parent &&
      this._passThroughOptions &&
      !this.parent._enablePositionalOptions
    ) {
      throw new Error(
        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
      );
    }
  }

  /**
   * Whether to store option values as properties on command object,
   * or store separately (specify false). In both cases the option values can be accessed using .opts().
   *
   * @param {boolean} [storeAsProperties=true]
   * @return {Command} `this` command for chaining
   */

  storeOptionsAsProperties(storeAsProperties = true) {
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    if (Object.keys(this._optionValues).length) {
      throw new Error(
        'call .storeOptionsAsProperties() before setting option values',
      );
    }
    this._storeOptionsAsProperties = !!storeAsProperties;
    return this;
  }

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  }

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    return this.setOptionValueWithSource(key, value, undefined);
  }

  /**
   * Store option value and where the value came from.
   *
   * @param {string} key
   * @param {object} value
   * @param {string} source - expected values are default/config/env/cli/implied
   * @return {Command} `this` command for chaining
   */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
   * Get source of option value.
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

  /**
   * Get source of option value. See also .optsWithGlobals().
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    this._getCommandAndAncestors().forEach((cmd) => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
      }
    });
    return source;
  }

  /**
   * Get user arguments from implied or explicit arguments.
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   *
   * @private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // auto-detect argument conventions if nothing supplied
    if (argv === undefined && parseOptions.from === undefined) {
      if (process$1.versions?.electron) {
        parseOptions.from = 'electron';
      }
      // check node specific options for scenarios where user CLI args follow executable without scriptname
      const execArgv = process$1.execArgv ?? [];
      if (
        execArgv.includes('-e') ||
        execArgv.includes('--eval') ||
        execArgv.includes('-p') ||
        execArgv.includes('--print')
      ) {
        parseOptions.from = 'eval'; // internal usage, not documented
      }
    }

    // default to using process.argv
    if (argv === undefined) {
      argv = process$1.argv;
    }
    this.rawArgs = argv.slice();

    // extract the user args and scriptPath
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: because defaultApp is an unknown property
        if (process$1.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      case 'eval':
        userArgs = argv.slice(1);
        break;
      default:
        throw new Error(
          `unexpected parse option { from: '${parseOptions.from}' }`,
        );
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath)
      this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * program.parse(); // parse process.argv and auto-detect electron and special node flags
   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Execute a sub-command executable.
   *
   * @private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    function findFile(baseDir, baseName) {
      // Look for specified file
      const localBin = path.resolve(baseDir, baseName);
      if (fs.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path.extname(baseName))) return undefined;

      // Try all the extensions.
      const foundExt = sourceExt.find((ext) =>
        fs.existsSync(`${localBin}${ext}`),
      );
      if (foundExt) return `${localBin}${foundExt}`;

      return undefined;
    }

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // executableFile and executableDir might be full path, or just a name
    let executableFile =
      subcommand._executableFile || `${this._name}-${subcommand._name}`;
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs.realpathSync(this._scriptPath);
      } catch (err) {
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path.resolve(
        path.dirname(resolvedScriptPath),
        executableDir,
      );
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path.basename(
          this._scriptPath,
          path.extname(this._scriptPath),
        );
        if (legacyName !== this._name) {
          localFile = findFile(
            executableDir,
            `${legacyName}-${subcommand._name}`,
          );
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path.extname(executableFile));

    let proc;
    if (process$1.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process$1.execArgv).concat(args);

        proc = childProcess.spawn(process$1.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process$1.execArgv).concat(args);
      proc = childProcess.spawn(process$1.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) {
      // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        process$1.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            // @ts-ignore because signals not typed to known strings
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    const exitCallback = this._exitCallback;
    proc.on('close', (code) => {
      code = code ?? 1; // code is null if spawned process terminated due to a signal
      if (!exitCallback) {
        process$1.exit(code);
      } else {
        exitCallback(
          new CommanderError$2(
            code,
            'commander.executeSubCommandAsync',
            '(close)',
          ),
        );
      }
    });
    proc.on('error', (err) => {
      // @ts-ignore: because err.code is an unknown property
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
        // @ts-ignore: because err.code is an unknown property
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process$1.exit(1);
      } else {
        const wrappedError = new CommanderError$2(
          1,
          'commander.executeSubCommandAsync',
          '(error)',
        );
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(
      promiseChain,
      subCommand,
      'preSubcommand',
    );
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(
      subcommandName,
      [],
      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
    );
  }

  /**
   * Check this.args against expected this.registeredArguments.
   *
   * @private
   */

  _checkNumberOfArguments() {
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (
      this.registeredArguments.length > 0 &&
      this.registeredArguments[this.registeredArguments.length - 1].variadic
    ) {
      return;
    }
    if (this.args.length > this.registeredArguments.length) {
      this._excessArguments(this.args);
    }
  }

  /**
   * Process this.args using this.registeredArguments and save as this.processedArgs!
   *
   * @private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
        parsedValue = this._callParseArg(
          argument,
          value,
          previous,
          invalidValueMessage,
        );
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {(Promise|undefined)} promise
   * @param {Function} fn
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    this._getCommandAndAncestors()
      .reverse()
      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)
      .forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {Command} subCommand
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach((hook) => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (
      this._getHelpCommand() &&
      operands[0] === this._getHelpCommand().name()
    ) {
      return this._dispatchHelpCommand(operands[1]);
    }
    if (this._defaultCommandName) {
      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(
        this._defaultCommandName,
        operands,
        unknown,
      );
    }
    if (
      this.commands.length &&
      this.args.length === 0 &&
      !this._actionHandler &&
      !this._defaultCommandName
    ) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    this._outputHelpIfRequested(parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () =>
        this._actionHandler(this.processedArgs),
      );
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) {
        // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @private
   * @return {Command | undefined}
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(
      (cmd) => cmd._name === name || cmd._aliases.includes(name),
    );
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @package
   */

  _findOption(arg) {
    return this.options.find((option) => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
        if (
          anOption.mandatory &&
          cmd.getOptionValue(anOption.attributeName()) === undefined
        ) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    });
  }

  /**
   * Display an error message if conflicting options are used together in this.
   *
   * @private
   */
  _checkForConflictingLocalOptions() {
    const definedNonDefaultOptions = this.options.filter((option) => {
      const optionKey = option.attributeName();
      if (this.getOptionValue(optionKey) === undefined) {
        return false;
      }
      return this.getOptionValueSource(optionKey) !== 'default';
    });

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0,
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName()),
      );
      if (conflictingAndDefined) {
        this._conflictingOption(option, conflictingAndDefined);
      }
    });
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {string[]} argv
   * @return {{operands: string[], unknown: string[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else {
            // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (
            option.required ||
            (option.optional && this._combineFlagAndOptionalValue)
          ) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if (
        (this._enablePositionalOptions || this._passThroughOptions) &&
        operands.length === 0 &&
        unknown.length === 0
      ) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (
          this._getHelpCommand() &&
          arg === this._getHelpCommand().name()
        ) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] =
          key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return this._getCommandAndAncestors().reduce(
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {},
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(
      `${message}\n`,
      this._outputConfiguration.writeErr,
    );
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process$1.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (
          this.getOptionValue(optionKey) === undefined ||
          ['default', 'config', 'env'].includes(
            this.getOptionValueSource(optionKey),
          )
        ) {
          if (option.required || option.optional) {
            // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process$1.env[option.envVar]);
          } else {
            // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = (optionKey) => {
      return (
        this.getOptionValue(optionKey) !== undefined &&
        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
      );
    };
    this.options
      .filter(
        (option) =>
          option.implied !== undefined &&
          hasCustomOptionValue(option.attributeName()) &&
          dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option,
          ),
      )
      .forEach((option) => {
        Object.keys(option.implied)
          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
          .forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              'implied',
            );
          });
      });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this.error(message, { code: 'commander.optionMissingArgument' });
  }

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
  }

  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @private
   */
  _conflictingOption(option, conflictingOption) {
    // The calling code does not know whether a negated option is the source of the
    // value, so do some work to take an educated guess.
    const findBestOptionFromValue = (option) => {
      const optionKey = option.attributeName();
      const optionValue = this.getOptionValue(optionKey);
      const negativeOption = this.options.find(
        (target) => target.negate && optionKey === target.attributeName(),
      );
      const positiveOption = this.options.find(
        (target) => !target.negate && optionKey === target.attributeName(),
      );
      if (
        negativeOption &&
        ((negativeOption.presetArg === undefined && optionValue === false) ||
          (negativeOption.presetArg !== undefined &&
            optionValue === negativeOption.presetArg))
      ) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      let command = this;
      do {
        const moreFlags = command
          .createHelp()
          .visibleOptions(command)
          .filter((option) => option.long)
          .map((option) => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = expected === 1 ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }

  /**
   * Unknown command.
   *
   * @private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp()
        .visibleCommands(this)
        .forEach((command) => {
          candidateNames.push(command.name());
          // just visible alias
          if (command.alias()) candidateNames.push(command.alias());
        });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }

  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str]
   * @param {string} [flags]
   * @param {string} [description]
   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this._registerOption(versionOption);

    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set the description.
   *
   * @param {string} [str]
   * @param {object} [argsDescription]
   * @return {(string|Command)}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined)
      return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {(string|Command)}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let command = this;
    if (
      this.commands.length !== 0 &&
      this.commands[this.commands.length - 1]._executableHandler
    ) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name)
      throw new Error("Command alias can't be the same as its name");
    const matchingCommand = this.parent?._findCommand(alias);
    if (matchingCommand) {
      // c.f. _registerCommand
      const existingCmd = [matchingCommand.name()]
        .concat(matchingCommand.aliases())
        .join('|');
      throw new Error(
        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
      );
    }

    command._aliases.push(alias);
    return this;
  }

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {(string[]|Command)}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return []
        .concat(
          this.options.length || this._helpOption !== null ? '[options]' : [],
          this.commands.length ? '[command]' : [],
          this.registeredArguments.length ? args : [],
        )
        .join(' ');
    }

    this._usage = str;
    return this;
  }

  /**
   * Get or set the name of the command.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }

  /**
   * Set the name of the command from script filename, such as process.argv[1],
   * or require.main.filename, or __filename.
   *
   * (Used internally and public although not documented in README.)
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   *
   * @param {string} filename
   * @return {Command}
   */

  nameFromFilename(filename) {
    this._name = path.basename(filename, path.extname(filename));

    return this;
  }

  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   *
   * @param {string} [path]
   * @return {(string|null|Command)}
   */

  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth =
        contextOptions && contextOptions.error
          ? this._outputConfiguration.getErrHelpWidth()
          : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }

  /**
   * @private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    this._getCommandAndAncestors()
      .reverse()
      .forEach((command) => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (
        typeof helpInformation !== 'string' &&
        !Buffer.isBuffer(helpInformation)
      ) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    if (this._getHelpOption()?.long) {
      this.emit(this._getHelpOption().long); // deprecated
    }
    this.emit('afterHelp', context);
    this._getCommandAndAncestors().forEach((command) =>
      command.emit('afterAllHelp', context),
    );
  }

  /**
   * You can pass in flags and a description to customise the built-in help option.
   * Pass in false to disable the built-in help option.
   *
   * @example
   * program.helpOption('-?, --help' 'show help'); // customise
   * program.helpOption(false); // disable
   *
   * @param {(string | boolean)} flags
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    // Support disabling built-in help option.
    if (typeof flags === 'boolean') {
      if (flags) {
        this._helpOption = this._helpOption ?? undefined; // preserve existing option
      } else {
        this._helpOption = null; // disable
      }
      return this;
    }

    // Customise flags and description.
    flags = flags ?? '-h, --help';
    description = description ?? 'display help for command';
    this._helpOption = this.createOption(flags, description);

    return this;
  }

  /**
   * Lazy create help option.
   * Returns null if has been disabled with .helpOption(false).
   *
   * @returns {(Option | null)} the help option
   * @package
   */
  _getHelpOption() {
    // Lazy create help option on demand.
    if (this._helpOption === undefined) {
      this.helpOption(undefined, undefined);
    }
    return this._helpOption;
  }

  /**
   * Supply your own option to use for the built-in help option.
   * This is an alternative to using helpOption() to customise the flags and description etc.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addHelpOption(option) {
    this._helpOption = option;
    return this;
  }

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process$1.exitCode || 0;
    if (
      exitCode === 0 &&
      contextOptions &&
      typeof contextOptions !== 'function' &&
      contextOptions.error
    ) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {(string | Function)} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }

  /**
   * Output help information if help flags specified
   *
   * @param {Array} args - array of options to search for help flags
   * @private
   */

  _outputHelpIfRequested(args) {
    const helpOption = this._getHelpOption();
    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
    if (helpRequested) {
      this.outputHelp();
      // (Do not have all displayed text available so only passing placeholder.)
      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
  }
};

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
    ) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null
    ) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

command.Command = Command$2;

const { Argument: Argument$1 } = argument;
const { Command: Command$1 } = command;
const { CommanderError: CommanderError$1, InvalidArgumentError: InvalidArgumentError$1 } = error$j;
const { Help: Help$1 } = help;
const { Option: Option$1 } = option;

commander.program = new Command$1();

commander.createCommand = (name) => new Command$1(name);
commander.createOption = (flags, description) => new Option$1(flags, description);
commander.createArgument = (name, description) => new Argument$1(name, description);

/**
 * Expose classes
 */

commander.Command = Command$1;
commander.Option = Option$1;
commander.Argument = Argument$1;
commander.Help = Help$1;

commander.CommanderError = CommanderError$1;
commander.InvalidArgumentError = InvalidArgumentError$1;
commander.InvalidOptionArgumentError = InvalidArgumentError$1; // Deprecated

// wrapper to provide named exports for ESM.
const {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError, // deprecated old name
  Command,
  Argument,
  Option,
  Help,
} = commander;

class OB11ConfigLoader extends ConfigBase {
  constructor(core, configPath) {
    super("onebot11", core, configPath);
  }
}

class OB11ActiveHttpAdapter {
  constructor(url, secret, core, obContext) {
    this.url = url;
    this.secret = secret;
    this.core = core;
    this.obContext = obContext;
    this.logger = core.context.logger;
  }
  logger;
  isOpen = false;
  onEvent(event) {
    if (!this.isOpen) {
      return;
    }
    const headers = {
      "Content-Type": "application/json",
      "x-self-id": this.core.selfInfo.uin
    };
    const msgStr = JSON.stringify(event);
    if (this.secret && this.secret.length > 0) {
      const hmac = createHmac("sha1", this.secret);
      hmac.update(msgStr);
      const sig = hmac.digest("hex");
      headers["x-signature"] = "sha1=" + sig;
    }
    fetch(this.url, {
      method: "POST",
      headers,
      body: msgStr
    }).then(async (res) => {
      let resJson;
      try {
        resJson = await res.json();
      } catch (e) {
        this.logger.logDebug("[OneBot] [Http Client] 新消息事件HTTP上报没有返回快速操作，不需要处理");
        return;
      }
      try {
        this.obContext.apis.QuickActionApi.handleQuickOperation(event, resJson).catch(this.logger.logError.bind(this.logger));
      } catch (e) {
        this.logger.logError.bind(this.logger)("[OneBot] [Http Client] 新消息事件HTTP上报返回快速操作失败", e);
      }
    }).catch((e) => {
      this.logger.logError.bind(this.logger)("[OneBot] [Http Client] 新消息事件HTTP上报失败", e);
    });
  }
  open() {
    this.isOpen = true;
  }
  close() {
    this.isOpen = false;
  }
}

var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["META"] = "meta_event";
  EventType2["REQUEST"] = "request";
  EventType2["NOTICE"] = "notice";
  EventType2["MESSAGE"] = "message";
  EventType2["MESSAGE_SENT"] = "message_sent";
  return EventType2;
})(EventType || {});
class OB11BaseEvent {
  time = Math.floor(Date.now() / 1e3);
  self_id;
  constructor(core) {
    this.self_id = parseInt(core.selfInfo.uin);
  }
}

class OB11BaseMetaEvent extends OB11BaseEvent {
  post_type = EventType.META;
}

class OB11HeartbeatEvent extends OB11BaseMetaEvent {
  meta_event_type = "heartbeat";
  status;
  interval;
  constructor(core, interval, isOnline, isGood) {
    super(core);
    this.interval = interval;
    this.status = {
      online: isOnline && true,
      good: isGood
    };
  }
}

var ActionName = /* @__PURE__ */ ((ActionName2) => {
  ActionName2["SendPrivateMsg"] = "send_private_msg";
  ActionName2["SendGroupMsg"] = "send_group_msg";
  ActionName2["SendMsg"] = "send_msg";
  ActionName2["DeleteMsg"] = "delete_msg";
  ActionName2["GetMsg"] = "get_msg";
  ActionName2["GoCQHTTP_GetForwardMsg"] = "get_forward_msg";
  ActionName2["SendLike"] = "send_like";
  ActionName2["SetGroupKick"] = "set_group_kick";
  ActionName2["SetGroupBan"] = "set_group_ban";
  ActionName2["SetGroupWholeBan"] = "set_group_whole_ban";
  ActionName2["SetGroupAdmin"] = "set_group_admin";
  ActionName2["SetGroupCard"] = "set_group_card";
  ActionName2["SetGroupName"] = "set_group_name";
  ActionName2["SetGroupLeave"] = "set_group_leave";
  ActionName2["SetSpecialTittle"] = "set_group_special_title";
  ActionName2["SetFriendAddRequest"] = "set_friend_add_request";
  ActionName2["SetGroupAddRequest"] = "set_group_add_request";
  ActionName2["GetLoginInfo"] = "get_login_info";
  ActionName2["GoCQHTTP_GetStrangerInfo"] = "get_stranger_info";
  ActionName2["GetFriendList"] = "get_friend_list";
  ActionName2["GetGroupInfo"] = "get_group_info";
  ActionName2["GetGroupList"] = "get_group_list";
  ActionName2["GetGroupMemberInfo"] = "get_group_member_info";
  ActionName2["GetGroupMemberList"] = "get_group_member_list";
  ActionName2["GetGroupHonorInfo"] = "get_group_honor_info";
  ActionName2["GetCookies"] = "get_cookies";
  ActionName2["GetCSRF"] = "get_csrf_token";
  ActionName2["GetCredentials"] = "get_credentials";
  ActionName2["GetRecord"] = "get_record";
  ActionName2["GetImage"] = "get_image";
  ActionName2["CanSendImage"] = "can_send_image";
  ActionName2["CanSendRecord"] = "can_send_record";
  ActionName2["GetStatus"] = "get_status";
  ActionName2["GetVersionInfo"] = "get_version_info";
  ActionName2["SetQQProfile"] = "set_qq_profile";
  ActionName2["GoCQHTTP_GetModelShow"] = "_get_model_show";
  ActionName2["GoCQHTTP_SetModelShow"] = "_set_model_show";
  ActionName2["GetOnlineClient"] = "get_online_clients";
  ActionName2["GoCQHTTP_DeleteFriend"] = "delete_friend";
  ActionName2["GoCQHTTP_MarkMsgAsRead"] = "mark_msg_as_read";
  ActionName2["GoCQHTTP_SendGroupForwardMsg"] = "send_group_forward_msg";
  ActionName2["GoCQHTTP_SendPrivateForwardMsg"] = "send_private_forward_msg";
  ActionName2["GoCQHTTP_GetGroupMsgHistory"] = "get_group_msg_history";
  ActionName2["OCRImage"] = "ocr_image";
  ActionName2["IOCRImage"] = ".ocr_image";
  ActionName2["GetGroupSystemMsg"] = "get_group_system_msg";
  ActionName2["GoCQHTTP_GetEssenceMsg"] = "get_essence_msg_list";
  ActionName2["GoCQHTTP_GetGroupAtAllRemain"] = "get_group_at_all_remain";
  ActionName2["SetGroupPortrait"] = "set_group_portrait";
  ActionName2["SetEssenceMsg"] = "set_essence_msg";
  ActionName2["DelEssenceMsg"] = "delete_essence_msg";
  ActionName2["GoCQHTTP_SendGroupNotice"] = "_send_group_notice";
  ActionName2["GoCQHTTP_GetGroupNotice"] = "_get_group_notice";
  ActionName2["GoCQHTTP_UploadGroupFile"] = "upload_group_file";
  ActionName2["GOCQHTTP_DeleteGroupFile"] = "delete_group_file";
  ActionName2["GoCQHTTP_CreateGroupFileFolder"] = "create_group_file_folder";
  ActionName2["GoCQHTTP_DeleteGroupFileFolder"] = "delete_group_folder";
  ActionName2["GoCQHTTP_GetGroupFileSystemInfo"] = "get_group_file_system_info";
  ActionName2["GoCQHTTP_GetGroupRootFiles"] = "get_group_root_files";
  ActionName2["GoCQHTTP_GetGroupFilesByFolder"] = "get_group_files_by_folder";
  ActionName2["GOCQHTTP_GetGroupFileUrl"] = "get_group_file_url";
  ActionName2["GOCQHTTP_UploadPrivateFile"] = "upload_private_file";
  ActionName2["GoCQHTTP_DownloadFile"] = "download_file";
  ActionName2["GoCQHTTP_CheckUrlSafely"] = "check_url_safely";
  ActionName2["GoCQHTTP_GetWordSlices"] = ".get_word_slices";
  ActionName2["GoCQHTTP_HandleQuickAction"] = ".handle_quick_operation";
  ActionName2["Unknown"] = "unknown";
  ActionName2["SharePeer"] = "ArkSharePeer";
  ActionName2["ShareGroupEx"] = "ArkShareGroup";
  ActionName2["GetRobotUinRange"] = "get_robot_uin_range";
  ActionName2["SetOnlineStatus"] = "set_online_status";
  ActionName2["GetFriendsWithCategory"] = "get_friends_with_category";
  ActionName2["SetQQAvatar"] = "set_qq_avatar";
  ActionName2["GetFile"] = "get_file";
  ActionName2["ForwardFriendSingleMsg"] = "forward_friend_single_msg";
  ActionName2["ForwardGroupSingleMsg"] = "forward_group_single_msg";
  ActionName2["TranslateEnWordToZn"] = "translate_en2zh";
  ActionName2["SetMsgEmojiLike"] = "set_msg_emoji_like";
  ActionName2["GoCQHTTP_SendForwardMsg"] = "send_forward_msg";
  ActionName2["MarkPrivateMsgAsRead"] = "mark_private_msg_as_read";
  ActionName2["MarkGroupMsgAsRead"] = "mark_group_msg_as_read";
  ActionName2["GetFriendMsgHistory"] = "get_friend_msg_history";
  ActionName2["CreateCollection"] = "create_collection";
  ActionName2["GetCollectionList"] = "get_collection_list";
  ActionName2["SetLongNick"] = "set_self_longnick";
  ActionName2["GetRecentContact"] = "get_recent_contact";
  ActionName2["_MarkAllMsgAsRead"] = "_mark_all_as_read";
  ActionName2["GetProfileLike"] = "get_profile_like";
  ActionName2["FetchCustomFace"] = "fetch_custom_face";
  ActionName2["FetchEmojiLike"] = "fetch_emoji_like";
  ActionName2["SetInputStatus"] = "set_input_status";
  ActionName2["GetGroupInfoEx"] = "get_group_info_ex";
  ActionName2["GetGroupIgnoreAddRequest"] = "get_group_ignore_add_request";
  ActionName2["DelGroupNotice"] = "_del_group_notice";
  ActionName2["FetchUserProfileLike"] = "fetch_user_profile_like";
  ActionName2["FriendPoke"] = "friend_poke";
  ActionName2["GroupPoke"] = "group_poke";
  ActionName2["GetPacketStatus"] = "nc_get_packet_status";
  ActionName2["GetUserStatus"] = "nc_get_user_status";
  ActionName2["GetRkey"] = "nc_get_rkey";
  ActionName2["GetGroupShutList"] = "get_group_shut_list";
  ActionName2["GetGuildList"] = "get_guild_list";
  ActionName2["GetGuildProfile"] = "get_guild_service_profile";
  ActionName2["GetGroupIgnoredNotifies"] = "get_group_ignored_notifies";
  ActionName2["SetGroupSign"] = "set_group_sign";
  return ActionName2;
})(ActionName || {});

class OB11Response {
  static res(data, status, retcode, message = "") {
    return {
      status,
      retcode,
      data,
      message,
      wording: message,
      echo: null
    };
  }
  static ok(data, echo = null) {
    const res = OB11Response.res(data, "ok", 0);
    if (!isNull(echo)) {
      res.echo = echo;
    }
    return res;
  }
  static error(err, retcode, echo = null) {
    const res = OB11Response.res(null, "failed", retcode, err);
    if (!isNull(echo)) {
      res.echo = echo;
    }
    return res;
  }
}

var LifeCycleSubType = /* @__PURE__ */ ((LifeCycleSubType2) => {
  LifeCycleSubType2["ENABLE"] = "enable";
  LifeCycleSubType2["DISABLE"] = "disable";
  LifeCycleSubType2["CONNECT"] = "connect";
  return LifeCycleSubType2;
})(LifeCycleSubType || {});
class OB11LifeCycleEvent extends OB11BaseMetaEvent {
  meta_event_type = "lifecycle";
  sub_type;
  constructor(core, subType) {
    super(core);
    this.sub_type = subType;
  }
}

class OB11ActiveWebSocketAdapter {
  constructor(url, reconnectIntervalInMillis, heartbeatIntervalInMillis, token, core, actions) {
    this.url = url;
    this.reconnectIntervalInMillis = reconnectIntervalInMillis;
    this.heartbeatIntervalInMillis = heartbeatIntervalInMillis;
    this.token = token;
    this.core = core;
    this.actions = actions;
    this.logger = core.context.logger;
  }
  isClosed = false;
  logger;
  connection = null;
  heartbeatRef = null;
  onEvent(event) {
    if (this.connection && this.connection.readyState === WebSocket$1.OPEN) {
      this.connection.send(JSON.stringify(event));
    }
  }
  async open() {
    if (this.connection) {
      return;
    }
    this.heartbeatRef = setInterval(() => {
      if (this.connection && this.connection.readyState === WebSocket$1.OPEN) {
        this.connection.send(JSON.stringify(new OB11HeartbeatEvent(this.core, this.heartbeatIntervalInMillis, this.core.selfInfo.online, true)));
      }
    }, this.heartbeatIntervalInMillis);
    await this.tryConnect();
  }
  close() {
    if (this.isClosed) {
      this.logger.logDebug("Cannot close a closed WebSocket connection");
      return;
    }
    this.isClosed = true;
    if (this.connection) {
      this.connection.close();
      this.connection = null;
    }
    if (this.heartbeatRef) {
      clearInterval(this.heartbeatRef);
      this.heartbeatRef = null;
    }
  }
  checkStateAndReply(data) {
    if (this.connection && this.connection.readyState === WebSocket$1.OPEN) {
      this.connection.send(JSON.stringify(data));
    }
  }
  async tryConnect() {
    if (!this.connection && !this.isClosed) {
      let isClosedByError = false;
      this.connection = new WebSocket$1(this.url, {
        maxPayload: 1024 * 1024 * 1024,
        handshakeTimeout: 2e3,
        perMessageDeflate: false,
        headers: {
          "X-Self-ID": this.core.selfInfo.uin,
          "Authorization": `Bearer ${this.token}`,
          "x-client-role": "Universal",
          // koishi-adapter-onebot 需要这个字段
          "User-Agent": "OneBot/11"
        }
      });
      this.connection.on("ping", () => {
        this.connection?.pong();
      });
      this.connection.on("pong", () => {
      });
      this.connection.on("open", () => {
        try {
          this.connectEvent(this.core);
        } catch (e) {
          this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Client] 发送连接生命周期失败", e);
        }
      });
      this.connection.on("message", (data) => {
        this.handleMessage(data);
      });
      this.connection.once("close", () => {
        if (!isClosedByError) {
          this.logger.logError.bind(this.logger)(`[OneBot] [WebSocket Client] 反向WebSocket (${this.url}) 连接意外关闭`);
          this.logger.logError.bind(this.logger)(`[OneBot] [WebSocket Client] 在 ${Math.floor(this.reconnectIntervalInMillis / 1e3)} 秒后尝试重新连接`);
          if (!this.isClosed) {
            this.connection = null;
            setTimeout(() => this.tryConnect(), this.reconnectIntervalInMillis);
          }
        }
      });
      this.connection.on("error", (err) => {
        isClosedByError = true;
        this.logger.logError.bind(this.logger)(`[OneBot] [WebSocket Client] 反向WebSocket (${this.url}) 连接错误`, err);
        this.logger.logError.bind(this.logger)(`[OneBot] [WebSocket Client] 在 ${Math.floor(this.reconnectIntervalInMillis / 1e3)} 秒后尝试重新连接`);
        if (!this.isClosed) {
          this.connection = null;
          setTimeout(() => this.tryConnect(), this.reconnectIntervalInMillis);
        }
      });
    }
  }
  connectEvent(core) {
    try {
      this.checkStateAndReply(new OB11LifeCycleEvent(core, LifeCycleSubType.CONNECT));
    } catch (e) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Client] 发送生命周期失败", e);
    }
  }
  async handleMessage(message) {
    let receiveData = { action: ActionName.Unknown, params: {} };
    let echo = void 0;
    try {
      receiveData = JSON.parse(message.toString());
      echo = receiveData.echo;
      this.logger.logDebug("[OneBot] [WebSocket Client] 收到正向Websocket消息", receiveData);
    } catch (e) {
      this.checkStateAndReply(OB11Response.error("json解析失败,请检查数据格式", 1400, echo));
      return;
    }
    receiveData.params = receiveData?.params ? receiveData.params : {};
    const action = this.actions.get(receiveData.action);
    if (!action) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Client] 发生错误", "不支持的api " + receiveData.action);
      this.checkStateAndReply(OB11Response.error("不支持的api " + receiveData.action, 1404, echo));
      return;
    }
    const retdata = await action.websocketHandle(receiveData.params, echo ?? "");
    const packet = Object.assign({}, retdata);
    this.checkStateAndReply(packet);
  }
}

var lib = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var vary$1 = {exports: {}};

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

vary$1.exports = vary;
vary$1.exports.append = append;

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append (header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required')
  }

  if (!field) {
    throw new TypeError('field argument is required')
  }

  // get fields array
  var fields = !Array.isArray(field)
    ? parse$1(String(field))
    : field;

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name')
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header
  }

  // enumerate current values
  var val = header;
  var vals = parse$1(header.toLowerCase());

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*'
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val
        ? val + ', ' + fields[i]
        : fields[i];
    }
  }

  return val
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse$1 (header) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20: /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break
      case 0x2c: /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break
      default:
        end = i + 1;
        break
    }
  }

  // final token
  list.push(header.substring(start, end));

  return list
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary (res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required')
  }

  // get existing header
  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val)
    ? val.join(', ')
    : String(val);

  // set new header
  if ((val = append(header, field))) {
    res.setHeader('Vary', val);
  }
}

var varyExports = vary$1.exports;

(function () {

  var assign = objectAssign;
  var vary = varyExports;

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
      headers = [],
      isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin);
      // reflect origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;
    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }
    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }
    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }
    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }
    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }
    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
      method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureMethods(options));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options));
      headers.push(configureExposedHeaders(options));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;
    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function (req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function (origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }

  // can pass either an options hash, an options delegate, or nothing
  lib.exports = middlewareWrapper;

}());

var libExports = lib.exports;
const cors = /*@__PURE__*/getDefaultExportFromCjs(libExports);

class OB11PassiveHttpAdapter {
  constructor(port, token, core, actions) {
    this.port = port;
    this.token = token;
    this.core = core;
    this.actions = actions;
  }
  app;
  server;
  isOpen = false;
  onEvent() {
  }
  open() {
    try {
      if (this.isOpen) {
        this.core.context.logger.logError("Cannot open a closed HTTP server");
        return;
      }
      if (!this.isOpen) {
        this.initializeServer();
        this.isOpen = true;
      }
    } catch (e) {
      this.core.context.logger.logError(`[OneBot] [HTTP Server Adapter] Boot Error: ${e}`);
    }
  }
  async close() {
    this.isOpen = false;
    this.server?.close();
    this.app = void 0;
  }
  initializeServer() {
    this.app = express();
    this.server = http$2.createServer(this.app);
    this.app.use(cors());
    this.app.use(express.urlencoded({ extended: true, limit: "5000mb" }));
    this.app.use((req, res, next) => {
      req.headers["content-type"] = "application/json";
      const originalJson = express.json({ limit: "5000mb" });
      originalJson(req, res, (err) => {
        if (err) {
          return res.status(400).send("Invalid JSON");
        }
        next();
      });
    });
    this.app.use((req, res, next) => this.authorize(this.token, req, res, next));
    this.app.use((req, res) => this.handleRequest(req, res));
    this.server.listen(this.port, () => {
      this.core.context.logger.log(`[OneBot] [HTTP Server Adapter] Start On Port ${this.port}`);
    });
  }
  authorize(token, req, res, next) {
    if (!token || token.length == 0) return next();
    const HeaderClientToken = req.headers.authorization?.split("Bearer ").pop() || "";
    const QueryClientToken = req.query.access_token;
    const ClientToken = typeof QueryClientToken === "string" && QueryClientToken !== "" ? QueryClientToken : HeaderClientToken;
    if (ClientToken === token) {
      return next();
    } else {
      return res.status(403).send(JSON.stringify({ message: "token verify failed!" }));
    }
  }
  async handleRequest(req, res) {
    if (!this.isOpen) {
      this.core.context.logger.log(`[OneBot] [HTTP Server Adapter] Server is closed`);
      return res.json(OB11Response.error("Server is closed", 200));
    }
    let payload = req.body;
    if (req.method == "get") {
      payload = req.query;
    } else if (req.query) {
      payload = { ...req.query, ...req.body };
    }
    const actionName = req.path.split("/")[1];
    const action = this.actions.get(actionName);
    if (action) {
      try {
        const result = await action.handle(payload);
        return res.json(result);
      } catch (error) {
        return res.json(OB11Response.error(error?.stack?.toString() || error?.message || "Error Handle", 200));
      }
    } else {
      return res.json(OB11Response.error("不支持的api " + actionName, 200));
    }
  }
}

const E_CANCELED = new Error('request for lock canceled');

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED) {
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject) => {
            const task = { resolve, reject, weight, priority };
            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
            if (i === -1 && weight <= this._value) {
                // Needs immediate dispatch, skip the queue
                this._dispatchItem(task);
            }
            else {
                this._queue.splice(i + 1, 0, task);
            }
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            }
            finally {
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
        }
        else {
            return new Promise((resolve) => {
                if (!this._weightedWaiters[weight - 1])
                    this._weightedWaiters[weight - 1] = [];
                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
            });
        }
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry) => entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
        let called = false;
        return () => {
            if (called)
                return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) {
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                waiters.forEach((waiter) => waiter.resolve());
                this._weightedWaiters[weight - 1] = [];
            }
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i))
                    .forEach((waiter => waiter.resolve()));
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) &&
            weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for (let i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
            return i;
        }
    }
    return -1;
}

var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError) {
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}

class OB11PassiveWebSocketAdapter {
  constructor(ip, port, heartbeatInterval, token, core, actions) {
    this.actions = actions;
    this.core = core;
    this.logger = core.context.logger;
    this.heartbeatInterval = heartbeatInterval;
    this.wsServer = new WebSocketServer({
      port,
      host: ip,
      maxPayload: 1024 * 1024 * 1024
    });
    this.wsServer.on("connection", async (wsClient, wsReq) => {
      if (!this.isOpen) {
        wsClient.close();
        return;
      }
      this.authorize(token, wsClient, wsReq);
      const paramUrl = wsReq.url?.indexOf("?") !== -1 ? wsReq.url?.substring(0, wsReq.url?.indexOf("?")) : wsReq.url;
      const isApiConnect = paramUrl === "/api" || paramUrl === "/api/";
      if (!isApiConnect) {
        this.connectEvent(core, wsClient);
      }
      wsClient.on("error", (err) => this.logger.log("[OneBot] [WebSocket Server] Client Error:", err.message));
      wsClient.on("message", (message) => {
        this.handleMessage(wsClient, message).then().catch(this.logger.logError.bind(this.logger));
      });
      wsClient.on("ping", () => {
        wsClient.pong();
      });
      wsClient.on("pong", () => {
      });
      wsClient.once("close", () => {
        this.wsClientsMutex.runExclusive(async () => {
          const NormolIndex = this.wsClients.indexOf(wsClient);
          if (NormolIndex !== -1) {
            this.wsClients.splice(NormolIndex, 1);
          }
          const EventIndex = this.wsClientWithEvent.indexOf(wsClient);
          if (EventIndex !== -1) {
            this.wsClientWithEvent.splice(EventIndex, 1);
          }
        });
      });
      await this.wsClientsMutex.runExclusive(async () => {
        if (!isApiConnect) {
          this.wsClientWithEvent.push(wsClient);
        }
        this.wsClients.push(wsClient);
      });
    }).on("error", (err) => this.logger.log("[OneBot] [WebSocket Server] Server Error:", err.message));
  }
  wsServer;
  wsClients = [];
  wsClientsMutex = new Mutex();
  isOpen = false;
  hasBeenClosed = false;
  heartbeatInterval = 0;
  core;
  logger;
  heartbeatIntervalId = null;
  wsClientWithEvent = [];
  connectEvent(core, wsClient) {
    try {
      this.checkStateAndReply(new OB11LifeCycleEvent(core, LifeCycleSubType.CONNECT), wsClient);
    } catch (e) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Server] 发送生命周期失败", e);
    }
  }
  onEvent(event) {
    this.wsClientsMutex.runExclusive(async () => {
      this.wsClientWithEvent.forEach((wsClient) => {
        wsClient.send(JSON.stringify(event));
      });
    });
  }
  open() {
    if (this.isOpen) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Server] Cannot open a opened WebSocket server");
      return;
    }
    if (this.hasBeenClosed) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Server] Cannot open a WebSocket server that has been closed");
      return;
    }
    const addressInfo = this.wsServer.address();
    this.logger.log("[OneBot] [WebSocket Server] Server Started", typeof addressInfo === "string" ? addressInfo : addressInfo?.address + ":" + addressInfo?.port);
    this.isOpen = true;
    this.registerHeartBeat();
  }
  async close() {
    this.isOpen = false;
    this.wsServer.close((err) => {
      if (err) {
        this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Server] Error closing server:", err.message);
      } else {
        this.logger.log.bind(this.logger)("[OneBot] [WebSocket Server] Server Closed");
      }
    });
    if (this.heartbeatIntervalId) {
      clearInterval(this.heartbeatIntervalId);
      this.heartbeatIntervalId = null;
    }
    await this.wsClientsMutex.runExclusive(async () => {
      this.wsClients.forEach((wsClient) => {
        wsClient.close();
      });
      this.wsClients = [];
      this.wsClientWithEvent = [];
    });
  }
  registerHeartBeat() {
    this.heartbeatIntervalId = setInterval(() => {
      this.wsClientsMutex.runExclusive(async () => {
        this.wsClients.forEach((wsClient) => {
          if (wsClient.readyState === WebSocket$1.OPEN) {
            wsClient.send(JSON.stringify(new OB11HeartbeatEvent(this.core, this.heartbeatInterval, this.core.selfInfo.online, true)));
          }
        });
      });
    }, this.heartbeatInterval);
  }
  authorize(token, wsClient, wsReq) {
    if (!token || token.length == 0) return;
    const QueryClientToken = urlParse.parse(wsReq?.url || "", true).query.access_token;
    const HeaderClientToken = wsReq.headers.authorization?.split("Bearer ").pop() || "";
    const ClientToken = typeof QueryClientToken === "string" && QueryClientToken !== "" ? QueryClientToken : HeaderClientToken;
    if (ClientToken === token) {
      return;
    }
    wsClient.send(JSON.stringify(OB11Response.res(null, "failed", 1403, "token验证失败")));
    wsClient.close();
  }
  checkStateAndReply(data, wsClient) {
    if (wsClient.readyState === WebSocket$1.OPEN) {
      wsClient.send(JSON.stringify(data));
    }
  }
  async handleMessage(wsClient, message) {
    let receiveData = { action: ActionName.Unknown, params: {} };
    let echo = void 0;
    try {
      receiveData = JSON.parse(message.toString());
      echo = receiveData.echo;
    } catch (e) {
      this.checkStateAndReply(OB11Response.error("json解析失败,请检查数据格式", 1400, echo), wsClient);
      return;
    }
    receiveData.params = receiveData?.params ? receiveData.params : {};
    const action = this.actions.get(receiveData.action);
    if (!action) {
      this.logger.logError.bind(this.logger)("[OneBot] [WebSocket Client] 发生错误", "不支持的api " + receiveData.action);
      this.checkStateAndReply(OB11Response.error("不支持的api " + receiveData.action, 1404, echo), wsClient);
      return;
    }
    const retdata = await action.websocketHandle(receiveData.params, echo ?? "");
    const packet = Object.assign({}, retdata);
    this.checkStateAndReply(packet, wsClient);
  }
}

class OB11NetworkManager {
  adapters = [];
  async openAllAdapters() {
    return Promise.all(this.adapters.map((adapter) => adapter.open()));
  }
  async emitEvent(event) {
    return Promise.all(this.adapters.map((adapter) => adapter.onEvent(event)));
  }
  registerAdapter(adapter) {
    this.adapters.push(adapter);
  }
  async registerAdapterAndOpen(adapter) {
    this.registerAdapter(adapter);
    await adapter.open();
  }
  async closeSomeAdapters(adaptersToClose) {
    this.adapters = this.adapters.filter((adapter) => !adaptersToClose.includes(adapter));
    await Promise.all(adaptersToClose.map((adapter) => adapter.close()));
  }
  /**
   * Close all adapters that satisfy the predicate.
   */
  async closeAdapterByPredicate(closeFilter) {
    await this.closeSomeAdapters(this.adapters.filter(closeFilter));
  }
  async closeAllAdapters() {
    await Promise.all(this.adapters.map((adapter) => adapter.close()));
    this.adapters = [];
  }
}

class OB11BaseNoticeEvent extends OB11BaseEvent {
  post_type = EventType.NOTICE;
}

class OB11PokeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "poke";
  target_id = 0;
  user_id = 0;
}
class OB11FriendPokeEvent extends OB11PokeEvent {
  raw_info;
  //raw_message nb等框架标准为string
  constructor(core, user_id, target_id, raw_message) {
    super(core);
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11GroupPokeEvent extends OB11PokeEvent {
  group_id;
  raw_info;
  //raw_message nb等框架标准为string
  constructor(core, group_id, user_id = 0, target_id = 0, raw_message) {
    super(core);
    this.group_id = group_id;
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}

class OneBotFriendApi {
  obContext;
  core;
  friendList = /* @__PURE__ */ new Map();
  //此处作为缓存 uin->info
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  //使用前预先判断 busiId 1061
  async parsePrivatePokeEvent(grayTipElement) {
    const json = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
    let pokedetail = json.items;
    pokedetail = pokedetail.filter((item) => item.uid);
    if (pokedetail.length == 2) {
      return new OB11FriendPokeEvent(
        this.core,
        parseInt(await this.core.apis.UserApi.getUinByUidV2(pokedetail[0].uid)),
        parseInt(await this.core.apis.UserApi.getUinByUidV2(pokedetail[1].uid)),
        pokedetail
      );
    }
    return void 0;
  }
}

class OB11GroupNoticeEvent extends OB11BaseNoticeEvent {
  group_id;
  user_id;
  constructor(core, group_id, user_id) {
    super(core);
    this.group_id = group_id;
    this.user_id = user_id;
  }
}

class OB11GroupBanEvent extends OB11GroupNoticeEvent {
  notice_type = "group_ban";
  operator_id;
  duration;
  sub_type;
  constructor(core, groupId, userId, operatorId, duration, sub_type) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.duration = duration;
    this.sub_type = sub_type;
  }
}

class OB11GroupIncreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_increase";
  operator_id;
  sub_type;
  constructor(core, groupId, userId, operatorId, subType = "approve") {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}

class OB11GroupDecreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_decrease";
  sub_type = "leave";
  // TODO: 实现其他几种子类型的识别 ("leave" | "kick" | "kick_me")
  operator_id;
  constructor(core, groupId, userId, operatorId, subType = "leave") {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}

var validator$2 = {};

var util$4 = {};

(function (exports) {

	const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
	const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
	const regexName = new RegExp('^' + nameRegexp + '$');

	const getAllMatches = function(string, regex) {
	  const matches = [];
	  let match = regex.exec(string);
	  while (match) {
	    const allmatches = [];
	    allmatches.startIndex = regex.lastIndex - match[0].length;
	    const len = match.length;
	    for (let index = 0; index < len; index++) {
	      allmatches.push(match[index]);
	    }
	    matches.push(allmatches);
	    match = regex.exec(string);
	  }
	  return matches;
	};

	const isName = function(string) {
	  const match = regexName.exec(string);
	  return !(match === null || typeof match === 'undefined');
	};

	exports.isExist = function(v) {
	  return typeof v !== 'undefined';
	};

	exports.isEmptyObject = function(obj) {
	  return Object.keys(obj).length === 0;
	};

	/**
	 * Copy all the properties of a into b.
	 * @param {*} target
	 * @param {*} a
	 */
	exports.merge = function(target, a, arrayMode) {
	  if (a) {
	    const keys = Object.keys(a); // will return an array of own properties
	    const len = keys.length; //don't make it inline
	    for (let i = 0; i < len; i++) {
	      if (arrayMode === 'strict') {
	        target[keys[i]] = [ a[keys[i]] ];
	      } else {
	        target[keys[i]] = a[keys[i]];
	      }
	    }
	  }
	};
	/* exports.merge =function (b,a){
	  return Object.assign(b,a);
	} */

	exports.getValue = function(v) {
	  if (exports.isExist(v)) {
	    return v;
	  } else {
	    return '';
	  }
	};

	// const fakeCall = function(a) {return a;};
	// const fakeCallNoReturn = function() {};

	exports.isName = isName;
	exports.getAllMatches = getAllMatches;
	exports.nameRegexp = nameRegexp; 
} (util$4));

const util$3 = util$4;

const defaultOptions$2 = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
validator$2.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions$2, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1); else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) ; else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util$3.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util$3.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util$3.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}

var OptionsBuilder = {};

const defaultOptions$1 = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions$1 = function(options) {
    return Object.assign({}, defaultOptions$1, options);
};

OptionsBuilder.buildOptions = buildOptions$1;
OptionsBuilder.defaultOptions = defaultOptions$1;

class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else {
      this.child.push( { [node.tagname]: node.child });
    }
  };
}

var xmlNode$1 = XmlNode;

const util$2 = util$4;

//TODO: handle comments
function readDocType$1(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else {
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else {
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = "";
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util$2.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

var DocTypeReader = readDocType$1;

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber$1(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else {
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else {//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else { //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
var strnum = toNumber$1;

function getIgnoreAttributesFn$2(ignoreAttributes) {
    if (typeof ignoreAttributes === 'function') {
        return ignoreAttributes
    }
    if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
            for (const pattern of ignoreAttributes) {
                if (typeof pattern === 'string' && attrName === pattern) {
                    return true
                }
                if (pattern instanceof RegExp && pattern.test(attrName)) {
                    return true
                }
            }
        }
    }
    return () => false
}

var ignoreAttributes = getIgnoreAttributesFn$2;

///@ts-check

const util$1 = util$4;
const xmlNode = xmlNode$1;
const readDocType = DocTypeReader;
const toNumber = strnum;
const getIgnoreAttributesFn$1 = ignoreAttributes;

// const regx =
//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
//   .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

let OrderedObjParser$1 = class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue$1;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn$1(this.options.ignoreAttributes);
  }

};

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    };
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else {
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else {
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util$1.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else {
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1);
          this.tagsNodeStack.pop();
        }else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags);else {
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath);

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.");
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if(val == undefined) val = "";

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else {
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            
            i = result.closeIndex;
          }
          //normal tag
          else {
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath);
        }else {
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else {
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if(result === false);else if(typeof result === "string"){
    childNode.tagname = result;
    currentNode.addChild(childNode);
  }else {
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue$1 = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else {
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " ";
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else {
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }

  const rawTagName = tagName;
  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.");
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.");
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>');

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util$1.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


var OrderedObjParser_1 = OrderedObjParser$1;

var node2json = {};

/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify$1(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName$1(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else {
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else {
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName$1(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
node2json.prettify = prettify$1;

const { buildOptions} = OptionsBuilder;
const OrderedObjParser = OrderedObjParser_1;
const { prettify} = node2json;
const validator$1 = validator$2;

let XMLParser$1 = class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string");else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else {
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator$1.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else {
            this.externalEntities[key] = value;
        }
    }
};

var XMLParser_1 = XMLParser$1;

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if(tagName === undefined) continue;

        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if(!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            if(!attrMap.hasOwnProperty(attr)) continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
var orderedJs2Xml = toXml;

//parse Empty Node as self closing node
const buildFromOrderedJs = orderedJs2Xml;
const getIgnoreAttributesFn = ignoreAttributes;

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode;

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      };
    }
    return this.j2x(jObj, 0, []).val;
  }
};

Builder.prototype.j2x = function(jObj, level, ajPath) {
  let attrStr = '';
  let val = '';
  const jPath = ajPath.join('.');
  for (let key in jObj) {
    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node only if it is not an attribute
      if (this.isAttribute(key)) {
        val += '';
      }
    } else if (jObj[key] === null) {
      // null attribute should be ignored by the attribute list, but should not cause the tag closing
      if (this.isAttribute(key)) {
        val += '';
      } else if (key[0] === '?') {
        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      } else {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      }
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr && !this.ignoreAttributesFn(attr, jPath)) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      } else if (!attr) {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') ; else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup){
            const result = this.j2x(item, level + 1, ajPath.concat(key));
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr;
            }
          }else {
            listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, '', level);
          }
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
};

function processTextOrObjNode (object, key, level, ajPath) {
  const result = this.j2x(object, level + 1, ajPath.concat(key));
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else {

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    // attrStr is an empty string in case the attribute came as undefined or null
    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
};

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/";
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else {
    closeTag = `></${key}`;
  }
  return closeTag;
};

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else {
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else {
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
};

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

var json2xml = Builder;

const validator = validator$2;
const XMLParser = XMLParser_1;
const XMLBuilder = json2xml;

var fxp = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
};

const fastXmlParser = /*@__PURE__*/getDefaultExportFromCjs(fxp);

class OB11GroupMsgEmojiLikeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_msg_emoji_like";
  message_id;
  likes;
  constructor(core, groupId, userId, messageId, likes) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.message_id = messageId;
    this.likes = likes;
  }
}

class OB11GroupCardEvent extends OB11GroupNoticeEvent {
  notice_type = "group_card";
  card_new;
  card_old;
  constructor(core, groupId, userId, cardNew, cardOld) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.card_new = cardNew;
    this.card_old = cardOld;
  }
}

class OB11GroupUploadNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_upload";
  file;
  constructor(core, groupId, userId, file) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.file = file;
  }
}

class OB11GroupEssenceEvent extends OB11GroupNoticeEvent {
  notice_type = "essence";
  message_id;
  sender_id;
  operator_id;
  sub_type = "add";
  constructor(core, groupId, message_id, sender_id, operator_id) {
    super(core, groupId, sender_id);
    this.group_id = groupId;
    this.operator_id = operator_id;
    this.message_id = message_id;
    this.sender_id = sender_id;
  }
}

class OB11GroupTitleEvent extends OB11GroupNoticeEvent {
  notice_type = "notify";
  sub_type = "title";
  title;
  constructor(core, groupId, userId, title) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.title = title;
  }
}

class OneBotGroupApi {
  obContext;
  core;
  GroupMemberList = /* @__PURE__ */ new Map();
  //此处作为缓存 group_id->memberUin->info
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parseGroupEvent(msg) {
    const logger = this.core.context.logger;
    if (msg.chatType !== ChatType.KCHATTYPEGROUP) {
      return;
    }
    if (msg.senderUin && msg.senderUin !== "0") {
      const member = await this.core.apis.GroupApi.getGroupMember(msg.peerUid, msg.senderUin);
      if (member && member.cardName !== msg.sendMemberName) {
        const newCardName = msg.sendMemberName || "";
        const event = new OB11GroupCardEvent(this.core, parseInt(msg.peerUid), parseInt(msg.senderUin), newCardName, member.cardName);
        member.cardName = newCardName;
        return event;
      }
    }
    for (const element of msg.elements) {
      if (element.grayTipElement && element.grayTipElement.groupElement) {
        const groupElement = element.grayTipElement.groupElement;
        if (groupElement.type == TipGroupElementType.memberIncrease) {
          const MemberIncreaseEvent = await this.obContext.apis.GroupApi.parseGroupMemberIncreaseEvent(msg.peerUid, element.grayTipElement);
          if (MemberIncreaseEvent) return MemberIncreaseEvent;
        } else if (groupElement.type === TipGroupElementType.ban) {
          const BanEvent = await this.obContext.apis.GroupApi.parseGroupBanEvent(msg.peerUid, element.grayTipElement);
          if (BanEvent) return BanEvent;
        } else if (groupElement.type == TipGroupElementType.kicked) {
          this.core.apis.GroupApi.quitGroup(msg.peerUid).then();
          try {
            const KickEvent = await this.obContext.apis.GroupApi.parseGroupKickEvent(msg.peerUid, element.grayTipElement);
            if (KickEvent) return KickEvent;
          } catch (e) {
            return new OB11GroupDecreaseEvent(
              this.core,
              parseInt(msg.peerUid),
              parseInt(this.core.selfInfo.uin),
              0,
              "leave"
            );
          }
        }
      } else if (element.fileElement) {
        return new OB11GroupUploadNoticeEvent(
          this.core,
          parseInt(msg.peerUid),
          parseInt(msg.senderUin || ""),
          {
            id: FileNapCatOneBotUUID.encode({
              chatType: ChatType.KCHATTYPEGROUP,
              peerUid: msg.peerUid
            }, msg.msgId, element.elementId, element.fileElement.fileUuid, "." + element.fileElement.fileName),
            url: pathToFileURL(element.fileElement.filePath).href,
            name: element.fileElement.fileName,
            size: parseInt(element.fileElement.fileSize),
            busid: element.fileElement.fileBizId || 0
          }
        );
      }
      if (element.grayTipElement) {
        if (element.grayTipElement.xmlElement?.templId === "10382") {
          const emojiLikeEvent = await this.obContext.apis.GroupApi.parseGroupEmojiLikeEventByGrayTip(msg.peerUid, element.grayTipElement);
          if (emojiLikeEvent) return emojiLikeEvent;
        }
        if (element.grayTipElement.subElementType == NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_XMLMSG) {
          const GroupIncreaseEvent = await this.obContext.apis.GroupApi.parseGroupIncreaseEvent(msg.peerUid, element.grayTipElement);
          if (GroupIncreaseEvent) return GroupIncreaseEvent;
        } else if (element.grayTipElement.subElementType == NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_JSON) {
          const json = JSON.parse(element.grayTipElement.jsonGrayTipElement.jsonStr);
          if (element.grayTipElement.jsonGrayTipElement.busiId == 1061) {
            const pokedetail = json.items;
            const poke_uid = pokedetail.filter((item) => item.uid);
            if (poke_uid.length == 2) {
              return new OB11GroupPokeEvent(
                this.core,
                parseInt(msg.peerUid),
                parseInt(await this.core.apis.UserApi.getUinByUidV2(poke_uid[0].uid)),
                parseInt(await this.core.apis.UserApi.getUinByUidV2(poke_uid[1].uid)),
                pokedetail
              );
            }
          }
          if (element.grayTipElement.jsonGrayTipElement.busiId == 2401) {
            const searchParams = new URL(json.items[0].jp).searchParams;
            const msgSeq = searchParams.get("msgSeq");
            const Group = searchParams.get("groupCode");
            if (!Group) return;
            const Peer = {
              guildId: "",
              chatType: ChatType.KCHATTYPEGROUP,
              peerUid: Group
            };
            const msgData = await this.core.apis.MsgApi.getMsgsBySeqAndCount(Peer, msgSeq.toString(), 1, true, true);
            const msgList = (await this.core.apis.WebApi.getGroupEssenceMsgAll(Group)).flatMap((e) => e.data.msg_list);
            const realMsg = msgList.find((e) => e.msg_seq.toString() == msgSeq);
            return new OB11GroupEssenceEvent(
              this.core,
              parseInt(msg.peerUid),
              MessageUnique.getShortIdByMsgId(msgData.msgList[0].msgId),
              parseInt(msgData.msgList[0].senderUin),
              parseInt(realMsg?.add_digest_uin ?? "0")
            );
          }
          if (element.grayTipElement.jsonGrayTipElement.busiId == 2407) {
            const type = json.items[json.items.length - 1]?.txt;
            if (type === "头衔") {
              const memberUin = json.items[1].param[0];
              const title = json.items[3].txt;
              logger.logDebug("收到群成员新头衔消息", json);
              return new OB11GroupTitleEvent(
                this.core,
                parseInt(msg.peerUid),
                parseInt(memberUin),
                title
              );
            } else if (type === "移出") {
              logger.logDebug("收到机器人被踢消息", json);
              return;
            } else {
              logger.logWarn("收到未知的灰条消息", json);
            }
          }
        }
      }
    }
  }
  async parseGroupBanEvent(GroupCode, grayTipElement) {
    const groupElement = grayTipElement?.groupElement;
    if (!groupElement?.shutUp) return void 0;
    const memberUid = groupElement.shutUp.member.uid;
    const adminUid = groupElement.shutUp.admin.uid;
    let memberUin;
    let duration = parseInt(groupElement.shutUp.duration);
    const subType = duration > 0 ? "ban" : "lift_ban";
    if (memberUid) {
      memberUin = (await this.core.apis.GroupApi.getGroupMember(GroupCode, memberUid))?.uin || "";
    } else {
      memberUin = "0";
      if (duration > 0) {
        duration = -1;
      }
    }
    const adminUin = (await this.core.apis.GroupApi.getGroupMember(GroupCode, adminUid))?.uin;
    if (memberUin && adminUin) {
      return new OB11GroupBanEvent(
        this.core,
        parseInt(GroupCode),
        parseInt(memberUin),
        parseInt(adminUin),
        duration,
        subType
      );
    }
    return void 0;
  }
  async parseGroupIncreaseEvent(GroupCode, grayTipElement) {
    this.core.context.logger.logDebug("收到新人被邀请进群消息", grayTipElement);
    const xmlElement = grayTipElement.xmlElement;
    if (xmlElement?.content) {
      const regex = /jp="(\d+)"/g;
      const matches = [];
      let match = null;
      while ((match = regex.exec(xmlElement.content)) !== null) {
        matches.push(match[1]);
      }
      if (matches.length === 2) {
        const [inviter, invitee] = matches;
        return new OB11GroupIncreaseEvent(
          this.core,
          parseInt(GroupCode),
          parseInt(invitee),
          parseInt(inviter),
          "invite"
        );
      }
    }
    return void 0;
  }
  async parseGroupMemberIncreaseEvent(GroupCode, grayTipElement) {
    const groupElement = grayTipElement?.groupElement;
    if (!groupElement) return void 0;
    const member = await this.core.apis.UserApi.getUserDetailInfo(groupElement.memberUid);
    const memberUin = member?.uin;
    const adminMember = await this.core.apis.GroupApi.getGroupMember(GroupCode, groupElement.adminUid);
    if (memberUin) {
      const operatorUin = adminMember?.uin || memberUin;
      return new OB11GroupIncreaseEvent(
        this.core,
        parseInt(GroupCode),
        parseInt(memberUin),
        parseInt(operatorUin)
      );
    } else {
      return void 0;
    }
  }
  async parseGroupKickEvent(GroupCode, grayTipElement) {
    const groupElement = grayTipElement?.groupElement;
    if (!groupElement) return void 0;
    const adminUin = (await this.core.apis.GroupApi.getGroupMember(GroupCode, groupElement.adminUid))?.uin || await this.core.apis.UserApi.getUidByUinV2(groupElement.adminUid);
    if (adminUin) {
      return new OB11GroupDecreaseEvent(
        this.core,
        parseInt(GroupCode),
        parseInt(this.core.selfInfo.uin),
        parseInt(adminUin),
        "kick_me"
      );
    }
    return void 0;
  }
  async parseGroupEmojiLikeEventByGrayTip(groupCode, grayTipElement) {
    const emojiLikeData = new fastXmlParser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: ""
    }).parse(grayTipElement.xmlElement.content);
    this.core.context.logger.logDebug("收到表情回应我的消息", emojiLikeData);
    const senderUin = emojiLikeData.gtip.qq.jp;
    const msgSeq = emojiLikeData.gtip.url.msgseq;
    const emojiId = emojiLikeData.gtip.face.id;
    return await this.createGroupEmojiLikeEvent(groupCode, senderUin, msgSeq, emojiId);
  }
  async createGroupEmojiLikeEvent(groupCode, senderUin, msgSeq, emojiId) {
    const peer = {
      chatType: ChatType.KCHATTYPEGROUP,
      guildId: "",
      peerUid: groupCode
    };
    const replyMsgList = (await this.core.apis.MsgApi.queryFirstMsgBySeq(peer, msgSeq)).msgList;
    if (replyMsgList.length < 1) {
      return;
    }
    const replyMsg = replyMsgList[0];
    if (!replyMsg) {
      this.core.context.logger.logError.bind(this.core.context.logger)("解析表情回应消息失败: 未找到回应消息");
      return void 0;
    }
    return new OB11GroupMsgEmojiLikeEvent(
      this.core,
      parseInt(groupCode),
      parseInt(senderUin),
      MessageUnique.getShortIdByMsgId(replyMsg.msgId),
      [{
        emoji_id: emojiId,
        count: 1
      }]
    );
  }
}

const LikeDetail = new MessageType("likeDetail", [
  {
    no: 1,
    name: "txt",
    kind: "scalar",
    T: ScalarType.STRING
    /* string */
  },
  {
    no: 3,
    name: "uin",
    kind: "scalar",
    T: ScalarType.INT64
    /* int64 */
  },
  {
    no: 5,
    name: "nickname",
    kind: "scalar",
    T: ScalarType.STRING
    /* string */
  }
]);
const LikeMsg = new MessageType("likeMsg", [
  {
    no: 1,
    name: "times",
    kind: "scalar",
    T: ScalarType.INT32
    /* int32 */
  },
  {
    no: 2,
    name: "time",
    kind: "scalar",
    T: ScalarType.INT32
    /* int32 */
  },
  { no: 3, name: "detail", kind: "message", T: () => LikeDetail }
]);
const ProfileLikeSubTip = new MessageType("profileLikeSubTip", [
  { no: 14, name: "msg", kind: "message", T: () => LikeMsg }
]);
const ProfileLikeTip = new MessageType("profileLikeTip", [
  {
    no: 1,
    name: "msgType",
    kind: "scalar",
    T: ScalarType.INT32
    /* int32 */
  },
  {
    no: 2,
    name: "subType",
    kind: "scalar",
    T: ScalarType.INT32
    /* int32 */
  },
  { no: 203, name: "content", kind: "message", T: () => ProfileLikeSubTip }
]);
const SysMessageHeader = new MessageType("SysMessageHeader", [
  {
    no: 1,
    name: "PeerNumber",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 2,
    name: "PeerString",
    kind: "scalar",
    T: ScalarType.STRING
    /* string */
  },
  {
    no: 5,
    name: "Uin",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  { no: 6, name: "Uid", kind: "scalar", T: ScalarType.STRING, opt: true }
]);
const SysMessageMsgSpec = new MessageType("SysMessageMsgSpec", [
  {
    no: 1,
    name: "msgType",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 2,
    name: "subType",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 3,
    name: "subSubType",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 5,
    name: "msgSeq",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 6,
    name: "time",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 12,
    name: "msgId",
    kind: "scalar",
    T: ScalarType.UINT64
    /* uint64 */
  },
  {
    no: 13,
    name: "other",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  }
]);
const SysMessageBodyWrapper = new MessageType("SysMessageBodyWrapper", [
  {
    no: 2,
    name: "wrappedBody",
    kind: "scalar",
    T: ScalarType.BYTES
    /* bytes */
  }
]);
const SysMessage = new MessageType("SysMessage", [
  { no: 1, name: "header", kind: "message", T: () => SysMessageHeader, repeat: RepeatType.UNPACKED },
  { no: 2, name: "msgSpec", kind: "message", T: () => SysMessageMsgSpec, repeat: RepeatType.UNPACKED },
  { no: 3, name: "bodyWrapper", kind: "message", T: () => SysMessageBodyWrapper }
]);
function decodeProfileLikeTip(buffer) {
  const reader = new BinaryReader(buffer);
  return ProfileLikeTip.internalBinaryRead(reader, reader.len, { readUnknownField: true, readerFactory: () => new BinaryReader(buffer) });
}
function decodeSysMessage(buffer) {
  const reader = new BinaryReader(buffer);
  return SysMessage.internalBinaryRead(reader, reader.len, { readUnknownField: true, readerFactory: () => new BinaryReader(buffer) });
}

class OB11ProfileLikeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "profile_like";
  operator_id;
  operator_nick;
  times;
  time;
  constructor(core, operatorId, operatorNick, times, time) {
    super(core);
    this.operator_id = operatorId;
    this.operator_nick = operatorNick;
    this.times = times;
    this.time = time;
  }
}

class OneBotUserApi {
  obContext;
  core;
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parseLikeEvent(wrappedBody) {
    const likeTip = decodeProfileLikeTip(Uint8Array.from(wrappedBody));
    if (likeTip?.msgType !== 0 || likeTip?.subType !== 203) return;
    this.core.context.logger.logDebug("收到点赞通知消息");
    const likeMsg = likeTip.content.msg;
    if (!likeMsg) return;
    const detail = likeMsg.detail;
    if (!detail) return;
    const times = detail.txt.match(/\d+/) ?? "0";
    return new OB11ProfileLikeEvent(
      this.core,
      Number(detail.uin),
      detail.nickname,
      parseInt(times[0], 10),
      likeMsg.time
    );
  }
}

const sysface = [
	{
		QSid: "392",
		QDes: "/龙年快乐",
		IQLid: "392",
		AQLid: "392",
		EMCode: "10392",
		AniStickerType: 3,
		AniStickerPackId: "1",
		AniStickerId: "38"
	},
	{
		QSid: "393",
		QDes: "/新年中龙",
		IQLid: "393",
		AQLid: "393",
		EMCode: "10393",
		QHide: "1",
		AniStickerType: 3,
		AniStickerPackId: "1",
		AniStickerId: "39"
	},
	{
		QSid: "364",
		QDes: "/超级赞",
		IQLid: "364",
		AQLid: "364",
		EMCode: "10364",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "1",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "366",
		QDes: "/芒狗",
		IQLid: "366",
		AQLid: "366",
		EMCode: "10366",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "2",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "362",
		QDes: "/好兄弟",
		IQLid: "362",
		AQLid: "362",
		EMCode: "10362",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "3",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "397",
		QDes: "/抛媚眼",
		IQLid: "397",
		AQLid: "397",
		EMCode: "10397",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "4",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "396",
		QDes: "/狼狗",
		IQLid: "396",
		AQLid: "396",
		EMCode: "10396",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "5",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "360",
		QDes: "/亲亲",
		IQLid: "360",
		AQLid: "360",
		EMCode: "10360",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "6",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "361",
		QDes: "/狗狗笑哭",
		IQLid: "361",
		AQLid: "361",
		EMCode: "10361",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "7",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "363",
		QDes: "/狗狗可怜",
		IQLid: "363",
		AQLid: "363",
		EMCode: "10363",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "8",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "365",
		QDes: "/狗狗生气",
		IQLid: "365",
		AQLid: "365",
		EMCode: "10365",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "9",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "367",
		QDes: "/狗狗疑问",
		IQLid: "367",
		AQLid: "367",
		EMCode: "10367",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "10",
		AniStickerPackId: "2",
		AniStickerPackName: "汪汪"
	},
	{
		QSid: "399",
		QDes: "/tui",
		IQLid: "399",
		AQLid: "399",
		EMCode: "10399",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "1",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "398",
		QDes: "/超级ok",
		IQLid: "398",
		AQLid: "398",
		EMCode: "10398",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "2",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "373",
		QDes: "/忙",
		IQLid: "373",
		AQLid: "373",
		EMCode: "10373",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "3",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "370",
		QDes: "/祝贺",
		IQLid: "370",
		AQLid: "370",
		EMCode: "10370",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "4",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "375",
		QDes: "/超级鼓掌",
		IQLid: "375",
		AQLid: "375",
		EMCode: "10375",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "5",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "368",
		QDes: "/奥特笑哭",
		IQLid: "368",
		AQLid: "368",
		EMCode: "10368",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "6",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "369",
		QDes: "/彩虹",
		IQLid: "369",
		AQLid: "369",
		EMCode: "10369",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "7",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "371",
		QDes: "/冒泡",
		IQLid: "371",
		AQLid: "371",
		EMCode: "10371",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "8",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "372",
		QDes: "/气呼呼",
		IQLid: "372",
		AQLid: "372",
		EMCode: "10372",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "9",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "374",
		QDes: "/波波流泪",
		IQLid: "374",
		AQLid: "374",
		EMCode: "10374",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "10",
		AniStickerPackId: "6",
		AniStickerPackName: "噗噗星人"
	},
	{
		QSid: "382",
		QDes: "/emo",
		IQLid: "382",
		AQLid: "382",
		EMCode: "10382",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "1",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "383",
		QDes: "/企鹅爱心",
		IQLid: "383",
		AQLid: "383",
		EMCode: "10383",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "2",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "401",
		QDes: "/超级转圈",
		IQLid: "401",
		AQLid: "401",
		EMCode: "10401",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "3",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "400",
		QDes: "/快乐",
		IQLid: "400",
		AQLid: "400",
		EMCode: "10400",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "4",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "380",
		QDes: "/真棒",
		IQLid: "380",
		AQLid: "380",
		EMCode: "10380",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "5",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "381",
		QDes: "/路过",
		IQLid: "381",
		AQLid: "381",
		EMCode: "10381",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "6",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "379",
		QDes: "/企鹅流泪",
		IQLid: "379",
		AQLid: "379",
		EMCode: "10379",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "7",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "376",
		QDes: "/跺脚",
		IQLid: "376",
		AQLid: "376",
		EMCode: "10376",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "8",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "378",
		QDes: "/企鹅笑哭",
		IQLid: "378",
		AQLid: "378",
		EMCode: "10378",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "9",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "377",
		QDes: "/嗨",
		IQLid: "377",
		AQLid: "377",
		EMCode: "10377",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "10",
		AniStickerPackId: "5",
		AniStickerPackName: "企鹅"
	},
	{
		QSid: "403",
		QDes: "/出去玩",
		IQLid: "403",
		AQLid: "403",
		EMCode: "10403",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "1",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "402",
		QDes: "/别说话",
		IQLid: "402",
		AQLid: "402",
		EMCode: "10402",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "2",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "390",
		QDes: "/太头秃",
		IQLid: "390",
		AQLid: "390",
		EMCode: "10390",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "3",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "391",
		QDes: "/太沧桑",
		IQLid: "391",
		AQLid: "391",
		EMCode: "10391",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "4",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "388",
		QDes: "/太头疼",
		IQLid: "388",
		AQLid: "388",
		EMCode: "10388",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "5",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "389",
		QDes: "/太赞了",
		IQLid: "389",
		AQLid: "389",
		EMCode: "10389",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "6",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "386",
		QDes: "/呜呜呜",
		IQLid: "386",
		AQLid: "386",
		EMCode: "10386",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "7",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "385",
		QDes: "/太气了",
		IQLid: "385",
		AQLid: "385",
		EMCode: "10385",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "8",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "384",
		QDes: "/晚安",
		IQLid: "384",
		AQLid: "384",
		EMCode: "10384",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "9",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "387",
		QDes: "/太好笑",
		IQLid: "387",
		AQLid: "387",
		EMCode: "10387",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "10",
		AniStickerPackId: "4",
		AniStickerPackName: "QQ黄脸"
	},
	{
		QSid: "413",
		QDes: "/摇起来",
		IQLid: "413",
		AQLid: "413",
		EMCode: "10413",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "1",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "405",
		QDes: "/好运来",
		IQLid: "405",
		AQLid: "405",
		EMCode: "10405",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "2",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "404",
		QDes: "/闪亮登场",
		IQLid: "404",
		AQLid: "404",
		EMCode: "10404",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "3",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "406",
		QDes: "/姐是女王",
		IQLid: "406",
		AQLid: "406",
		EMCode: "10406",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "4",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "410",
		QDes: "/么么哒",
		IQLid: "410",
		AQLid: "410",
		EMCode: "10410",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "5",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "411",
		QDes: "/一起嗨",
		IQLid: "411",
		AQLid: "411",
		EMCode: "10411",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "6",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "407",
		QDes: "/我听听",
		IQLid: "407",
		AQLid: "407",
		EMCode: "10407",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "7",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "408",
		QDes: "/臭美",
		IQLid: "408",
		AQLid: "408",
		EMCode: "10408",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "8",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "412",
		QDes: "/开心",
		IQLid: "412",
		AQLid: "412",
		EMCode: "10412",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "9",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "409",
		QDes: "/送你花花",
		IQLid: "409",
		AQLid: "409",
		EMCode: "10409",
		QHide: "1",
		AniStickerType: 1,
		AniStickerId: "10",
		AniStickerPackId: "3",
		AniStickerPackName: "喜花妮"
	},
	{
		QSid: "394",
		QDes: "/新年大龙",
		IQLid: "394",
		AQLid: "394",
		EMCode: "10394",
		QHide: "1",
		AniStickerType: 3,
		AniStickerPackId: "1",
		AniStickerId: "40"
	},
	{
		QSid: "14",
		QDes: "/微笑",
		IQLid: "23",
		AQLid: "23",
		EMCode: "100"
	},
	{
		QSid: "1",
		QDes: "/撇嘴",
		IQLid: "40",
		AQLid: "40",
		EMCode: "101"
	},
	{
		QSid: "2",
		QDes: "/色",
		IQLid: "19",
		AQLid: "19",
		EMCode: "102"
	},
	{
		QSid: "3",
		QDes: "/发呆",
		IQLid: "43",
		AQLid: "43",
		EMCode: "103"
	},
	{
		QSid: "4",
		QDes: "/得意",
		IQLid: "21",
		AQLid: "21",
		EMCode: "104"
	},
	{
		QSid: "6",
		QDes: "/害羞",
		IQLid: "20",
		AQLid: "20",
		EMCode: "106"
	},
	{
		QSid: "7",
		QDes: "/闭嘴",
		IQLid: "104",
		AQLid: "106",
		EMCode: "107"
	},
	{
		QSid: "8",
		QDes: "/睡",
		IQLid: "35",
		AQLid: "35",
		EMCode: "108"
	},
	{
		QSid: "9",
		QDes: "/大哭",
		IQLid: "10",
		AQLid: "10",
		EMCode: "109"
	},
	{
		QSid: "5",
		QDes: "/流泪",
		IQLid: "9",
		AQLid: "9",
		EMCode: "105",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "16"
	},
	{
		QSid: "10",
		QDes: "/尴尬",
		IQLid: "25",
		AQLid: "25",
		EMCode: "110"
	},
	{
		QSid: "11",
		QDes: "/发怒",
		IQLid: "24",
		AQLid: "24",
		EMCode: "111"
	},
	{
		QSid: "12",
		QDes: "/调皮",
		IQLid: "1",
		AQLid: "1",
		EMCode: "112"
	},
	{
		QSid: "13",
		QDes: "/呲牙",
		IQLid: "0",
		AQLid: "0",
		EMCode: "113"
	},
	{
		QSid: "0",
		QDes: "/惊讶",
		IQLid: "33",
		AQLid: "33",
		EMCode: "114"
	},
	{
		QSid: "15",
		QDes: "/难过",
		IQLid: "32",
		AQLid: "32",
		EMCode: "115"
	},
	{
		QSid: "16",
		QDes: "/酷",
		IQLid: "12",
		AQLid: "12",
		EMCode: "116"
	},
	{
		QSid: "96",
		QDes: "/冷汗",
		IQLid: "27",
		AQLid: "27",
		EMCode: "117"
	},
	{
		QSid: "18",
		QDes: "/抓狂",
		IQLid: "13",
		AQLid: "13",
		EMCode: "118"
	},
	{
		QSid: "19",
		QDes: "/吐",
		IQLid: "22",
		AQLid: "22",
		EMCode: "119"
	},
	{
		QSid: "20",
		QDes: "/偷笑",
		IQLid: "3",
		AQLid: "3",
		EMCode: "120"
	},
	{
		QSid: "21",
		QDes: "/可爱",
		IQLid: "18",
		AQLid: "18",
		EMCode: "121"
	},
	{
		QSid: "22",
		QDes: "/白眼",
		IQLid: "30",
		AQLid: "30",
		EMCode: "122"
	},
	{
		QSid: "23",
		QDes: "/傲慢",
		IQLid: "31",
		AQLid: "31",
		EMCode: "123"
	},
	{
		QSid: "24",
		QDes: "/饥饿",
		IQLid: "79",
		AQLid: "81",
		EMCode: "124"
	},
	{
		QSid: "25",
		QDes: "/困",
		IQLid: "80",
		AQLid: "82",
		EMCode: "125"
	},
	{
		QSid: "26",
		QDes: "/惊恐",
		IQLid: "26",
		AQLid: "26",
		EMCode: "126"
	},
	{
		QSid: "27",
		QDes: "/流汗",
		IQLid: "2",
		AQLid: "2",
		EMCode: "127"
	},
	{
		QSid: "28",
		QDes: "/憨笑",
		IQLid: "37",
		AQLid: "37",
		EMCode: "128"
	},
	{
		QSid: "29",
		QDes: "/悠闲",
		IQLid: "50",
		AQLid: "50",
		EMCode: "129"
	},
	{
		QSid: "30",
		QDes: "/奋斗",
		IQLid: "42",
		AQLid: "42",
		EMCode: "130"
	},
	{
		QSid: "31",
		QDes: "/咒骂",
		IQLid: "81",
		AQLid: "83",
		EMCode: "131"
	},
	{
		QSid: "32",
		QDes: "/疑问",
		IQLid: "34",
		AQLid: "34",
		EMCode: "132"
	},
	{
		QSid: "33",
		QDes: "/嘘",
		IQLid: "11",
		AQLid: "11",
		EMCode: "133"
	},
	{
		QSid: "34",
		QDes: "/晕",
		IQLid: "49",
		AQLid: "49",
		EMCode: "134"
	},
	{
		QSid: "35",
		QDes: "/折磨",
		IQLid: "82",
		AQLid: "84",
		EMCode: "135"
	},
	{
		QSid: "36",
		QDes: "/衰",
		IQLid: "39",
		AQLid: "39",
		EMCode: "136"
	},
	{
		QSid: "37",
		QDes: "/骷髅",
		isStatic: "1",
		IQLid: "76",
		AQLid: "78",
		EMCode: "137"
	},
	{
		QSid: "38",
		QDes: "/敲打",
		IQLid: "5",
		AQLid: "5",
		EMCode: "138"
	},
	{
		QSid: "39",
		QDes: "/再见",
		IQLid: "4",
		AQLid: "4",
		EMCode: "139"
	},
	{
		QSid: "97",
		QDes: "/擦汗",
		IQLid: "6",
		AQLid: "6",
		EMCode: "140"
	},
	{
		QSid: "98",
		QDes: "/抠鼻",
		IQLid: "83",
		AQLid: "85",
		EMCode: "141"
	},
	{
		QSid: "99",
		QDes: "/鼓掌",
		IQLid: "84",
		AQLid: "86",
		EMCode: "142"
	},
	{
		QSid: "100",
		QDes: "/糗大了",
		IQLid: "85",
		AQLid: "87",
		EMCode: "143"
	},
	{
		QSid: "101",
		QDes: "/坏笑",
		IQLid: "46",
		AQLid: "46",
		EMCode: "144"
	},
	{
		QSid: "102",
		QDes: "/左哼哼",
		IQLid: "86",
		AQLid: "88",
		EMCode: "145"
	},
	{
		QSid: "103",
		QDes: "/右哼哼",
		IQLid: "44",
		AQLid: "44",
		EMCode: "146"
	},
	{
		QSid: "104",
		QDes: "/哈欠",
		IQLid: "87",
		AQLid: "89",
		EMCode: "147"
	},
	{
		QSid: "105",
		QDes: "/鄙视",
		IQLid: "48",
		AQLid: "48",
		EMCode: "148"
	},
	{
		QSid: "106",
		QDes: "/委屈",
		IQLid: "14",
		AQLid: "14",
		EMCode: "149"
	},
	{
		QSid: "107",
		QDes: "/快哭了",
		IQLid: "88",
		AQLid: "90",
		EMCode: "150"
	},
	{
		QSid: "108",
		QDes: "/阴险",
		IQLid: "41",
		AQLid: "41",
		EMCode: "151"
	},
	{
		QSid: "305",
		QDes: "/右亲亲",
		IQLid: "305",
		AQLid: "305",
		EMCode: "10305"
	},
	{
		QSid: "109",
		QDes: "/左亲亲",
		IQLid: "36",
		AQLid: "36",
		EMCode: "152"
	},
	{
		QSid: "110",
		QDes: "/吓",
		IQLid: "89",
		AQLid: "91",
		EMCode: "153"
	},
	{
		QSid: "111",
		QDes: "/可怜",
		IQLid: "51",
		AQLid: "51",
		EMCode: "154"
	},
	{
		QSid: "172",
		QDes: "/眨眼睛",
		IQLid: "142",
		AQLid: "164",
		EMCode: "242"
	},
	{
		QSid: "182",
		QDes: "/笑哭",
		IQLid: "152",
		AQLid: "174",
		EMCode: "252"
	},
	{
		QSid: "179",
		QDes: "/doge",
		IQLid: "149",
		AQLid: "171",
		EMCode: "249"
	},
	{
		QSid: "173",
		QDes: "/泪奔",
		IQLid: "143",
		AQLid: "165",
		EMCode: "243"
	},
	{
		QSid: "174",
		QDes: "/无奈",
		IQLid: "144",
		AQLid: "166",
		EMCode: "244"
	},
	{
		QSid: "212",
		QDes: "/托腮",
		IQLid: "182",
		AQLid: "161",
		EMCode: "282"
	},
	{
		QSid: "175",
		QDes: "/卖萌",
		IQLid: "145",
		AQLid: "167",
		EMCode: "245"
	},
	{
		QSid: "178",
		QDes: "/斜眼笑",
		IQLid: "148",
		AQLid: "170",
		EMCode: "248"
	},
	{
		QSid: "177",
		QDes: "/喷血",
		IQLid: "147",
		AQLid: "169",
		EMCode: "247"
	},
	{
		QSid: "176",
		QDes: "/小纠结",
		IQLid: "146",
		AQLid: "168",
		EMCode: "246"
	},
	{
		QSid: "183",
		QDes: "/我最美",
		IQLid: "153",
		AQLid: "175",
		EMCode: "253"
	},
	{
		QSid: "262",
		QDes: "/脑阔疼",
		IQLid: "262",
		AQLid: "262",
		EMCode: "10262"
	},
	{
		QSid: "263",
		QDes: "/沧桑",
		IQLid: "263",
		AQLid: "263",
		EMCode: "10263"
	},
	{
		QSid: "264",
		QDes: "/捂脸",
		IQLid: "264",
		AQLid: "264",
		EMCode: "10264"
	},
	{
		QSid: "265",
		QDes: "/辣眼睛",
		IQLid: "265",
		AQLid: "265",
		EMCode: "10265"
	},
	{
		QSid: "266",
		QDes: "/哦哟",
		IQLid: "266",
		AQLid: "266",
		EMCode: "10266"
	},
	{
		QSid: "267",
		QDes: "/头秃",
		IQLid: "267",
		AQLid: "267",
		EMCode: "10267"
	},
	{
		QSid: "268",
		QDes: "/问号脸",
		IQLid: "268",
		AQLid: "268",
		EMCode: "10268"
	},
	{
		QSid: "269",
		QDes: "/暗中观察",
		IQLid: "269",
		AQLid: "269",
		EMCode: "10269"
	},
	{
		QSid: "270",
		QDes: "/emm",
		IQLid: "270",
		AQLid: "270",
		EMCode: "10270"
	},
	{
		QSid: "271",
		QDes: "/吃瓜",
		IQLid: "271",
		AQLid: "271",
		EMCode: "10271"
	},
	{
		QSid: "272",
		QDes: "/呵呵哒",
		IQLid: "272",
		AQLid: "272",
		EMCode: "10272"
	},
	{
		QSid: "277",
		QDes: "/汪汪",
		IQLid: "277",
		AQLid: "277",
		EMCode: "10277"
	},
	{
		QSid: "307",
		QDes: "/喵喵",
		IQLid: "307",
		AQLid: "307",
		EMCode: "10307"
	},
	{
		QSid: "306",
		QDes: "/牛气冲天",
		isStatic: "1",
		IQLid: "306",
		AQLid: "306",
		EMCode: "10306"
	},
	{
		QSid: "281",
		QDes: "/无眼笑",
		IQLid: "281",
		AQLid: "281",
		EMCode: "10281"
	},
	{
		QSid: "282",
		QDes: "/敬礼",
		IQLid: "282",
		AQLid: "282",
		EMCode: "10282"
	},
	{
		QSid: "283",
		QDes: "/狂笑",
		IQLid: "283",
		AQLid: "283",
		EMCode: "10283"
	},
	{
		QSid: "284",
		QDes: "/面无表情",
		IQLid: "284",
		AQLid: "284",
		EMCode: "10284"
	},
	{
		QSid: "285",
		QDes: "/摸鱼",
		IQLid: "285",
		AQLid: "285",
		EMCode: "10285"
	},
	{
		QSid: "293",
		QDes: "/摸锦鲤",
		IQLid: "293",
		AQLid: "293",
		EMCode: "10293"
	},
	{
		QSid: "286",
		QDes: "/魔鬼笑",
		IQLid: "286",
		AQLid: "286",
		EMCode: "10286"
	},
	{
		QSid: "287",
		QDes: "/哦",
		IQLid: "287",
		AQLid: "287",
		EMCode: "10287"
	},
	{
		QSid: "289",
		QDes: "/睁眼",
		IQLid: "289",
		AQLid: "289",
		EMCode: "10289"
	},
	{
		QSid: "294",
		QDes: "/期待",
		IQLid: "294",
		AQLid: "294",
		EMCode: "10294"
	},
	{
		QSid: "297",
		QDes: "/拜谢",
		IQLid: "297",
		AQLid: "297",
		EMCode: "10297"
	},
	{
		QSid: "298",
		QDes: "/元宝",
		IQLid: "298",
		AQLid: "298",
		EMCode: "10298"
	},
	{
		QSid: "299",
		QDes: "/牛啊",
		IQLid: "299",
		AQLid: "299",
		EMCode: "10299"
	},
	{
		QSid: "300",
		QDes: "/胖三斤",
		IQLid: "300",
		AQLid: "300",
		EMCode: "10300"
	},
	{
		QSid: "323",
		QDes: "/嫌弃",
		IQLid: "323",
		AQLid: "323",
		EMCode: "10323"
	},
	{
		QSid: "332",
		QDes: "/举牌牌",
		IQLid: "332",
		AQLid: "332",
		EMCode: "10332"
	},
	{
		QSid: "336",
		QDes: "/豹富",
		IQLid: "336",
		AQLid: "336",
		EMCode: "10336"
	},
	{
		QSid: "353",
		QDes: "/拜托",
		IQLid: "353",
		AQLid: "353",
		EMCode: "10353"
	},
	{
		QSid: "355",
		QDes: "/耶",
		IQLid: "355",
		AQLid: "355",
		EMCode: "10355"
	},
	{
		QSid: "356",
		QDes: "/666",
		IQLid: "356",
		AQLid: "356",
		EMCode: "10356"
	},
	{
		QSid: "354",
		QDes: "/尊嘟假嘟",
		IQLid: "354",
		AQLid: "354",
		EMCode: "10354"
	},
	{
		QSid: "352",
		QDes: "/咦",
		IQLid: "352",
		AQLid: "352",
		EMCode: "10352"
	},
	{
		QSid: "357",
		QDes: "/裂开",
		IQLid: "357",
		AQLid: "357",
		EMCode: "10357"
	},
	{
		QSid: "334",
		QDes: "/虎虎生威",
		IQLid: "334",
		AQLid: "334",
		EMCode: "10334"
	},
	{
		QSid: "347",
		QDes: "/大展宏兔",
		IQLid: "347",
		AQLid: "347",
		EMCode: "10347"
	},
	{
		QSid: "303",
		QDes: "/右拜年",
		IQLid: "303",
		AQLid: "303",
		EMCode: "10303"
	},
	{
		QSid: "302",
		QDes: "/左拜年",
		IQLid: "302",
		AQLid: "302",
		EMCode: "10302"
	},
	{
		QSid: "295",
		QDes: "/拿到红包",
		IQLid: "295",
		AQLid: "295",
		EMCode: "10295"
	},
	{
		QSid: "311",
		QDes: "/打call",
		IQLid: "311",
		AQLid: "311",
		EMCode: "10311",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "1"
	},
	{
		QSid: "312",
		QDes: "/变形",
		IQLid: "312",
		AQLid: "312",
		EMCode: "10312",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "2"
	},
	{
		QSid: "314",
		QDes: "/仔细分析",
		IQLid: "314",
		AQLid: "314",
		EMCode: "10314",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "4"
	},
	{
		QSid: "317",
		QDes: "/菜汪",
		IQLid: "317",
		AQLid: "317",
		EMCode: "10317",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "7"
	},
	{
		QSid: "318",
		QDes: "/崇拜",
		IQLid: "318",
		AQLid: "318",
		EMCode: "10318",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "8"
	},
	{
		QSid: "319",
		QDes: "/比心",
		IQLid: "319",
		AQLid: "319",
		EMCode: "10319",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "9"
	},
	{
		QSid: "320",
		QDes: "/庆祝",
		IQLid: "320",
		AQLid: "320",
		EMCode: "10320",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "10"
	},
	{
		QSid: "324",
		QDes: "/吃糖",
		IQLid: "324",
		AQLid: "324",
		EMCode: "10324",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "12"
	},
	{
		QSid: "325",
		QDes: "/惊吓",
		IQLid: "325",
		AQLid: "325",
		EMCode: "10325",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "14"
	},
	{
		QSid: "337",
		QDes: "/花朵脸",
		IQLid: "337",
		AQLid: "337",
		EMCode: "10337",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "22"
	},
	{
		QSid: "338",
		QDes: "/我想开了",
		IQLid: "338",
		AQLid: "338",
		EMCode: "10338",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "20"
	},
	{
		QSid: "339",
		QDes: "/舔屏",
		IQLid: "339",
		AQLid: "339",
		EMCode: "10339",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "21"
	},
	{
		QSid: "341",
		QDes: "/打招呼",
		IQLid: "341",
		AQLid: "341",
		EMCode: "10341",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "24"
	},
	{
		QSid: "342",
		QDes: "/酸Q",
		IQLid: "342",
		AQLid: "342",
		EMCode: "10342",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "26"
	},
	{
		QSid: "343",
		QDes: "/我方了",
		IQLid: "343",
		AQLid: "343",
		EMCode: "10343",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "27"
	},
	{
		QSid: "344",
		QDes: "/大怨种",
		IQLid: "344",
		AQLid: "344",
		EMCode: "10344",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "28"
	},
	{
		QSid: "345",
		QDes: "/红包多多",
		IQLid: "345",
		AQLid: "345",
		EMCode: "10345",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "29"
	},
	{
		QSid: "346",
		QDes: "/你真棒棒",
		IQLid: "346",
		AQLid: "346",
		EMCode: "10346",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "25"
	},
	{
		QSid: "181",
		QDes: "/戳一戳",
		IQLid: "151",
		AQLid: "173",
		EMCode: "251",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "37"
	},
	{
		QSid: "74",
		QDes: "/太阳",
		isStatic: "1",
		IQLid: "73",
		AQLid: "75",
		EMCode: "176",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "35"
	},
	{
		QSid: "75",
		QDes: "/月亮",
		isStatic: "1",
		IQLid: "67",
		AQLid: "68",
		EMCode: "175",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "36"
	},
	{
		QSid: "351",
		QDes: "/敲敲",
		IQLid: "351",
		AQLid: "351",
		EMCode: "10351",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "30"
	},
	{
		QSid: "349",
		QDes: "/坚强",
		IQLid: "349",
		AQLid: "349",
		EMCode: "10349",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "32"
	},
	{
		QSid: "350",
		QDes: "/贴贴",
		IQLid: "350",
		AQLid: "350",
		EMCode: "10350",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "31"
	},
	{
		QSid: "395",
		QDes: "/略略略",
		IQLid: "395",
		AQLid: "395",
		EMCode: "10395",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "41"
	},
	{
		QSid: "114",
		QDes: "/篮球",
		IQLid: "90",
		AQLid: "92",
		EMCode: "158",
		AniStickerType: 2,
		AniStickerPackId: "1",
		AniStickerId: "13"
	},
	{
		QSid: "358",
		QDes: "/骰子",
		IQLid: "358",
		AQLid: "358",
		QHide: "1",
		EMCode: "10358",
		AniStickerType: 2,
		AniStickerPackId: "1",
		AniStickerId: "33"
	},
	{
		QSid: "359",
		QDes: "/包剪锤",
		IQLid: "359",
		AQLid: "359",
		QHide: "1",
		EMCode: "10359",
		AniStickerType: 2,
		AniStickerPackId: "1",
		AniStickerId: "34"
	},
	{
		QSid: "326",
		QDes: "/生气",
		IQLid: "326",
		AQLid: "326",
		EMCode: "10326",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "15"
	},
	{
		QSid: "53",
		QDes: "/蛋糕",
		IQLid: "59",
		AQLid: "59",
		EMCode: "168",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "17"
	},
	{
		QSid: "49",
		QDes: "/拥抱",
		IQLid: "45",
		AQLid: "45",
		EMCode: "178"
	},
	{
		QSid: "66",
		QDes: "/爱心",
		IQLid: "28",
		AQLid: "28",
		EMCode: "166"
	},
	{
		QSid: "63",
		QDes: "/玫瑰",
		IQLid: "8",
		AQLid: "8",
		EMCode: "163"
	},
	{
		QSid: "64",
		QDes: "/凋谢",
		IQLid: "57",
		AQLid: "57",
		EMCode: "164"
	},
	{
		QSid: "187",
		QDes: "/幽灵",
		IQLid: "157",
		AQLid: "179",
		EMCode: "257"
	},
	{
		QSid: "146",
		QDes: "/爆筋",
		IQLid: "116",
		AQLid: "118",
		EMCode: "121011"
	},
	{
		QSid: "116",
		QDes: "/示爱",
		IQLid: "29",
		AQLid: "29",
		EMCode: "165"
	},
	{
		QSid: "67",
		QDes: "/心碎",
		IQLid: "72",
		AQLid: "74",
		EMCode: "167"
	},
	{
		QSid: "60",
		QDes: "/咖啡",
		IQLid: "66",
		AQLid: "66",
		EMCode: "160"
	},
	{
		QSid: "185",
		QDes: "/羊驼",
		IQLid: "155",
		AQLid: "177",
		EMCode: "255"
	},
	{
		QSid: "137",
		QDes: "/鞭炮",
		isStatic: "1",
		IQLid: "107",
		AQLid: "109",
		EMCode: "121002",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "18"
	},
	{
		QSid: "333",
		QDes: "/烟花",
		isStatic: "1",
		IQLid: "333",
		AQLid: "333",
		EMCode: "10333",
		AniStickerType: 1,
		AniStickerPackId: "1",
		AniStickerId: "19"
	},
	{
		QSid: "76",
		QDes: "/赞",
		IQLid: "52",
		AQLid: "52",
		EMCode: "179"
	},
	{
		QSid: "124",
		QDes: "/OK",
		IQLid: "64",
		AQLid: "64",
		EMCode: "189"
	},
	{
		QSid: "118",
		QDes: "/抱拳",
		IQLid: "56",
		AQLid: "56",
		EMCode: "183"
	},
	{
		QSid: "78",
		QDes: "/握手",
		IQLid: "54",
		AQLid: "54",
		EMCode: "181"
	},
	{
		QSid: "119",
		QDes: "/勾引",
		IQLid: "63",
		AQLid: "63",
		EMCode: "184"
	},
	{
		QSid: "79",
		QDes: "/胜利",
		IQLid: "55",
		AQLid: "55",
		EMCode: "182"
	},
	{
		QSid: "120",
		QDes: "/拳头",
		IQLid: "71",
		AQLid: "73",
		EMCode: "185"
	},
	{
		QSid: "121",
		QDes: "/差劲",
		IQLid: "70",
		AQLid: "72",
		EMCode: "186"
	},
	{
		QSid: "77",
		QDes: "/踩",
		IQLid: "53",
		AQLid: "53",
		EMCode: "180"
	},
	{
		QSid: "123",
		QDes: "/NO",
		IQLid: "92",
		AQLid: "94",
		EMCode: "188"
	},
	{
		QSid: "201",
		QDes: "/点赞",
		IQLid: "171",
		AQLid: "150",
		EMCode: "271"
	},
	{
		QSid: "273",
		QDes: "/我酸了",
		isStatic: "1",
		IQLid: "273",
		AQLid: "273",
		EMCode: "10273"
	},
	{
		QSid: "46",
		QDes: "/猪头",
		isStatic: "1",
		IQLid: "7",
		AQLid: "7",
		EMCode: "162"
	},
	{
		QSid: "112",
		QDes: "/菜刀",
		IQLid: "17",
		AQLid: "17",
		EMCode: "155"
	},
	{
		QSid: "56",
		QDes: "/刀",
		IQLid: "68",
		AQLid: "70",
		EMCode: "171"
	},
	{
		QSid: "169",
		QDes: "/手枪",
		isStatic: "1",
		IQLid: "139",
		AQLid: "141",
		EMCode: "121034"
	},
	{
		QSid: "171",
		QDes: "/茶",
		IQLid: "141",
		AQLid: "163",
		EMCode: "241"
	},
	{
		QSid: "59",
		QDes: "/便便",
		IQLid: "15",
		AQLid: "15",
		EMCode: "174"
	},
	{
		QSid: "144",
		QDes: "/喝彩",
		isStatic: "1",
		IQLid: "114",
		AQLid: "116",
		EMCode: "121009"
	},
	{
		QSid: "147",
		QDes: "/棒棒糖",
		isStatic: "1",
		IQLid: "117",
		AQLid: "119",
		EMCode: "121012"
	},
	{
		QSid: "89",
		QDes: "/西瓜",
		isStatic: "1",
		IQLid: "60",
		AQLid: "60",
		EMCode: "156"
	},
	{
		QSid: "148",
		QDes: "/喝奶",
		isStatic: "1",
		IQLid: "118",
		AQLid: "120",
		QHide: "1",
		EMCode: "121013"
	},
	{
		QSid: "55",
		QDes: "/炸弹",
		isStatic: "1",
		IQLid: "16",
		AQLid: "16",
		QHide: "1",
		EMCode: "170"
	},
	{
		QSid: "41",
		QDes: "/发抖",
		isStatic: "1",
		IQLid: "69",
		AQLid: "71",
		EMCode: "193"
	},
	{
		QSid: "125",
		QDes: "/转圈",
		IQLid: "95",
		AQLid: "97",
		EMCode: "195"
	},
	{
		QSid: "42",
		QDes: "/爱情",
		IQLid: "38",
		AQLid: "38",
		EMCode: "190"
	},
	{
		QSid: "43",
		QDes: "/跳跳",
		IQLid: "93",
		AQLid: "95",
		EMCode: "192"
	},
	{
		QSid: "86",
		QDes: "/怄火",
		IQLid: "94",
		AQLid: "96",
		EMCode: "194"
	},
	{
		QSid: "129",
		QDes: "/挥手",
		IQLid: "77",
		AQLid: "79",
		EMCode: "199"
	},
	{
		QSid: "226",
		QDes: "/拍桌",
		IQLid: "196",
		isCMEmoji: "1",
		AQLid: "198",
		QHide: "1",
		EMCode: "297"
	},
	{
		QSid: "85",
		QDes: "/飞吻",
		isStatic: "1",
		IQLid: "47",
		AQLid: "47",
		EMCode: "191"
	},
	{
		QSid: "215",
		QDes: "/糊脸",
		IQLid: "185",
		isCMEmoji: "1",
		AQLid: "187",
		QHide: "1",
		EMCode: "285"
	},
	{
		QSid: "214",
		QDes: "/啵啵",
		IQLid: "184",
		isCMEmoji: "1",
		AQLid: "186",
		QHide: "1",
		EMCode: "284"
	},
	{
		QSid: "222",
		QDes: "/抱抱",
		IQLid: "192",
		isCMEmoji: "1",
		AQLid: "194",
		QHide: "1",
		EMCode: "292"
	},
	{
		QSid: "203",
		QDes: "/托脸",
		IQLid: "173",
		AQLid: "152",
		QHide: "1",
		EMCode: "273"
	},
	{
		QSid: "235",
		QDes: "/颤抖",
		IQLid: "205",
		isCMEmoji: "1",
		AQLid: "207",
		QHide: "1",
		EMCode: "305"
	},
	{
		QSid: "241",
		QDes: "/生日快乐",
		IQLid: "211",
		isCMEmoji: "1",
		AQLid: "213",
		QHide: "1",
		EMCode: "311"
	},
	{
		QSid: "237",
		QDes: "/偷看",
		IQLid: "207",
		isCMEmoji: "1",
		AQLid: "209",
		QHide: "1",
		EMCode: "307"
	},
	{
		QSid: "218",
		QDes: "/舔一舔",
		IQLid: "188",
		isCMEmoji: "1",
		AQLid: "190",
		QHide: "1",
		EMCode: "288"
	},
	{
		QSid: "233",
		QDes: "/掐一掐",
		IQLid: "203",
		isCMEmoji: "1",
		AQLid: "205",
		QHide: "1",
		EMCode: "303"
	},
	{
		QSid: "232",
		QDes: "/佛系",
		IQLid: "202",
		isCMEmoji: "1",
		AQLid: "204",
		QHide: "1",
		EMCode: "302"
	},
	{
		QSid: "238",
		QDes: "/扇脸",
		IQLid: "208",
		isCMEmoji: "1",
		AQLid: "210",
		QHide: "1",
		EMCode: "308"
	},
	{
		QSid: "217",
		QDes: "/扯一扯",
		IQLid: "187",
		isCMEmoji: "1",
		AQLid: "189",
		QHide: "1",
		EMCode: "287"
	},
	{
		QSid: "225",
		QDes: "/撩一撩",
		IQLid: "195",
		isCMEmoji: "1",
		AQLid: "197",
		QHide: "1",
		EMCode: "296"
	},
	{
		QSid: "230",
		QDes: "/嘲讽",
		IQLid: "200",
		isCMEmoji: "1",
		AQLid: "202",
		QHide: "1",
		EMCode: "300"
	},
	{
		QSid: "194",
		QDes: "/不开心",
		IQLid: "164",
		AQLid: "143",
		QHide: "1",
		EMCode: "264"
	},
	{
		QSid: "210",
		QDes: "/飙泪",
		IQLid: "180",
		AQLid: "159",
		QHide: "1",
		EMCode: "280"
	},
	{
		QSid: "193",
		QDes: "/大笑",
		IQLid: "163",
		AQLid: "185",
		QHide: "1",
		EMCode: "263"
	},
	{
		QSid: "204",
		QDes: "/吃",
		IQLid: "174",
		AQLid: "153",
		QHide: "1",
		EMCode: "274"
	},
	{
		QSid: "200",
		QDes: "/求求",
		IQLid: "170",
		AQLid: "149",
		QHide: "1",
		EMCode: "270"
	},
	{
		QSid: "290",
		QDes: "/敲开心",
		IQLid: "290",
		isCMEmoji: "1",
		AQLid: "290",
		QHide: "1",
		EMCode: "20240"
	},
	{
		QSid: "224",
		QDes: "/开枪",
		IQLid: "194",
		isCMEmoji: "1",
		AQLid: "196",
		QHide: "1",
		EMCode: "295"
	},
	{
		QSid: "229",
		QDes: "/干杯",
		IQLid: "199",
		isCMEmoji: "1",
		AQLid: "201",
		QHide: "1",
		EMCode: "299"
	},
	{
		QSid: "221",
		QDes: "/顶呱呱",
		IQLid: "191",
		isCMEmoji: "1",
		AQLid: "193",
		QHide: "1",
		EMCode: "291"
	},
	{
		QSid: "219",
		QDes: "/蹭一蹭",
		IQLid: "189",
		isCMEmoji: "1",
		AQLid: "191",
		QHide: "1",
		EMCode: "289"
	},
	{
		QSid: "227",
		QDes: "/拍手",
		IQLid: "197",
		isCMEmoji: "1",
		AQLid: "199",
		QHide: "1",
		EMCode: "294"
	},
	{
		QSid: "216",
		QDes: "/拍头",
		IQLid: "186",
		isCMEmoji: "1",
		AQLid: "188",
		QHide: "1",
		EMCode: "286"
	},
	{
		QSid: "231",
		QDes: "/哼",
		IQLid: "201",
		isCMEmoji: "1",
		AQLid: "203",
		QHide: "1",
		EMCode: "301"
	},
	{
		QSid: "244",
		QDes: "/扔狗",
		IQLid: "214",
		isCMEmoji: "1",
		AQLid: "216",
		QHide: "1",
		EMCode: "312"
	},
	{
		QSid: "223",
		QDes: "/暴击",
		IQLid: "193",
		isCMEmoji: "1",
		AQLid: "195",
		QHide: "1",
		EMCode: "293"
	},
	{
		QSid: "243",
		QDes: "/甩头",
		IQLid: "213",
		isCMEmoji: "1",
		AQLid: "215",
		QHide: "1",
		EMCode: "313"
	},
	{
		QSid: "211",
		QDes: "/我不看",
		IQLid: "181",
		AQLid: "160",
		QHide: "1",
		EMCode: "281"
	},
	{
		QSid: "292",
		QDes: "/让我康康",
		IQLid: "292",
		isCMEmoji: "1",
		AQLid: "292",
		QHide: "1",
		EMCode: "20242"
	},
	{
		QSid: "240",
		QDes: "/喷脸",
		IQLid: "210",
		isCMEmoji: "1",
		AQLid: "212",
		QHide: "1",
		EMCode: "310"
	},
	{
		QSid: "180",
		QDes: "/惊喜",
		IQLid: "150",
		AQLid: "172",
		QHide: "1",
		EMCode: "250"
	},
	{
		QSid: "122",
		QDes: "/爱你",
		IQLid: "65",
		AQLid: "65",
		QHide: "1",
		EMCode: "187"
	},
	{
		QSid: "202",
		QDes: "/无聊",
		IQLid: "172",
		AQLid: "151",
		QHide: "1",
		EMCode: "272"
	},
	{
		QSid: "278",
		QDes: "/汗",
		IQLid: "278",
		isCMEmoji: "1",
		AQLid: "278",
		QHide: "1",
		EMCode: "20237"
	},
	{
		QSid: "301",
		QDes: "/好闪",
		IQLid: "301",
		AQLid: "301",
		QHide: "1",
		EMCode: "10301"
	},
	{
		QSid: "288",
		QDes: "/请",
		IQLid: "288",
		AQLid: "288",
		QHide: "1",
		EMCode: "10288"
	},
	{
		QSid: "322",
		QDes: "/拒绝",
		IQLid: "322",
		AQLid: "322",
		QHide: "1",
		EMCode: "10322"
	},
	{
		QSid: "198",
		QDes: "/呃",
		IQLid: "168",
		AQLid: "147",
		QHide: "1",
		EMCode: "268"
	},
	{
		QSid: "348",
		QDes: "/福萝卜",
		IQLid: "348",
		AQLid: "348",
		QHide: "1",
		EMCode: "10348"
	},
	{
		QSid: "206",
		QDes: "/害怕",
		IQLid: "176",
		AQLid: "155",
		QHide: "1",
		EMCode: "276"
	},
	{
		QSid: "239",
		QDes: "/原谅",
		IQLid: "209",
		isCMEmoji: "1",
		AQLid: "211",
		QHide: "1",
		EMCode: "309"
	}
];
const emoji = [
	{
		QSid: "😊",
		QCid: "128522",
		AQLid: "0",
		QDes: "/嘿嘿",
		EMCode: "400832"
	},
	{
		QSid: "😌",
		QCid: "128524",
		AQLid: "1",
		QDes: "/羞涩",
		EMCode: "400834"
	},
	{
		QSid: "😚",
		QCid: "128538",
		AQLid: "2",
		QDes: "/亲亲",
		EMCode: "400848"
	},
	{
		QSid: "😓",
		QCid: "128531",
		AQLid: "3",
		QDes: "/汗",
		EMCode: "400841"
	},
	{
		QSid: "😰",
		QCid: "128560",
		AQLid: "4",
		QDes: "/紧张",
		EMCode: "400870"
	},
	{
		QSid: "😝",
		QCid: "128541",
		AQLid: "5",
		QDes: "/吐舌",
		EMCode: "400851"
	},
	{
		QSid: "😁",
		QCid: "128513",
		AQLid: "6",
		QDes: "/呲牙",
		EMCode: "400823"
	},
	{
		QSid: "😜",
		QCid: "128540",
		AQLid: "7",
		QDes: "/淘气",
		EMCode: "400850"
	},
	{
		QSid: "☺",
		QCid: "9786",
		AQLid: "8",
		QDes: "/可爱",
		EMCode: "401181"
	},
	{
		QSid: "😉",
		QCid: "128521",
		AQLid: "9",
		QDes: "/媚眼",
		QHide: "1",
		EMCode: "400831"
	},
	{
		QSid: "😍",
		QCid: "128525",
		AQLid: "10",
		QDes: "/花痴",
		EMCode: "400835"
	},
	{
		QSid: "😔",
		QCid: "128532",
		AQLid: "11",
		QDes: "/失落",
		EMCode: "400842"
	},
	{
		QSid: "😄",
		QCid: "128516",
		AQLid: "12",
		QDes: "/高兴",
		EMCode: "400826"
	},
	{
		QSid: "😏",
		QCid: "128527",
		AQLid: "13",
		QDes: "/哼哼",
		EMCode: "400837"
	},
	{
		QSid: "😒",
		QCid: "128530",
		AQLid: "14",
		QDes: "/不屑",
		EMCode: "400840"
	},
	{
		QSid: "😳",
		QCid: "128563",
		AQLid: "15",
		QDes: "/瞪眼",
		EMCode: "400873"
	},
	{
		QSid: "😘",
		QCid: "128536",
		AQLid: "16",
		QDes: "/飞吻",
		EMCode: "400846"
	},
	{
		QSid: "😭",
		QCid: "128557",
		AQLid: "17",
		QDes: "/大哭",
		EMCode: "400867"
	},
	{
		QSid: "😱",
		QCid: "128561",
		AQLid: "18",
		QDes: "/害怕",
		EMCode: "400871"
	},
	{
		QSid: "😂",
		QCid: "128514",
		AQLid: "19",
		QDes: "/激动",
		EMCode: "400824"
	},
	{
		QSid: "💪",
		QCid: "128170",
		AQLid: "20",
		QDes: "/肌肉",
		EMCode: "400644"
	},
	{
		QSid: "👊",
		QCid: "128074",
		AQLid: "21",
		QDes: "/拳头",
		EMCode: "400390"
	},
	{
		QSid: "👍",
		QCid: "128077",
		AQLid: "22",
		QDes: "/厉害",
		EMCode: "400408"
	},
	{
		QSid: "☝",
		QCid: "9757",
		AQLid: "23",
		QDes: "/向上",
		QHide: "1",
		EMCode: "401203"
	},
	{
		QSid: "👏",
		QCid: "128079",
		AQLid: "24",
		QDes: "/鼓掌",
		EMCode: "400420"
	},
	{
		QSid: "✌",
		QCid: "9996",
		AQLid: "25",
		QDes: "/胜利",
		QHide: "1",
		EMCode: "401210"
	},
	{
		QSid: "👎",
		QCid: "128078",
		AQLid: "26",
		QDes: "/鄙视",
		EMCode: "400414"
	},
	{
		QSid: "🙏",
		QCid: "128591",
		AQLid: "27",
		QDes: "/合十",
		EMCode: "400396"
	},
	{
		QSid: "👌",
		QCid: "128076",
		AQLid: "28",
		QDes: "/好的",
		EMCode: "400402"
	},
	{
		QSid: "👈",
		QCid: "128072",
		AQLid: "29",
		QDes: "/向左",
		QHide: "1",
		EMCode: "400378"
	},
	{
		QSid: "👉",
		QCid: "128073",
		AQLid: "30",
		QDes: "/向右",
		QHide: "1",
		EMCode: "400384"
	},
	{
		QSid: "👆",
		QCid: "128070",
		AQLid: "31",
		QDes: "/向上",
		EMCode: "400366"
	},
	{
		QSid: "👇",
		QCid: "128071",
		AQLid: "32",
		QDes: "/向下",
		QHide: "1",
		EMCode: "400372"
	},
	{
		QSid: "👀",
		QCid: "128064",
		AQLid: "33",
		QDes: "/眼睛",
		EMCode: "400351"
	},
	{
		QSid: "👃",
		QCid: "128067",
		AQLid: "34",
		QDes: "/鼻子",
		QHide: "1",
		EMCode: "400358"
	},
	{
		QSid: "👄",
		QCid: "128068",
		AQLid: "35",
		QDes: "/嘴唇",
		QHide: "1",
		EMCode: "400364"
	},
	{
		QSid: "👂",
		QCid: "128066",
		AQLid: "36",
		QDes: "/耳朵",
		QHide: "1",
		EMCode: "400352"
	},
	{
		QSid: "🍚",
		QCid: "127834",
		AQLid: "37",
		QDes: "/米饭",
		QHide: "1",
		EMCode: "400149"
	},
	{
		QSid: "🍝",
		QCid: "127837",
		AQLid: "38",
		QDes: "/意面",
		QHide: "1",
		EMCode: "400152"
	},
	{
		QSid: "🍜",
		QCid: "127836",
		AQLid: "39",
		QDes: "/拉面",
		EMCode: "400151"
	},
	{
		QSid: "🍙",
		QCid: "127833",
		AQLid: "40",
		QDes: "/饭团",
		QHide: "1",
		EMCode: "400148"
	},
	{
		QSid: "🍧",
		QCid: "127847",
		AQLid: "41",
		QDes: "/刨冰",
		EMCode: "400162"
	},
	{
		QSid: "🍣",
		QCid: "127843",
		AQLid: "42",
		QDes: "/寿司",
		QHide: "1",
		EMCode: "400158"
	},
	{
		QSid: "🎂",
		QCid: "127874",
		AQLid: "43",
		QDes: "/蛋糕",
		QHide: "1",
		EMCode: "400186"
	},
	{
		QSid: "🍞",
		QCid: "127838",
		AQLid: "44",
		QDes: "/面包",
		EMCode: "400153"
	},
	{
		QSid: "🍔",
		QCid: "127828",
		AQLid: "45",
		QDes: "/汉堡",
		QHide: "1",
		EMCode: "400143"
	},
	{
		QSid: "🍳",
		QCid: "127859",
		AQLid: "46",
		QDes: "/煎蛋",
		QHide: "1",
		EMCode: "400174"
	},
	{
		QSid: "🍟",
		QCid: "127839",
		AQLid: "47",
		QDes: "/薯条",
		QHide: "1",
		EMCode: "400154"
	},
	{
		QSid: "🍺",
		QCid: "127866",
		AQLid: "48",
		QDes: "/啤酒",
		EMCode: "400181"
	},
	{
		QSid: "🍻",
		QCid: "127867",
		AQLid: "49",
		QDes: "/干杯",
		EMCode: "400182"
	},
	{
		QSid: "🍸",
		QCid: "127864",
		AQLid: "50",
		QDes: "/高脚杯",
		QHide: "1",
		EMCode: "400179"
	},
	{
		QSid: "☕",
		QCid: "9749",
		AQLid: "51",
		QDes: "/咖啡",
		EMCode: "401262"
	},
	{
		QSid: "🍎",
		QCid: "127822",
		AQLid: "52",
		QDes: "/苹果",
		EMCode: "400137"
	},
	{
		QSid: "🍊",
		QCid: "127818",
		AQLid: "53",
		QDes: "/橙子",
		QHide: "1",
		EMCode: "400133"
	},
	{
		QSid: "🍓",
		QCid: "127827",
		AQLid: "54",
		QDes: "/草莓",
		EMCode: "400142"
	},
	{
		QSid: "🍉",
		QCid: "127817",
		AQLid: "55",
		QDes: "/西瓜",
		EMCode: "400132"
	},
	{
		QSid: "💊",
		QCid: "128138",
		AQLid: "56",
		QDes: "/药丸",
		QHide: "1",
		EMCode: "400612"
	},
	{
		QSid: "🚬",
		QCid: "128684",
		AQLid: "57",
		QDes: "/吸烟",
		EMCode: "400987"
	},
	{
		QSid: "🎄",
		QCid: "127876",
		AQLid: "58",
		QDes: "/圣诞树",
		QHide: "1",
		EMCode: "400188"
	},
	{
		QSid: "🌹",
		QCid: "127801",
		AQLid: "59",
		QDes: "/玫瑰",
		EMCode: "400116"
	},
	{
		QSid: "🎉",
		QCid: "127881",
		AQLid: "60",
		QDes: "/庆祝",
		EMCode: "400198"
	},
	{
		QSid: "🌴",
		QCid: "127796",
		AQLid: "61",
		QDes: "/椰子树",
		QHide: "1",
		EMCode: "400112"
	},
	{
		QSid: "💝",
		QCid: "128157",
		AQLid: "62",
		QDes: "/礼物",
		EMCode: "400631"
	},
	{
		QSid: "🎀",
		QCid: "127872",
		AQLid: "63",
		QDes: "/蝴蝶结",
		QHide: "1",
		EMCode: "400184"
	},
	{
		QSid: "🎈",
		QCid: "127880",
		AQLid: "64",
		QDes: "/气球",
		QHide: "1",
		EMCode: "400197"
	},
	{
		QSid: "🐚",
		QCid: "128026",
		AQLid: "65",
		QDes: "/海螺",
		QHide: "1",
		EMCode: "400314"
	},
	{
		QSid: "💍",
		QCid: "128141",
		AQLid: "66",
		QDes: "/戒指",
		QHide: "1",
		EMCode: "400615"
	},
	{
		QSid: "💣",
		QCid: "128163",
		AQLid: "67",
		QDes: "/炸弹",
		EMCode: "400637"
	},
	{
		QSid: "👑",
		QCid: "128081",
		AQLid: "68",
		QDes: "/皇冠",
		QHide: "1",
		EMCode: "400432"
	},
	{
		QSid: "🔔",
		QCid: "128276",
		AQLid: "69",
		QDes: "/铃铛",
		QHide: "1",
		EMCode: "400751"
	},
	{
		QSid: "⭐",
		QCid: "11088",
		AQLid: "70",
		QDes: "/星星",
		QHide: "1",
		EMCode: "401686"
	},
	{
		QSid: "✨",
		QCid: "10024",
		AQLid: "71",
		QDes: "/闪光",
		EMCode: "401137"
	},
	{
		QSid: "💨",
		QCid: "128168",
		AQLid: "72",
		QDes: "/吹气",
		EMCode: "400642"
	},
	{
		QSid: "💦",
		QCid: "128166",
		AQLid: "73",
		QDes: "/水",
		EMCode: "400640"
	},
	{
		QSid: "🔥",
		QCid: "128293",
		AQLid: "74",
		QDes: "/火",
		EMCode: "400768"
	},
	{
		QSid: "🏆",
		QCid: "127942",
		AQLid: "75",
		QDes: "/奖杯",
		QHide: "1",
		EMCode: "400256"
	},
	{
		QSid: "💰",
		QCid: "128176",
		AQLid: "76",
		QDes: "/钱",
		QHide: "1",
		EMCode: "400655"
	},
	{
		QSid: "💤",
		QCid: "128164",
		AQLid: "77",
		QDes: "/睡觉",
		EMCode: "400638"
	},
	{
		QSid: "⚡",
		QCid: "9889",
		AQLid: "78",
		QDes: "/闪电",
		QHide: "1",
		EMCode: "401685"
	},
	{
		QSid: "👣",
		QCid: "128099",
		AQLid: "79",
		QDes: "/脚印",
		QHide: "1",
		EMCode: "400450"
	},
	{
		QSid: "💩",
		QCid: "128169",
		AQLid: "80",
		QDes: "/便便",
		EMCode: "400643"
	},
	{
		QSid: "💉",
		QCid: "128137",
		AQLid: "81",
		QDes: "/打针",
		EMCode: "400611"
	},
	{
		QSid: "♨",
		QCid: "9832",
		AQLid: "82",
		QDes: "/热",
		QHide: "1",
		EMCode: "401287"
	},
	{
		QSid: "📫",
		QCid: "128235",
		AQLid: "83",
		QDes: "/邮箱",
		EMCode: "400714"
	},
	{
		QSid: "🔑",
		QCid: "128273",
		AQLid: "84",
		QDes: "/钥匙",
		QHide: "1",
		EMCode: "400748"
	},
	{
		QSid: "🔒",
		QCid: "128274",
		AQLid: "85",
		QDes: "/锁",
		QHide: "1",
		EMCode: "400749"
	},
	{
		QSid: "✈",
		QCid: "9992",
		AQLid: "86",
		QDes: "/飞机",
		QHide: "1",
		EMCode: "401298"
	},
	{
		QSid: "🚄",
		QCid: "128644",
		AQLid: "87",
		QDes: "/列车",
		QHide: "1",
		EMCode: "400942"
	},
	{
		QSid: "🚗",
		QCid: "128663",
		AQLid: "88",
		QDes: "/汽车",
		QHide: "1",
		EMCode: "400961"
	},
	{
		QSid: "🚤",
		QCid: "128676",
		AQLid: "89",
		QDes: "/快艇",
		QHide: "1",
		EMCode: "400979"
	},
	{
		QSid: "🚲",
		QCid: "128690",
		AQLid: "90",
		QDes: "/自行车",
		QHide: "1",
		EMCode: "400993"
	},
	{
		QSid: "🐎",
		QCid: "128014",
		AQLid: "91",
		QDes: "/骑马",
		EMCode: "400302"
	},
	{
		QSid: "🚀",
		QCid: "128640",
		AQLid: "92",
		QDes: "/火箭",
		QHide: "1",
		EMCode: "400938"
	},
	{
		QSid: "🚌",
		QCid: "128652",
		AQLid: "93",
		QDes: "/公交",
		QHide: "1",
		EMCode: "400950"
	},
	{
		QSid: "⛵",
		QCid: "9973",
		AQLid: "94",
		QDes: "/船",
		QHide: "1",
		EMCode: "401294"
	},
	{
		QSid: "👩",
		QCid: "128105",
		AQLid: "95",
		QDes: "/妈妈",
		QHide: "1",
		EMCode: "400482"
	},
	{
		QSid: "👨",
		QCid: "128104",
		AQLid: "96",
		QDes: "/爸爸",
		QHide: "1",
		EMCode: "400465"
	},
	{
		QSid: "👧",
		QCid: "128103",
		AQLid: "97",
		QDes: "/女孩",
		EMCode: "400459"
	},
	{
		QSid: "👦",
		QCid: "128102",
		AQLid: "98",
		QDes: "/男孩",
		EMCode: "400453"
	},
	{
		QSid: "🐵",
		QCid: "128053",
		AQLid: "99",
		QDes: "/猴",
		EMCode: "400341"
	},
	{
		QSid: "🐙",
		QCid: "128025",
		AQLid: "100",
		QDes: "/章鱼",
		QHide: "1",
		EMCode: "400313"
	},
	{
		QSid: "🐷",
		QCid: "128055",
		AQLid: "101",
		QDes: "/猪",
		EMCode: "400343"
	},
	{
		QSid: "💀",
		QCid: "128128",
		AQLid: "102",
		QDes: "/骷髅",
		QHide: "1",
		EMCode: "400572"
	},
	{
		QSid: "🐤",
		QCid: "128036",
		AQLid: "103",
		QDes: "/小鸡",
		QHide: "1",
		EMCode: "400324"
	},
	{
		QSid: "🐨",
		QCid: "128040",
		AQLid: "104",
		QDes: "/树懒",
		QHide: "1",
		EMCode: "400328"
	},
	{
		QSid: "🐮",
		QCid: "128046",
		AQLid: "105",
		QDes: "/牛",
		EMCode: "400334"
	},
	{
		QSid: "🐔",
		QCid: "128020",
		AQLid: "106",
		QDes: "/公鸡",
		EMCode: "400308"
	},
	{
		QSid: "🐸",
		QCid: "128056",
		AQLid: "107",
		QDes: "/青蛙",
		EMCode: "400344"
	},
	{
		QSid: "👻",
		QCid: "128123",
		AQLid: "108",
		QDes: "/幽灵",
		EMCode: "400562"
	},
	{
		QSid: "🐛",
		QCid: "128027",
		AQLid: "109",
		QDes: "/虫",
		EMCode: "400315"
	},
	{
		QSid: "🐠",
		QCid: "128032",
		AQLid: "110",
		QDes: "/鱼",
		QHide: "1",
		EMCode: "400320"
	},
	{
		QSid: "🐶",
		QCid: "128054",
		AQLid: "111",
		QDes: "/狗",
		EMCode: "400342"
	},
	{
		QSid: "🐯",
		QCid: "128047",
		AQLid: "112",
		QDes: "/老虎",
		QHide: "1",
		EMCode: "400335"
	},
	{
		QSid: "👼",
		QCid: "128124",
		AQLid: "113",
		QDes: "/天使",
		QHide: "1",
		EMCode: "400563"
	},
	{
		QSid: "🐧",
		QCid: "128039",
		AQLid: "114",
		QDes: "/企鹅",
		QHide: "1",
		EMCode: "400327"
	},
	{
		QSid: "🐳",
		QCid: "128051",
		AQLid: "115",
		QDes: "/鲸鱼",
		EMCode: "400339"
	},
	{
		QSid: "🐭",
		QCid: "128045",
		AQLid: "116",
		QDes: "/老鼠",
		QHide: "1",
		EMCode: "400333"
	},
	{
		QSid: "👒",
		QCid: "128082",
		AQLid: "117",
		QDes: "/帽子",
		QHide: "1",
		EMCode: "400433"
	},
	{
		QSid: "👗",
		QCid: "128087",
		AQLid: "118",
		QDes: "/连衣裙",
		QHide: "1",
		EMCode: "400438"
	},
	{
		QSid: "💄",
		QCid: "128132",
		AQLid: "119",
		QDes: "/口红",
		QHide: "1",
		EMCode: "400591"
	},
	{
		QSid: "👠",
		QCid: "128096",
		AQLid: "120",
		QDes: "/高跟鞋",
		QHide: "1",
		EMCode: "400447"
	},
	{
		QSid: "👢",
		QCid: "128098",
		AQLid: "121",
		QDes: "/靴子",
		EMCode: "400449"
	},
	{
		QSid: "🌂",
		QCid: "127746",
		AQLid: "122",
		QDes: "/雨伞",
		QHide: "1",
		EMCode: "400077"
	},
	{
		QSid: "👜",
		QCid: "128092",
		AQLid: "123",
		QDes: "/包",
		QHide: "1",
		EMCode: "400443"
	},
	{
		QSid: "👙",
		QCid: "128089",
		AQLid: "124",
		QDes: "/内衣",
		QHide: "1",
		EMCode: "400440"
	},
	{
		QSid: "👕",
		QCid: "128085",
		AQLid: "125",
		QDes: "/衣服",
		QHide: "1",
		EMCode: "400436"
	},
	{
		QSid: "👟",
		QCid: "128095",
		AQLid: "126",
		QDes: "/鞋子",
		QHide: "1",
		EMCode: "400446"
	},
	{
		QSid: "☁",
		QCid: "9729",
		AQLid: "127",
		QDes: "/云朵",
		QHide: "1",
		EMCode: "401329"
	},
	{
		QSid: "☀",
		QCid: "9728",
		AQLid: "128",
		QDes: "/晴天",
		EMCode: "401328"
	},
	{
		QSid: "☔",
		QCid: "9748",
		AQLid: "129",
		QDes: "/雨天",
		QHide: "1",
		EMCode: "401342"
	},
	{
		QSid: "🌙",
		QCid: "127769",
		AQLid: "130",
		QDes: "/月亮",
		QHide: "1",
		EMCode: "400100"
	},
	{
		QSid: "⛄",
		QCid: "9924",
		AQLid: "131",
		QDes: "/雪人",
		QHide: "1",
		EMCode: "401346"
	},
	{
		QSid: "⭕",
		QCid: "11093",
		AQLid: "132",
		QDes: "/正确",
		QHide: "1",
		EMCode: "401687"
	},
	{
		QSid: "❌",
		QCid: "10060",
		AQLid: "133",
		QDes: "/错误",
		QHide: "1",
		EMCode: "401142"
	},
	{
		QSid: "❔",
		QCid: "10068",
		AQLid: "134",
		QDes: "/问号",
		EMCode: "401145"
	},
	{
		QSid: "❕",
		QCid: "10069",
		AQLid: "135",
		QDes: "/叹号",
		QHide: "1",
		EMCode: "401146"
	},
	{
		QSid: "☎",
		QCid: "9742",
		AQLid: "136",
		QDes: "/电话",
		QHide: "1",
		EMCode: "401398"
	},
	{
		QSid: "📷",
		QCid: "128247",
		AQLid: "137",
		QDes: "/相机",
		QHide: "1",
		EMCode: "400726"
	},
	{
		QSid: "📱",
		QCid: "128241",
		AQLid: "138",
		QDes: "/手机",
		QHide: "1",
		EMCode: "400720"
	},
	{
		QSid: "📠",
		QCid: "128224",
		AQLid: "139",
		QDes: "/传真",
		QHide: "1",
		EMCode: "400703"
	},
	{
		QSid: "💻",
		QCid: "128187",
		AQLid: "140",
		QDes: "/电脑",
		QHide: "1",
		EMCode: "400666"
	},
	{
		QSid: "🎥",
		QCid: "127909",
		AQLid: "141",
		QDes: "/摄影机",
		QHide: "1",
		EMCode: "400214"
	},
	{
		QSid: "🎤",
		QCid: "127908",
		AQLid: "142",
		QDes: "/话筒",
		QHide: "1",
		EMCode: "400213"
	},
	{
		QSid: "🔫",
		QCid: "128299",
		AQLid: "143",
		QDes: "/手枪",
		EMCode: "400774"
	},
	{
		QSid: "💿",
		QCid: "128191",
		AQLid: "144",
		QDes: "/光碟",
		QHide: "1",
		EMCode: "400670"
	},
	{
		QSid: "💓",
		QCid: "128147",
		AQLid: "145",
		QDes: "/爱心",
		EMCode: "400621"
	},
	{
		QSid: "♣",
		QCid: "9827",
		AQLid: "146",
		QDes: "/扑克",
		QHide: "1",
		EMCode: "401385"
	},
	{
		QSid: "🀄",
		QCid: "126980",
		AQLid: "147",
		QDes: "/麻将",
		QHide: "1",
		EMCode: "401386"
	},
	{
		QSid: "〽",
		QCid: "12349",
		AQLid: "148",
		QDes: "/股票",
		QHide: "1",
		EMCode: "401691"
	},
	{
		QSid: "🎰",
		QCid: "127920",
		AQLid: "149",
		QDes: "/老虎机",
		QHide: "1",
		EMCode: "400225"
	},
	{
		QSid: "🚥",
		QCid: "128677",
		AQLid: "150",
		QDes: "/信号灯",
		QHide: "1",
		EMCode: "400980"
	},
	{
		QSid: "🚧",
		QCid: "128679",
		AQLid: "151",
		QDes: "/路障",
		QHide: "1",
		EMCode: "400982"
	},
	{
		QSid: "🎸",
		QCid: "127928",
		AQLid: "152",
		QDes: "/吉他",
		QHide: "1",
		EMCode: "400233"
	},
	{
		QSid: "💈",
		QCid: "128136",
		AQLid: "153",
		QDes: "/理发厅",
		QHide: "1",
		EMCode: "400610"
	},
	{
		QSid: "🛀",
		QCid: "128704",
		AQLid: "154",
		QDes: "/浴缸",
		QHide: "1",
		EMCode: "401022"
	},
	{
		QSid: "🚽",
		QCid: "128701",
		AQLid: "155",
		QDes: "/马桶",
		QHide: "1",
		EMCode: "401019"
	},
	{
		QSid: "🏠",
		QCid: "127968",
		AQLid: "156",
		QDes: "/家",
		QHide: "1",
		EMCode: "400271"
	},
	{
		QSid: "⛪",
		QCid: "9962",
		AQLid: "157",
		QDes: "/教堂",
		QHide: "1",
		EMCode: "401281"
	},
	{
		QSid: "🏦",
		QCid: "127974",
		AQLid: "158",
		QDes: "/银行",
		QHide: "1",
		EMCode: "400277"
	},
	{
		QSid: "🏥",
		QCid: "127973",
		AQLid: "159",
		QDes: "/医院",
		QHide: "1",
		EMCode: "400276"
	},
	{
		QSid: "🏨",
		QCid: "127976",
		AQLid: "160",
		QDes: "/酒店",
		QHide: "1",
		EMCode: "400279"
	},
	{
		QSid: "🏧",
		QCid: "127975",
		AQLid: "161",
		QDes: "/取款机",
		QHide: "1",
		EMCode: "400278"
	},
	{
		QSid: "🏪",
		QCid: "127978",
		AQLid: "162",
		QDes: "/便利店",
		EMCode: "400281"
	},
	{
		QSid: "🚹",
		QCid: "128697",
		AQLid: "163",
		QDes: "/男性",
		QHide: "1",
		EMCode: "401015"
	},
	{
		QSid: "🚺",
		QCid: "128698",
		AQLid: "164",
		QDes: "/女性",
		QHide: "1",
		EMCode: "401016"
	}
];
const faceConfig = {
	sysface: sysface,
	emoji: emoji
};

var OB11UserSex = /* @__PURE__ */ ((OB11UserSex2) => {
  OB11UserSex2["male"] = "male";
  OB11UserSex2["female"] = "female";
  OB11UserSex2["unknown"] = "unknown";
  return OB11UserSex2;
})(OB11UserSex || {});
var OB11GroupMemberRole = /* @__PURE__ */ ((OB11GroupMemberRole2) => {
  OB11GroupMemberRole2["owner"] = "owner";
  OB11GroupMemberRole2["admin"] = "admin";
  OB11GroupMemberRole2["member"] = "member";
  return OB11GroupMemberRole2;
})(OB11GroupMemberRole || {});

var OB11MessageDataType = /* @__PURE__ */ ((OB11MessageDataType2) => {
  OB11MessageDataType2["text"] = "text";
  OB11MessageDataType2["image"] = "image";
  OB11MessageDataType2["music"] = "music";
  OB11MessageDataType2["video"] = "video";
  OB11MessageDataType2["voice"] = "record";
  OB11MessageDataType2["file"] = "file";
  OB11MessageDataType2["at"] = "at";
  OB11MessageDataType2["reply"] = "reply";
  OB11MessageDataType2["json"] = "json";
  OB11MessageDataType2["face"] = "face";
  OB11MessageDataType2["mface"] = "mface";
  OB11MessageDataType2["markdown"] = "markdown";
  OB11MessageDataType2["node"] = "node";
  OB11MessageDataType2["forward"] = "forward";
  OB11MessageDataType2["xml"] = "xml";
  OB11MessageDataType2["poke"] = "poke";
  OB11MessageDataType2["dice"] = "dice";
  OB11MessageDataType2["RPS"] = "rps";
  OB11MessageDataType2["miniapp"] = "miniapp";
  OB11MessageDataType2["contact"] = "contact";
  OB11MessageDataType2["Location"] = "location";
  return OB11MessageDataType2;
})(OB11MessageDataType || {});

class OB11Entities {
  static selfInfo(selfInfo) {
    return {
      user_id: parseInt(selfInfo.uin),
      nickname: selfInfo.nick
    };
  }
  static friendsV2(friends) {
    return friends.map((rawFriend) => ({
      ...rawFriend.baseInfo,
      ...rawFriend.coreInfo,
      user_id: parseInt(rawFriend.coreInfo.uin),
      nickname: rawFriend.coreInfo.nick,
      remark: rawFriend.coreInfo.remark ?? rawFriend.coreInfo.nick,
      sex: this.sex(rawFriend.baseInfo.sex),
      level: 0
    }));
  }
  static friends(friends) {
    return friends.map((rawFriend) => ({
      user_id: parseInt(rawFriend.uin),
      nickname: rawFriend.nick,
      remark: rawFriend.remark,
      sex: this.sex(rawFriend.sex),
      level: 0
    }));
  }
  static groupMemberRole(role) {
    return {
      4: OB11GroupMemberRole.owner,
      3: OB11GroupMemberRole.admin,
      2: OB11GroupMemberRole.member
    }[role];
  }
  static sex(sex) {
    if (!sex) return OB11UserSex.unknown;
    return {
      [Sex.male]: OB11UserSex.male,
      [Sex.female]: OB11UserSex.female,
      [Sex.unknown]: OB11UserSex.unknown
    }[sex] || OB11UserSex.unknown;
  }
  static groupMember(group_id, member) {
    return {
      group_id: parseInt(group_id),
      user_id: parseInt(member.uin),
      nickname: member.nick,
      card: member.cardName,
      sex: OB11Entities.sex(member.sex),
      age: member.age ?? 0,
      area: "",
      level: member.memberRealLevel ?? "0",
      qq_level: member.qqLevel && calcQQLevel(member.qqLevel) || 0,
      join_time: +member.joinTime,
      last_sent_time: +member.lastSpeakTime,
      title_expire_time: 0,
      unfriendly: false,
      card_changeable: true,
      is_robot: member.isRobot,
      shut_up_timestamp: member.shutUpTime,
      role: OB11Entities.groupMemberRole(member.role),
      title: member.memberSpecialTitle || ""
    };
  }
  static stranger(user) {
    return {
      ...user,
      user_id: parseInt(user.uin),
      nickname: user.nick,
      sex: OB11Entities.sex(user.sex),
      age: 0,
      qid: user.qid,
      login_days: 0,
      level: user.qqLevel && calcQQLevel(user.qqLevel) || 0
    };
  }
  static group(group) {
    return {
      group_id: parseInt(group.groupCode),
      group_name: group.groupName,
      member_count: group.memberCount,
      max_member_count: group.maxMember
    };
  }
  static groups(groups) {
    return groups.map(OB11Entities.group);
  }
  static file(peerId, file) {
    return {
      group_id: parseInt(peerId),
      file_id: FileNapCatOneBotUUID.encodeModelId({ chatType: 2, peerUid: peerId }, file.fileModelId, file.fileId, file.fileId ?? ""),
      file_name: file.fileName,
      busid: file.busId,
      size: parseInt(file.fileSize),
      upload_time: file.uploadTime,
      dead_time: file.deadTime,
      modify_time: file.modifyTime,
      download_times: file.downloadTimes,
      uploader: parseInt(file.uploaderUin),
      uploader_name: file.uploaderName
    };
  }
  static folder(peerId, folder) {
    return {
      group_id: parseInt(peerId),
      folder_id: folder.folderId,
      folder: folder.folderId,
      folder_name: folder.folderName,
      create_time: folder.createTime,
      creator: parseInt(folder.createUin),
      creator_name: folder.creatorName,
      total_file_count: folder.totalFileCount
    };
  }
}

const pattern$1 = /\[CQ:(\w+)((,\w+=[^,\]]*)*)]/;
function unescape$1(source) {
  return String(source).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
}
function from(source) {
  const capture = pattern$1.exec(source);
  if (!capture) return null;
  const [, type, attrs] = capture;
  const data = {};
  if (attrs) {
    attrs.slice(1).split(",").forEach((str) => {
      const index = str.indexOf("=");
      data[str.slice(0, index)] = unescape$1(str.slice(index + 1));
    });
  }
  return { type, data, capture };
}
function h(type, data) {
  return {
    type,
    data
  };
}
function decodeCQCode(source) {
  const elements = [];
  let result;
  while (result = from(source)) {
    const { type, data, capture } = result;
    if (capture.index) {
      elements.push(h("text", { text: unescape$1(source.slice(0, capture.index)) }));
    }
    elements.push(h(type, data));
    source = source.slice(capture.index + capture[0].length);
  }
  if (source) elements.push(h("text", { text: unescape$1(source) }));
  return elements;
}
function encodeCQCode(data) {
  const CQCodeEscapeText = (text) => {
    return text.replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/]/g, "&#93;");
  };
  const CQCodeEscape = (text) => {
    return text.replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/]/g, "&#93;").replace(/,/g, "&#44;");
  };
  if (data.type === "text") {
    return CQCodeEscapeText(data.data.text);
  }
  let result = "[CQ:" + data.type;
  for (const name in data.data) {
    const value = data.data[name];
    if (value === void 0) {
      continue;
    }
    try {
      const text = value.toString();
      result += `,${name}=${CQCodeEscape(text)}`;
    } catch (error) {
    }
  }
  result += "]";
  return result;
}

class OB11FriendAddNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_add";
  user_id;
  constructor(core, userId) {
    super(core);
    this.user_id = userId;
  }
}

function keyCanBeParsed(key, parser) {
  return key in parser;
}
class OneBotMsgApi {
  obContext;
  core;
  rawToOb11Converters = {
    textElement: async (element) => {
      if (element.atType === AtType.notAt) {
        let text = element.content;
        if (!text.trim()) {
          return null;
        }
        if (text.indexOf("\n") === -1 && text.indexOf("\r\n") === -1) {
          text = text.replace(/\r/g, "\n");
        }
        return {
          type: OB11MessageDataType.text,
          data: { text }
        };
      } else {
        let qq = "all";
        if (element.atType !== AtType.atAll) {
          const {
            atNtUid
            /* content */
          } = element;
          let atQQ = element.atUid;
          if (!atQQ || atQQ === "0") {
            atQQ = await this.core.apis.UserApi.getUinByUidV2(atNtUid);
          }
          if (atQQ) {
            qq = atQQ;
          }
        }
        return {
          type: OB11MessageDataType.at,
          data: {
            qq
            // name: content.slice(1);
          }
        };
      }
    },
    picElement: async (element, msg, elementWrapper) => {
      try {
        const peer = {
          chatType: msg.chatType,
          peerUid: msg.peerUid,
          guildId: ""
        };
        const encodedFileId = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, element.fileUuid, "." + element.fileName);
        return {
          type: OB11MessageDataType.image,
          data: {
            summary: element.summary,
            file: encodedFileId,
            sub_type: element.picSubType,
            file_id: encodedFileId,
            url: await this.core.apis.FileApi.getImageUrl(element),
            path: element.filePath,
            file_size: element.fileSize,
            file_unique: element.fileName
          }
        };
      } catch (e) {
        this.core.context.logger.logError.bind(this.core.context.logger)("获取图片url失败", e.stack);
        return null;
      }
    },
    fileElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      return {
        type: OB11MessageDataType.file,
        data: {
          file: element.fileName,
          path: element.filePath,
          url: pathToFileURL(element.filePath).href,
          file_id: FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, element.fileUuid, "." + element.fileName),
          file_size: element.fileSize,
          file_unique: element.fileName
        }
      };
    },
    faceElement: async (element) => {
      const faceIndex = element.faceIndex;
      if (faceIndex === FaceIndex.dice) {
        return {
          type: OB11MessageDataType.dice,
          data: {
            result: element.resultId
          }
        };
      } else if (faceIndex === FaceIndex.RPS) {
        return {
          type: OB11MessageDataType.RPS,
          data: {
            result: element.resultId
          }
        };
      } else {
        return {
          type: OB11MessageDataType.face,
          data: {
            id: element.faceIndex.toString()
          }
        };
      }
    },
    marketFaceElement: async (_, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      const { emojiId } = _;
      const dir = emojiId.substring(0, 2);
      const url = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw300.gif`;
      return {
        type: OB11MessageDataType.image,
        data: {
          summary: _.faceName,
          // 商城表情名称
          file: "marketface",
          file_id: FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + _.key + ".jpg"),
          path: url,
          url,
          file_unique: _.key
        }
      };
    },
    replyElement: async (element, msg) => {
      const records = msg.records.find((msgRecord) => msgRecord.msgId === element?.sourceMsgIdInRecords);
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      if (!records || !element.replyMsgTime || !element.senderUidStr) {
        this.core.context.logger.logError.bind(this.core.context.logger)("获取不到引用的消息", element.replayMsgSeq);
        return null;
      }
      const createReplyData = (msgId) => ({
        type: OB11MessageDataType.reply,
        data: {
          id: MessageUnique.createUniqueMsgId(peer, msgId).toString()
        }
      });
      if (records.peerUin === "284840486" || records.peerUin === "1094950020") {
        return createReplyData(records.msgId);
      }
      const replyMsg = (await this.core.apis.MsgApi.queryMsgsWithFilterExWithSeqV2(peer, element.replayMsgSeq, element.replyMsgTime, [element.senderUidStr])).msgList.find((msg2) => msg2.msgRandom === records.msgRandom);
      if (!replyMsg || records.msgRandom !== replyMsg.msgRandom) {
        this.core.context.logger.logError.bind(this.core.context.logger)("获取不到引用的消息", element.replayMsgSeq);
        return null;
      }
      return createReplyData(replyMsg.msgId);
    },
    videoElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      let videoUrlWrappers;
      if (msg.peerUin === "284840486" || msg.peerUin === "1094950020") {
        try {
          videoUrlWrappers = await this.core.apis.FileApi.getVideoUrl({
            chatType: msg.chatType,
            peerUid: msg.peerUid,
            guildId: "0"
          }, msg.parentMsgIdList[0] ?? msg.msgId, elementWrapper.elementId);
        } catch (error) {
          this.core.context.logger.logWarn("合并获取视频 URL 失败");
        }
      } else {
        try {
          videoUrlWrappers = await this.core.apis.FileApi.getVideoUrl({
            chatType: msg.chatType,
            peerUid: msg.peerUid,
            guildId: "0"
          }, msg.msgId, elementWrapper.elementId);
        } catch (error) {
          this.core.context.logger.logWarn("获取视频 URL 失败");
        }
      }
      let videoDownUrl;
      if (videoUrlWrappers) {
        const videoDownUrlTemp = videoUrlWrappers.find((urlWrapper) => {
          return !!urlWrapper.url;
        });
        if (videoDownUrlTemp) {
          videoDownUrl = videoDownUrlTemp.url;
        }
      }
      if (!videoDownUrl) {
        videoDownUrl = element.filePath;
      }
      const fileCode = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + element.fileName);
      return {
        type: OB11MessageDataType.video,
        data: {
          file: fileCode,
          path: videoDownUrl,
          url: videoDownUrl ?? pathToFileURL(element.filePath).href,
          file_id: fileCode,
          file_size: element.fileSize,
          file_unique: element.fileName
        }
      };
    },
    pttElement: async (element, msg, elementWrapper) => {
      const peer = {
        chatType: msg.chatType,
        peerUid: msg.peerUid,
        guildId: ""
      };
      const fileCode = FileNapCatOneBotUUID.encode(peer, msg.msgId, elementWrapper.elementId, "", "." + element.fileName);
      return {
        type: OB11MessageDataType.voice,
        data: {
          file: fileCode,
          path: element.filePath,
          url: pathToFileURL(element.filePath).href,
          file_id: fileCode,
          file_size: element.fileSize,
          file_unique: element.fileName
        }
      };
    },
    multiForwardMsgElement: async (_, msg) => {
      ({
        data: {},
        type: OB11MessageDataType.forward
      });
      msg.msgId;
      const parentMsgPeer = msg.parentMsgPeer ?? {
        chatType: msg.chatType,
        guildId: "",
        peerUid: msg.peerUid
      };
      msg.parentMsgIdList = msg.parentMsgIdList ?? [];
      msg.parentMsgIdList.push(msg.msgId);
      const multiMsgs = (await this.core.apis.MsgApi.getMultiMsg(parentMsgPeer, msg.parentMsgIdList[0], msg.msgId))?.msgList;
      if (!multiMsgs) return null;
      return {
        type: OB11MessageDataType.forward,
        data: {
          id: msg.msgId,
          content: (await Promise.all(multiMsgs.map(
            async (multiMsgItem) => {
              multiMsgItem.parentMsgPeer = parentMsgPeer;
              multiMsgItem.parentMsgIdList = msg.parentMsgIdList;
              multiMsgItem.id = MessageUnique.createUniqueMsgId(parentMsgPeer, multiMsgItem.msgId);
              return await this.parseMessage(multiMsgItem);
            }
          ))).filter((item) => item !== void 0)
        }
      };
    },
    arkElement: async (element) => {
      return {
        type: OB11MessageDataType.json,
        data: {
          data: element.bytesData
        }
      };
    },
    markdownElement: async (element) => {
      return {
        type: OB11MessageDataType.markdown,
        data: {
          content: element.content
        }
      };
    }
  };
  ob11ToRawConverters = {
    [OB11MessageDataType.text]: async ({ data: { text } }) => ({
      elementType: ElementType.TEXT,
      elementId: "",
      textElement: {
        content: text,
        atType: AtType.notAt,
        atUid: "",
        atTinyId: "",
        atNtUid: ""
      }
    }),
    [OB11MessageDataType.at]: async ({ data: { qq: atQQ } }, context) => {
      function at(atUid, atNtUid, atType, atName) {
        return {
          elementType: ElementType.TEXT,
          elementId: "",
          textElement: {
            content: `@${atName}`,
            atType,
            atUid,
            atTinyId: "",
            atNtUid
          }
        };
      }
      if (!context.peer || context.peer.chatType == ChatType.KCHATTYPEC2C) return void 0;
      if (atQQ === "all") return at(atQQ, atQQ, AtType.atAll, "全体成员");
      const atMember = await this.core.apis.GroupApi.getGroupMember(context.peer.peerUid, atQQ);
      if (atMember) {
        return at(atQQ, atMember.uid, AtType.atUser, atMember.nick || atMember.cardName);
      }
      const uid = await this.core.apis.UserApi.getUidByUinV2(`${atQQ}`);
      if (!uid) throw new Error("Get Uid Error");
      const info = await this.core.apis.UserApi.getUserDetailInfo(uid);
      return at(atQQ, uid, AtType.atUser, info.nick || "");
    },
    [OB11MessageDataType.reply]: async ({ data: { id } }) => {
      const replyMsgM = MessageUnique.getMsgIdAndPeerByShortId(parseInt(id));
      if (!replyMsgM) {
        this.core.context.logger.logWarn("回复消息不存在", id);
        return void 0;
      }
      const replyMsg = (await this.core.apis.MsgApi.getMsgsByMsgId(
        replyMsgM.Peer,
        [replyMsgM.MsgId]
      )).msgList[0];
      return replyMsg ? {
        elementType: ElementType.REPLY,
        elementId: "",
        replyElement: {
          replayMsgSeq: replyMsg.msgSeq,
          // raw.msgSeq
          replayMsgId: replyMsg.msgId,
          // raw.msgId
          senderUin: replyMsg.senderUin,
          senderUinStr: replyMsg.senderUin
        }
      } : void 0;
    },
    [OB11MessageDataType.face]: async ({ data: { id } }) => {
      let parsedFaceId = parseInt(id);
      const sysFaces = faceConfig.sysface;
      const face = sysFaces.find((systemFace) => systemFace.QSid === parsedFaceId.toString());
      if (!face) {
        this.core.context.logger.logError.bind(this.core.context.logger)("不支持的ID", id);
        return void 0;
      }
      parsedFaceId = parseInt(parsedFaceId.toString());
      let faceType = 1;
      if (parsedFaceId >= 222) {
        faceType = 2;
      }
      if (face.AniStickerType) {
        faceType = 3;
      }
      return {
        elementType: ElementType.FACE,
        elementId: "",
        faceElement: {
          faceIndex: parsedFaceId,
          faceType,
          faceText: face.QDes,
          stickerId: face.AniStickerId,
          stickerType: face.AniStickerType,
          packId: face.AniStickerPackId,
          sourceType: 1
        }
      };
    },
    [OB11MessageDataType.mface]: async ({
      data: {
        emoji_package_id,
        emoji_id,
        key,
        summary
      }
    }) => ({
      elementType: ElementType.MFACE,
      elementId: "",
      marketFaceElement: {
        emojiPackageId: emoji_package_id,
        emojiId: emoji_id,
        key,
        faceName: summary || "[商城表情]"
      }
    }),
    // File service
    [OB11MessageDataType.image]: async (sendMsg, context) => {
      const sendPicElement = await this.core.apis.FileApi.createValidSendPicElement(
        context,
        (await this.handleOb11FileLikeMessage(sendMsg, context)).path,
        sendMsg.data.summary,
        sendMsg.data.sub_type
      );
      return sendPicElement;
    },
    [OB11MessageDataType.file]: async (sendMsg, context) => {
      const { path, fileName } = await this.handleOb11FileLikeMessage(sendMsg, context);
      return await this.core.apis.FileApi.createValidSendFileElement(context, path, fileName);
    },
    [OB11MessageDataType.video]: async (sendMsg, context) => {
      const { path, fileName } = await this.handleOb11FileLikeMessage(sendMsg, context);
      let thumb = sendMsg.data.thumb;
      if (thumb) {
        const uri2LocalRes = await uri2local(this.core.NapCatTempPath, thumb);
        if (uri2LocalRes.success) thumb = uri2LocalRes.path;
      }
      return await this.core.apis.FileApi.createValidSendVideoElement(context, path, fileName, thumb);
    },
    [OB11MessageDataType.voice]: async (sendMsg, context) => this.core.apis.FileApi.createValidSendPttElement(
      (await this.handleOb11FileLikeMessage(sendMsg, context)).path
    ),
    [OB11MessageDataType.json]: async ({ data: { data } }) => ({
      elementType: ElementType.ARK,
      elementId: "",
      arkElement: {
        bytesData: typeof data === "string" ? data : JSON.stringify(data),
        linkInfo: null,
        subElementType: null
      }
    }),
    [OB11MessageDataType.dice]: async () => ({
      elementType: ElementType.FACE,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.dice,
        faceType: FaceType.dice,
        faceText: "[骰子]",
        packId: "1",
        stickerId: "33",
        sourceType: 1,
        stickerType: 2,
        surpriseId: ""
        // "randomType": 1,
      }
    }),
    [OB11MessageDataType.RPS]: async () => ({
      elementType: ElementType.FACE,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.RPS,
        faceText: "[包剪锤]",
        faceType: 3,
        packId: "1",
        stickerId: "34",
        sourceType: 1,
        stickerType: 2,
        surpriseId: ""
        // "randomType": 1,
      }
    }),
    // Need signing
    [OB11MessageDataType.markdown]: async ({ data: { content } }) => ({
      elementType: ElementType.MARKDOWN,
      elementId: "",
      markdownElement: { content }
    }),
    [OB11MessageDataType.music]: async ({ data }, context) => {
      if (data.id !== void 0) {
        if (!["qq", "163", "kugou", "kuwo", "migu"].includes(data.type)) {
          this.core.context.logger.logError.bind(this.core.context.logger)("音乐卡片type错误, 只支持qq、163、kugou、kuwo、migu，当前type:", data.type);
          return void 0;
        }
      } else {
        if (!["qq", "163", "kugou", "kuwo", "migu", "custom"].includes(data.type)) {
          this.core.context.logger.logError.bind(this.core.context.logger)("音乐卡片type错误, 只支持qq、163、kugou、kuwo、migu、custom，当前type:", data.type);
          return void 0;
        }
        if (!data.url) {
          this.core.context.logger.logError.bind(this.core.context.logger)("自定义音卡缺少参数url");
          return void 0;
        }
        if (!data.image) {
          this.core.context.logger.logError.bind(this.core.context.logger)("自定义音卡缺少参数image");
          return void 0;
        }
      }
      let postData;
      if (data.id === void 0 && data.content) {
        const { content, ...others } = data;
        postData = { singer: content, ...others };
      } else {
        postData = data;
      }
      let signUrl = this.obContext.configLoader.configData.musicSignUrl;
      if (!signUrl) {
        signUrl = "https://ss.xingzhige.com/music_card/card";
      }
      try {
        const musicJson = await RequestUtil.HttpGetJson(signUrl, "POST", postData);
        return this.ob11ToRawConverters.json({
          data: { data: musicJson },
          type: OB11MessageDataType.json
        }, context);
      } catch (e) {
        this.core.context.logger.logError.bind(this.core.context.logger)("生成音乐消息失败", e);
      }
    },
    [OB11MessageDataType.node]: async () => void 0,
    [OB11MessageDataType.forward]: async ({ data }, context) => {
      const jsonData = ForwardMsgBuilder.fromResId(data.id);
      return this.ob11ToRawConverters.json({
        data: { data: JSON.stringify(jsonData) },
        type: OB11MessageDataType.json
      }, context);
    },
    [OB11MessageDataType.xml]: async () => void 0,
    [OB11MessageDataType.poke]: async () => void 0,
    [OB11MessageDataType.Location]: async () => ({
      elementType: ElementType.SHARELOCATION,
      elementId: "",
      shareLocationElement: {
        text: "测试",
        ext: ""
      }
    }),
    [OB11MessageDataType.miniapp]: async () => void 0,
    [OB11MessageDataType.contact]: async ({ data: { type = "qq", id } }, context) => {
      if (type === "qq") {
        const arkJson = await this.core.apis.UserApi.getBuddyRecommendContactArkJson(id.toString(), "");
        return this.ob11ToRawConverters.json({
          data: { data: arkJson.arkMsg },
          type: OB11MessageDataType.json
        }, context);
      } else if (type === "group") {
        const arkJson = await this.core.apis.GroupApi.getGroupRecommendContactArkJson(id.toString());
        return this.ob11ToRawConverters.json({
          data: { data: arkJson.arkJson },
          type: OB11MessageDataType.json
        }, context);
      }
    }
  };
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async parsePrivateMsgEvent(msg) {
    if (msg.chatType !== ChatType.KCHATTYPEC2C) {
      return;
    }
    for (const element of msg.elements) {
      if (element.grayTipElement && element.grayTipElement.subElementType == NTGrayTipElementSubTypeV2.GRAYTIP_ELEMENT_SUBTYPE_JSON) {
        if (element.grayTipElement.jsonGrayTipElement.busiId == 1061) {
          const PokeEvent = await this.obContext.apis.FriendApi.parsePrivatePokeEvent(element.grayTipElement);
          if (PokeEvent) return PokeEvent;
        }
        if (element.grayTipElement.jsonGrayTipElement.busiId == 19324 && msg.peerUid !== "") {
          return new OB11FriendAddNoticeEvent(this.core, Number(await this.core.apis.UserApi.getUinByUidV2(msg.peerUid)));
        }
      }
    }
  }
  async parseMessage(msg, messagePostFormat = this.obContext.configLoader.configData.messagePostFormat) {
    if (msg.senderUin == "0" || msg.senderUin == "") return;
    if (msg.peerUin == "0" || msg.peerUin == "") return;
    const resMsg = {
      self_id: parseInt(this.core.selfInfo.uin),
      user_id: parseInt(msg.senderUin),
      time: parseInt(msg.msgTime) || Date.now(),
      message_id: msg.id,
      message_seq: msg.id,
      real_id: msg.id,
      message_type: msg.chatType == ChatType.KCHATTYPEGROUP ? "group" : "private",
      sender: {
        user_id: parseInt(msg.senderUin || "0"),
        nickname: msg.sendNickName,
        card: msg.sendMemberName || ""
      },
      raw_message: "",
      font: 14,
      sub_type: "friend",
      message: messagePostFormat === "string" ? "" : [],
      message_format: messagePostFormat === "string" ? "string" : "array",
      post_type: this.core.selfInfo.uin == msg.senderUin ? EventType.MESSAGE_SENT : EventType.MESSAGE
    };
    if (this.core.selfInfo.uin == msg.senderUin) {
      resMsg.message_sent_type = "self";
    }
    if (msg.chatType == ChatType.KCHATTYPEGROUP) {
      resMsg.sub_type = "normal";
      resMsg.group_id = parseInt(msg.peerUin);
      let member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
      if (!member) member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
      if (member) {
        resMsg.sender.role = OB11Entities.groupMemberRole(member.role);
        resMsg.sender.nickname = member.nick;
      }
    } else if (msg.chatType == ChatType.KCHATTYPEC2C) {
      resMsg.sub_type = "friend";
      resMsg.sender.nickname = (await this.core.apis.UserApi.getUserDetailInfo(msg.senderUid)).nick;
    } else if (msg.chatType == ChatType.KCHATTYPETEMPC2CFROMGROUP) {
      resMsg.sub_type = "group";
      const ret = await this.core.apis.MsgApi.getTempChatInfo(ChatType.KCHATTYPETEMPC2CFROMGROUP, msg.senderUid);
      if (ret.result === 0) {
        const member = await this.core.apis.GroupApi.getGroupMember(msg.peerUin, msg.senderUin);
        resMsg.group_id = parseInt(ret.tmpChatInfo.groupCode);
        resMsg.sender.nickname = member?.nick ?? member?.cardName ?? "临时会话";
        resMsg.temp_source = resMsg.group_id;
      } else {
        resMsg.group_id = 284840486;
        resMsg.temp_source = resMsg.group_id;
        resMsg.sender.nickname = "临时会话";
      }
    }
    const msgSegments = await Promise.allSettled(msg.elements.map(
      async (element) => {
        for (const key in element) {
          if (keyCanBeParsed(key, this.rawToOb11Converters) && element[key]) {
            const parsedElement = await this.rawToOb11Converters[key]?.(
              // eslint-disable-next-line
              // @ts-ignore
              element[key],
              msg,
              element
            );
            if (key === "faceElement" && !parsedElement) {
              return null;
            }
            return parsedElement;
          }
        }
      }
    ));
    const validSegments = msgSegments.filter((entry) => {
      if (entry.status === "fulfilled") {
        return !!entry.value;
      } else {
        this.core.context.logger.logError.bind(this.core.context.logger)("消息段解析失败", entry.reason);
        return false;
      }
    }).map((entry) => entry.value).filter((value) => value != null);
    const msgAsCQCode = validSegments.map((msg2) => encodeCQCode(msg2)).join("").trim();
    if (messagePostFormat === "string") {
      resMsg.message = msgAsCQCode;
      resMsg.raw_message = msgAsCQCode;
    } else {
      resMsg.message = validSegments;
      resMsg.raw_message = msgAsCQCode;
    }
    return resMsg;
  }
  async createSendElements(messageData, peer, ignoreTypes = []) {
    const deleteAfterSentFiles = [];
    const callResultList = [];
    for (const sendMsg of messageData) {
      if (ignoreTypes.includes(sendMsg.type)) {
        continue;
      }
      const callResult = this.ob11ToRawConverters[sendMsg.type](
        // eslint-disable-next-line
        // @ts-ignore
        sendMsg,
        { peer, deleteAfterSentFiles }
      )?.catch(void 0);
      callResultList.push(callResult);
    }
    const ret = await Promise.all(callResultList);
    const sendElements = ret.filter((ele) => !!ele);
    return { sendElements, deleteAfterSentFiles };
  }
  async sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles, waitComplete = true) {
    if (!sendElements.length) {
      throw new Error("消息体无法解析, 请检查是否发送了不支持的消息类型");
    }
    let totalSize = 0;
    let timeout = 1e4;
    try {
      for (const fileElement of sendElements) {
        if (fileElement.elementType === ElementType.PTT) {
          totalSize += fs__default$1.statSync(fileElement.pttElement.filePath).size;
        }
        if (fileElement.elementType === ElementType.FILE) {
          totalSize += fs__default$1.statSync(fileElement.fileElement.filePath).size;
        }
        if (fileElement.elementType === ElementType.VIDEO) {
          totalSize += fs__default$1.statSync(fileElement.videoElement.filePath).size;
        }
        if (fileElement.elementType === ElementType.PIC) {
          totalSize += fs__default$1.statSync(fileElement.picElement.sourcePath).size;
        }
      }
      const PredictTime = totalSize / 1024 / 256 * 1e3;
      if (!Number.isNaN(PredictTime)) {
        timeout += PredictTime;
      }
    } catch (e) {
      this.core.context.logger.logError.bind(this.core.context.logger)("发送消息计算预计时间异常", e);
    }
    const returnMsg = await this.core.apis.MsgApi.sendMsg(peer, sendElements, waitComplete, timeout);
    if (!returnMsg) throw new Error("发送消息失败");
    returnMsg.id = MessageUnique.createUniqueMsgId({
      chatType: peer.chatType,
      guildId: "",
      peerUid: peer.peerUid
    }, returnMsg.msgId);
    deleteAfterSentFiles.forEach((file) => {
      fsPromise$1.unlink(file).then().catch((e) => this.core.context.logger.logError.bind(this.core.context.logger)("发送消息删除文件失败", e));
    });
    return returnMsg;
  }
  async handleOb11FileLikeMessage({ data: inputdata }, { deleteAfterSentFiles }) {
    const realUri = inputdata.url || inputdata.file || inputdata.path || "";
    if (realUri.length === 0) {
      this.core.context.logger.logError.bind(this.core.context.logger)("文件消息缺少参数", inputdata);
      throw Error("文件消息缺少参数");
    }
    const {
      path,
      fileName,
      errMsg,
      success
    } = await uri2local(this.core.NapCatTempPath, realUri);
    if (!success) {
      this.core.context.logger.logError.bind(this.core.context.logger)("文件下载失败", errMsg);
      throw Error("文件下载失败" + errMsg);
    }
    deleteAfterSentFiles.push(path);
    return { path, fileName: inputdata.name ?? fileName };
  }
  async parseSysMessage(msg) {
    const sysMsg = decodeSysMessage(Uint8Array.from(msg));
    if (sysMsg.msgSpec.length === 0) {
      return;
    }
    const { msgType, subType, subSubType } = sysMsg.msgSpec[0];
    if (msgType === 528 && subType === 39 && subSubType === 39) {
      if (!sysMsg.bodyWrapper) return;
      const event = await this.obContext.apis.UserApi.parseLikeEvent(sysMsg.bodyWrapper.wrappedBody);
      return event;
    }
  }
}

var ajv = {exports: {}};

var core$2 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
	// eslint-disable-next-line @typescript-eslint/no-extraneous-class
	class _CodeOrName {
	}
	exports._CodeOrName = _CodeOrName;
	exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
	class Name extends _CodeOrName {
	    constructor(s) {
	        super();
	        if (!exports.IDENTIFIER.test(s))
	            throw new Error("CodeGen: name must be a valid identifier");
	        this.str = s;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        return false;
	    }
	    get names() {
	        return { [this.str]: 1 };
	    }
	}
	exports.Name = Name;
	class _Code extends _CodeOrName {
	    constructor(code) {
	        super();
	        this._items = typeof code === "string" ? [code] : code;
	    }
	    toString() {
	        return this.str;
	    }
	    emptyStr() {
	        if (this._items.length > 1)
	            return false;
	        const item = this._items[0];
	        return item === "" || item === '""';
	    }
	    get str() {
	        var _a;
	        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
	    }
	    get names() {
	        var _a;
	        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
	            if (c instanceof Name)
	                names[c.str] = (names[c.str] || 0) + 1;
	            return names;
	        }, {})));
	    }
	}
	exports._Code = _Code;
	exports.nil = new _Code("");
	function _(strs, ...args) {
	    const code = [strs[0]];
	    let i = 0;
	    while (i < args.length) {
	        addCodeArg(code, args[i]);
	        code.push(strs[++i]);
	    }
	    return new _Code(code);
	}
	exports._ = _;
	const plus = new _Code("+");
	function str(strs, ...args) {
	    const expr = [safeStringify(strs[0])];
	    let i = 0;
	    while (i < args.length) {
	        expr.push(plus);
	        addCodeArg(expr, args[i]);
	        expr.push(plus, safeStringify(strs[++i]));
	    }
	    optimize(expr);
	    return new _Code(expr);
	}
	exports.str = str;
	function addCodeArg(code, arg) {
	    if (arg instanceof _Code)
	        code.push(...arg._items);
	    else if (arg instanceof Name)
	        code.push(arg);
	    else
	        code.push(interpolate(arg));
	}
	exports.addCodeArg = addCodeArg;
	function optimize(expr) {
	    let i = 1;
	    while (i < expr.length - 1) {
	        if (expr[i] === plus) {
	            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
	            if (res !== undefined) {
	                expr.splice(i - 1, 3, res);
	                continue;
	            }
	            expr[i++] = "+";
	        }
	        i++;
	    }
	}
	function mergeExprItems(a, b) {
	    if (b === '""')
	        return a;
	    if (a === '""')
	        return b;
	    if (typeof a == "string") {
	        if (b instanceof Name || a[a.length - 1] !== '"')
	            return;
	        if (typeof b != "string")
	            return `${a.slice(0, -1)}${b}"`;
	        if (b[0] === '"')
	            return a.slice(0, -1) + b.slice(1);
	        return;
	    }
	    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
	        return `"${a}${b.slice(1)}`;
	    return;
	}
	function strConcat(c1, c2) {
	    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
	}
	exports.strConcat = strConcat;
	// TODO do not allow arrays here
	function interpolate(x) {
	    return typeof x == "number" || typeof x == "boolean" || x === null
	        ? x
	        : safeStringify(Array.isArray(x) ? x.join(",") : x);
	}
	function stringify(x) {
	    return new _Code(safeStringify(x));
	}
	exports.stringify = stringify;
	function safeStringify(x) {
	    return JSON.stringify(x)
	        .replace(/\u2028/g, "\\u2028")
	        .replace(/\u2029/g, "\\u2029");
	}
	exports.safeStringify = safeStringify;
	function getProperty(key) {
	    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
	}
	exports.getProperty = getProperty;
	//Does best effort to format the name properly
	function getEsmExportName(key) {
	    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
	        return new _Code(`${key}`);
	    }
	    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
	}
	exports.getEsmExportName = getEsmExportName;
	function regexpCode(rx) {
	    return new _Code(rx.toString());
	}
	exports.regexpCode = regexpCode;
	
} (code$1));

var scope = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
	const code_1 = code$1;
	class ValueError extends Error {
	    constructor(name) {
	        super(`CodeGen: "code" for ${name} not defined`);
	        this.value = name.value;
	    }
	}
	var UsedValueState;
	(function (UsedValueState) {
	    UsedValueState[UsedValueState["Started"] = 0] = "Started";
	    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
	})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
	exports.varKinds = {
	    const: new code_1.Name("const"),
	    let: new code_1.Name("let"),
	    var: new code_1.Name("var"),
	};
	class Scope {
	    constructor({ prefixes, parent } = {}) {
	        this._names = {};
	        this._prefixes = prefixes;
	        this._parent = parent;
	    }
	    toName(nameOrPrefix) {
	        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
	    }
	    name(prefix) {
	        return new code_1.Name(this._newName(prefix));
	    }
	    _newName(prefix) {
	        const ng = this._names[prefix] || this._nameGroup(prefix);
	        return `${prefix}${ng.index++}`;
	    }
	    _nameGroup(prefix) {
	        var _a, _b;
	        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
	            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
	        }
	        return (this._names[prefix] = { prefix, index: 0 });
	    }
	}
	exports.Scope = Scope;
	class ValueScopeName extends code_1.Name {
	    constructor(prefix, nameStr) {
	        super(nameStr);
	        this.prefix = prefix;
	    }
	    setValue(value, { property, itemIndex }) {
	        this.value = value;
	        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
	    }
	}
	exports.ValueScopeName = ValueScopeName;
	const line = (0, code_1._) `\n`;
	class ValueScope extends Scope {
	    constructor(opts) {
	        super(opts);
	        this._values = {};
	        this._scope = opts.scope;
	        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
	    }
	    get() {
	        return this._scope;
	    }
	    name(prefix) {
	        return new ValueScopeName(prefix, this._newName(prefix));
	    }
	    value(nameOrPrefix, value) {
	        var _a;
	        if (value.ref === undefined)
	            throw new Error("CodeGen: ref must be passed in value");
	        const name = this.toName(nameOrPrefix);
	        const { prefix } = name;
	        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
	        let vs = this._values[prefix];
	        if (vs) {
	            const _name = vs.get(valueKey);
	            if (_name)
	                return _name;
	        }
	        else {
	            vs = this._values[prefix] = new Map();
	        }
	        vs.set(valueKey, name);
	        const s = this._scope[prefix] || (this._scope[prefix] = []);
	        const itemIndex = s.length;
	        s[itemIndex] = value.ref;
	        name.setValue(value, { property: prefix, itemIndex });
	        return name;
	    }
	    getValue(prefix, keyOrRef) {
	        const vs = this._values[prefix];
	        if (!vs)
	            return;
	        return vs.get(keyOrRef);
	    }
	    scopeRefs(scopeName, values = this._values) {
	        return this._reduceValues(values, (name) => {
	            if (name.scopePath === undefined)
	                throw new Error(`CodeGen: name "${name}" has no value`);
	            return (0, code_1._) `${scopeName}${name.scopePath}`;
	        });
	    }
	    scopeCode(values = this._values, usedValues, getCode) {
	        return this._reduceValues(values, (name) => {
	            if (name.value === undefined)
	                throw new Error(`CodeGen: name "${name}" has no value`);
	            return name.value.code;
	        }, usedValues, getCode);
	    }
	    _reduceValues(values, valueCode, usedValues = {}, getCode) {
	        let code = code_1.nil;
	        for (const prefix in values) {
	            const vs = values[prefix];
	            if (!vs)
	                continue;
	            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
	            vs.forEach((name) => {
	                if (nameSet.has(name))
	                    return;
	                nameSet.set(name, UsedValueState.Started);
	                let c = valueCode(name);
	                if (c) {
	                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
	                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
	                }
	                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
	                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
	                }
	                else {
	                    throw new ValueError(name);
	                }
	                nameSet.set(name, UsedValueState.Completed);
	            });
	        }
	        return code;
	    }
	}
	exports.ValueScope = ValueScope;
	
} (scope));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
	const code_1 = code$1;
	const scope_1 = scope;
	var code_2 = code$1;
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
	Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
	Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
	Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
	var scope_2 = scope;
	Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
	Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
	Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
	Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
	exports.operators = {
	    GT: new code_1._Code(">"),
	    GTE: new code_1._Code(">="),
	    LT: new code_1._Code("<"),
	    LTE: new code_1._Code("<="),
	    EQ: new code_1._Code("==="),
	    NEQ: new code_1._Code("!=="),
	    NOT: new code_1._Code("!"),
	    OR: new code_1._Code("||"),
	    AND: new code_1._Code("&&"),
	    ADD: new code_1._Code("+"),
	};
	class Node {
	    optimizeNodes() {
	        return this;
	    }
	    optimizeNames(_names, _constants) {
	        return this;
	    }
	}
	class Def extends Node {
	    constructor(varKind, name, rhs) {
	        super();
	        this.varKind = varKind;
	        this.name = name;
	        this.rhs = rhs;
	    }
	    render({ es5, _n }) {
	        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
	        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
	        return `${varKind} ${this.name}${rhs};` + _n;
	    }
	    optimizeNames(names, constants) {
	        if (!names[this.name.str])
	            return;
	        if (this.rhs)
	            this.rhs = optimizeExpr(this.rhs, names, constants);
	        return this;
	    }
	    get names() {
	        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
	    }
	}
	class Assign extends Node {
	    constructor(lhs, rhs, sideEffects) {
	        super();
	        this.lhs = lhs;
	        this.rhs = rhs;
	        this.sideEffects = sideEffects;
	    }
	    render({ _n }) {
	        return `${this.lhs} = ${this.rhs};` + _n;
	    }
	    optimizeNames(names, constants) {
	        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
	            return;
	        this.rhs = optimizeExpr(this.rhs, names, constants);
	        return this;
	    }
	    get names() {
	        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
	        return addExprNames(names, this.rhs);
	    }
	}
	class AssignOp extends Assign {
	    constructor(lhs, op, rhs, sideEffects) {
	        super(lhs, rhs, sideEffects);
	        this.op = op;
	    }
	    render({ _n }) {
	        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
	    }
	}
	class Label extends Node {
	    constructor(label) {
	        super();
	        this.label = label;
	        this.names = {};
	    }
	    render({ _n }) {
	        return `${this.label}:` + _n;
	    }
	}
	class Break extends Node {
	    constructor(label) {
	        super();
	        this.label = label;
	        this.names = {};
	    }
	    render({ _n }) {
	        const label = this.label ? ` ${this.label}` : "";
	        return `break${label};` + _n;
	    }
	}
	class Throw extends Node {
	    constructor(error) {
	        super();
	        this.error = error;
	    }
	    render({ _n }) {
	        return `throw ${this.error};` + _n;
	    }
	    get names() {
	        return this.error.names;
	    }
	}
	class AnyCode extends Node {
	    constructor(code) {
	        super();
	        this.code = code;
	    }
	    render({ _n }) {
	        return `${this.code};` + _n;
	    }
	    optimizeNodes() {
	        return `${this.code}` ? this : undefined;
	    }
	    optimizeNames(names, constants) {
	        this.code = optimizeExpr(this.code, names, constants);
	        return this;
	    }
	    get names() {
	        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
	    }
	}
	class ParentNode extends Node {
	    constructor(nodes = []) {
	        super();
	        this.nodes = nodes;
	    }
	    render(opts) {
	        return this.nodes.reduce((code, n) => code + n.render(opts), "");
	    }
	    optimizeNodes() {
	        const { nodes } = this;
	        let i = nodes.length;
	        while (i--) {
	            const n = nodes[i].optimizeNodes();
	            if (Array.isArray(n))
	                nodes.splice(i, 1, ...n);
	            else if (n)
	                nodes[i] = n;
	            else
	                nodes.splice(i, 1);
	        }
	        return nodes.length > 0 ? this : undefined;
	    }
	    optimizeNames(names, constants) {
	        const { nodes } = this;
	        let i = nodes.length;
	        while (i--) {
	            // iterating backwards improves 1-pass optimization
	            const n = nodes[i];
	            if (n.optimizeNames(names, constants))
	                continue;
	            subtractNames(names, n.names);
	            nodes.splice(i, 1);
	        }
	        return nodes.length > 0 ? this : undefined;
	    }
	    get names() {
	        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
	    }
	}
	class BlockNode extends ParentNode {
	    render(opts) {
	        return "{" + opts._n + super.render(opts) + "}" + opts._n;
	    }
	}
	class Root extends ParentNode {
	}
	class Else extends BlockNode {
	}
	Else.kind = "else";
	class If extends BlockNode {
	    constructor(condition, nodes) {
	        super(nodes);
	        this.condition = condition;
	    }
	    render(opts) {
	        let code = `if(${this.condition})` + super.render(opts);
	        if (this.else)
	            code += "else " + this.else.render(opts);
	        return code;
	    }
	    optimizeNodes() {
	        super.optimizeNodes();
	        const cond = this.condition;
	        if (cond === true)
	            return this.nodes; // else is ignored here
	        let e = this.else;
	        if (e) {
	            const ns = e.optimizeNodes();
	            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
	        }
	        if (e) {
	            if (cond === false)
	                return e instanceof If ? e : e.nodes;
	            if (this.nodes.length)
	                return this;
	            return new If(not(cond), e instanceof If ? [e] : e.nodes);
	        }
	        if (cond === false || !this.nodes.length)
	            return undefined;
	        return this;
	    }
	    optimizeNames(names, constants) {
	        var _a;
	        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
	        if (!(super.optimizeNames(names, constants) || this.else))
	            return;
	        this.condition = optimizeExpr(this.condition, names, constants);
	        return this;
	    }
	    get names() {
	        const names = super.names;
	        addExprNames(names, this.condition);
	        if (this.else)
	            addNames(names, this.else.names);
	        return names;
	    }
	}
	If.kind = "if";
	class For extends BlockNode {
	}
	For.kind = "for";
	class ForLoop extends For {
	    constructor(iteration) {
	        super();
	        this.iteration = iteration;
	    }
	    render(opts) {
	        return `for(${this.iteration})` + super.render(opts);
	    }
	    optimizeNames(names, constants) {
	        if (!super.optimizeNames(names, constants))
	            return;
	        this.iteration = optimizeExpr(this.iteration, names, constants);
	        return this;
	    }
	    get names() {
	        return addNames(super.names, this.iteration.names);
	    }
	}
	class ForRange extends For {
	    constructor(varKind, name, from, to) {
	        super();
	        this.varKind = varKind;
	        this.name = name;
	        this.from = from;
	        this.to = to;
	    }
	    render(opts) {
	        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
	        const { name, from, to } = this;
	        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
	    }
	    get names() {
	        const names = addExprNames(super.names, this.from);
	        return addExprNames(names, this.to);
	    }
	}
	class ForIter extends For {
	    constructor(loop, varKind, name, iterable) {
	        super();
	        this.loop = loop;
	        this.varKind = varKind;
	        this.name = name;
	        this.iterable = iterable;
	    }
	    render(opts) {
	        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
	    }
	    optimizeNames(names, constants) {
	        if (!super.optimizeNames(names, constants))
	            return;
	        this.iterable = optimizeExpr(this.iterable, names, constants);
	        return this;
	    }
	    get names() {
	        return addNames(super.names, this.iterable.names);
	    }
	}
	class Func extends BlockNode {
	    constructor(name, args, async) {
	        super();
	        this.name = name;
	        this.args = args;
	        this.async = async;
	    }
	    render(opts) {
	        const _async = this.async ? "async " : "";
	        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
	    }
	}
	Func.kind = "func";
	class Return extends ParentNode {
	    render(opts) {
	        return "return " + super.render(opts);
	    }
	}
	Return.kind = "return";
	class Try extends BlockNode {
	    render(opts) {
	        let code = "try" + super.render(opts);
	        if (this.catch)
	            code += this.catch.render(opts);
	        if (this.finally)
	            code += this.finally.render(opts);
	        return code;
	    }
	    optimizeNodes() {
	        var _a, _b;
	        super.optimizeNodes();
	        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
	        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
	        return this;
	    }
	    optimizeNames(names, constants) {
	        var _a, _b;
	        super.optimizeNames(names, constants);
	        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
	        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
	        return this;
	    }
	    get names() {
	        const names = super.names;
	        if (this.catch)
	            addNames(names, this.catch.names);
	        if (this.finally)
	            addNames(names, this.finally.names);
	        return names;
	    }
	}
	class Catch extends BlockNode {
	    constructor(error) {
	        super();
	        this.error = error;
	    }
	    render(opts) {
	        return `catch(${this.error})` + super.render(opts);
	    }
	}
	Catch.kind = "catch";
	class Finally extends BlockNode {
	    render(opts) {
	        return "finally" + super.render(opts);
	    }
	}
	Finally.kind = "finally";
	class CodeGen {
	    constructor(extScope, opts = {}) {
	        this._values = {};
	        this._blockStarts = [];
	        this._constants = {};
	        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
	        this._extScope = extScope;
	        this._scope = new scope_1.Scope({ parent: extScope });
	        this._nodes = [new Root()];
	    }
	    toString() {
	        return this._root.render(this.opts);
	    }
	    // returns unique name in the internal scope
	    name(prefix) {
	        return this._scope.name(prefix);
	    }
	    // reserves unique name in the external scope
	    scopeName(prefix) {
	        return this._extScope.name(prefix);
	    }
	    // reserves unique name in the external scope and assigns value to it
	    scopeValue(prefixOrName, value) {
	        const name = this._extScope.value(prefixOrName, value);
	        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
	        vs.add(name);
	        return name;
	    }
	    getScopeValue(prefix, keyOrRef) {
	        return this._extScope.getValue(prefix, keyOrRef);
	    }
	    // return code that assigns values in the external scope to the names that are used internally
	    // (same names that were returned by gen.scopeName or gen.scopeValue)
	    scopeRefs(scopeName) {
	        return this._extScope.scopeRefs(scopeName, this._values);
	    }
	    scopeCode() {
	        return this._extScope.scopeCode(this._values);
	    }
	    _def(varKind, nameOrPrefix, rhs, constant) {
	        const name = this._scope.toName(nameOrPrefix);
	        if (rhs !== undefined && constant)
	            this._constants[name.str] = rhs;
	        this._leafNode(new Def(varKind, name, rhs));
	        return name;
	    }
	    // `const` declaration (`var` in es5 mode)
	    const(nameOrPrefix, rhs, _constant) {
	        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
	    }
	    // `let` declaration with optional assignment (`var` in es5 mode)
	    let(nameOrPrefix, rhs, _constant) {
	        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
	    }
	    // `var` declaration with optional assignment
	    var(nameOrPrefix, rhs, _constant) {
	        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
	    }
	    // assignment code
	    assign(lhs, rhs, sideEffects) {
	        return this._leafNode(new Assign(lhs, rhs, sideEffects));
	    }
	    // `+=` code
	    add(lhs, rhs) {
	        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
	    }
	    // appends passed SafeExpr to code or executes Block
	    code(c) {
	        if (typeof c == "function")
	            c();
	        else if (c !== code_1.nil)
	            this._leafNode(new AnyCode(c));
	        return this;
	    }
	    // returns code for object literal for the passed argument list of key-value pairs
	    object(...keyValues) {
	        const code = ["{"];
	        for (const [key, value] of keyValues) {
	            if (code.length > 1)
	                code.push(",");
	            code.push(key);
	            if (key !== value || this.opts.es5) {
	                code.push(":");
	                (0, code_1.addCodeArg)(code, value);
	            }
	        }
	        code.push("}");
	        return new code_1._Code(code);
	    }
	    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
	    if(condition, thenBody, elseBody) {
	        this._blockNode(new If(condition));
	        if (thenBody && elseBody) {
	            this.code(thenBody).else().code(elseBody).endIf();
	        }
	        else if (thenBody) {
	            this.code(thenBody).endIf();
	        }
	        else if (elseBody) {
	            throw new Error('CodeGen: "else" body without "then" body');
	        }
	        return this;
	    }
	    // `else if` clause - invalid without `if` or after `else` clauses
	    elseIf(condition) {
	        return this._elseNode(new If(condition));
	    }
	    // `else` clause - only valid after `if` or `else if` clauses
	    else() {
	        return this._elseNode(new Else());
	    }
	    // end `if` statement (needed if gen.if was used only with condition)
	    endIf() {
	        return this._endBlockNode(If, Else);
	    }
	    _for(node, forBody) {
	        this._blockNode(node);
	        if (forBody)
	            this.code(forBody).endFor();
	        return this;
	    }
	    // a generic `for` clause (or statement if `forBody` is passed)
	    for(iteration, forBody) {
	        return this._for(new ForLoop(iteration), forBody);
	    }
	    // `for` statement for a range of values
	    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
	        const name = this._scope.toName(nameOrPrefix);
	        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
	    }
	    // `for-of` statement (in es5 mode replace with a normal for loop)
	    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
	        const name = this._scope.toName(nameOrPrefix);
	        if (this.opts.es5) {
	            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
	            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
	                this.var(name, (0, code_1._) `${arr}[${i}]`);
	                forBody(name);
	            });
	        }
	        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
	    }
	    // `for-in` statement.
	    // With option `ownProperties` replaced with a `for-of` loop for object keys
	    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
	        if (this.opts.ownProperties) {
	            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
	        }
	        const name = this._scope.toName(nameOrPrefix);
	        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
	    }
	    // end `for` loop
	    endFor() {
	        return this._endBlockNode(For);
	    }
	    // `label` statement
	    label(label) {
	        return this._leafNode(new Label(label));
	    }
	    // `break` statement
	    break(label) {
	        return this._leafNode(new Break(label));
	    }
	    // `return` statement
	    return(value) {
	        const node = new Return();
	        this._blockNode(node);
	        this.code(value);
	        if (node.nodes.length !== 1)
	            throw new Error('CodeGen: "return" should have one node');
	        return this._endBlockNode(Return);
	    }
	    // `try` statement
	    try(tryBody, catchCode, finallyCode) {
	        if (!catchCode && !finallyCode)
	            throw new Error('CodeGen: "try" without "catch" and "finally"');
	        const node = new Try();
	        this._blockNode(node);
	        this.code(tryBody);
	        if (catchCode) {
	            const error = this.name("e");
	            this._currNode = node.catch = new Catch(error);
	            catchCode(error);
	        }
	        if (finallyCode) {
	            this._currNode = node.finally = new Finally();
	            this.code(finallyCode);
	        }
	        return this._endBlockNode(Catch, Finally);
	    }
	    // `throw` statement
	    throw(error) {
	        return this._leafNode(new Throw(error));
	    }
	    // start self-balancing block
	    block(body, nodeCount) {
	        this._blockStarts.push(this._nodes.length);
	        if (body)
	            this.code(body).endBlock(nodeCount);
	        return this;
	    }
	    // end the current self-balancing block
	    endBlock(nodeCount) {
	        const len = this._blockStarts.pop();
	        if (len === undefined)
	            throw new Error("CodeGen: not in self-balancing block");
	        const toClose = this._nodes.length - len;
	        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
	            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
	        }
	        this._nodes.length = len;
	        return this;
	    }
	    // `function` heading (or definition if funcBody is passed)
	    func(name, args = code_1.nil, async, funcBody) {
	        this._blockNode(new Func(name, args, async));
	        if (funcBody)
	            this.code(funcBody).endFunc();
	        return this;
	    }
	    // end function definition
	    endFunc() {
	        return this._endBlockNode(Func);
	    }
	    optimize(n = 1) {
	        while (n-- > 0) {
	            this._root.optimizeNodes();
	            this._root.optimizeNames(this._root.names, this._constants);
	        }
	    }
	    _leafNode(node) {
	        this._currNode.nodes.push(node);
	        return this;
	    }
	    _blockNode(node) {
	        this._currNode.nodes.push(node);
	        this._nodes.push(node);
	    }
	    _endBlockNode(N1, N2) {
	        const n = this._currNode;
	        if (n instanceof N1 || (N2 && n instanceof N2)) {
	            this._nodes.pop();
	            return this;
	        }
	        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
	    }
	    _elseNode(node) {
	        const n = this._currNode;
	        if (!(n instanceof If)) {
	            throw new Error('CodeGen: "else" without "if"');
	        }
	        this._currNode = n.else = node;
	        return this;
	    }
	    get _root() {
	        return this._nodes[0];
	    }
	    get _currNode() {
	        const ns = this._nodes;
	        return ns[ns.length - 1];
	    }
	    set _currNode(node) {
	        const ns = this._nodes;
	        ns[ns.length - 1] = node;
	    }
	}
	exports.CodeGen = CodeGen;
	function addNames(names, from) {
	    for (const n in from)
	        names[n] = (names[n] || 0) + (from[n] || 0);
	    return names;
	}
	function addExprNames(names, from) {
	    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
	}
	function optimizeExpr(expr, names, constants) {
	    if (expr instanceof code_1.Name)
	        return replaceName(expr);
	    if (!canOptimize(expr))
	        return expr;
	    return new code_1._Code(expr._items.reduce((items, c) => {
	        if (c instanceof code_1.Name)
	            c = replaceName(c);
	        if (c instanceof code_1._Code)
	            items.push(...c._items);
	        else
	            items.push(c);
	        return items;
	    }, []));
	    function replaceName(n) {
	        const c = constants[n.str];
	        if (c === undefined || names[n.str] !== 1)
	            return n;
	        delete names[n.str];
	        return c;
	    }
	    function canOptimize(e) {
	        return (e instanceof code_1._Code &&
	            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
	    }
	}
	function subtractNames(names, from) {
	    for (const n in from)
	        names[n] = (names[n] || 0) - (from[n] || 0);
	}
	function not(x) {
	    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
	}
	exports.not = not;
	const andCode = mappend(exports.operators.AND);
	// boolean AND (&&) expression with the passed arguments
	function and(...args) {
	    return args.reduce(andCode);
	}
	exports.and = and;
	const orCode = mappend(exports.operators.OR);
	// boolean OR (||) expression with the passed arguments
	function or(...args) {
	    return args.reduce(orCode);
	}
	exports.or = or;
	function mappend(op) {
	    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
	}
	function par(x) {
	    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
	}
	
} (codegen));

var util = {};

Object.defineProperty(util, "__esModule", { value: true });
util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
const codegen_1$v = codegen;
const code_1$a = code$1;
// TODO refactor to use Set
function toHash(arr) {
    const hash = {};
    for (const item of arr)
        hash[item] = true;
    return hash;
}
util.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
}
util.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self } = it;
    if (!opts.strictSchema)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
    }
}
util.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
}
util.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
}
util.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return (0, codegen_1$v._) `${schema}`;
    }
    return (0, codegen_1$v._) `${topSchemaRef}${schemaPath}${(0, codegen_1$v.getProperty)(keyword)}`;
}
util.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
util.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
util.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    }
    else {
        f(xs);
    }
}
util.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen_1$v.Name
                ? (from instanceof codegen_1$v.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen_1$v.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen_1$v.Name && !(res instanceof codegen_1$v.Name) ? resultToName(gen, res) : res;
    };
}
util.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._) `${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1$v._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$v._) `${to} || {}`).code((0, codegen_1$v._) `Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._) `${to} !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            }
            else {
                gen.assign(to, (0, codegen_1$v._) `${to} || {}`);
                setEvaluated(gen, to, from);
            }
        }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
    }),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1$v._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$v._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1$v._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$v._) `${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    }),
};
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1$v._) `{}`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
}
util.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1$v._) `${props}${(0, codegen_1$v.getProperty)(p)}`, true));
}
util.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
    return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1$a._Code(f.code)),
    });
}
util.useFunc = useFunc;
var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
})(Type || (util.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen_1$v.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? (0, codegen_1$v._) `"[" + ${dataProp} + "]"`
                : (0, codegen_1$v._) `"['" + ${dataProp} + "']"`
            : isNumber
                ? (0, codegen_1$v._) `"/" + ${dataProp}`
                : (0, codegen_1$v._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    }
    return jsPropertySyntax ? (0, codegen_1$v.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
        return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
}
util.checkStrictMode = checkStrictMode;

var names$1 = {};

Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$u = codegen;
const names = {
    // validation function arguments
    data: new codegen_1$u.Name("data"), // data passed to validation function
    // args passed from referencing schema
    valCxt: new codegen_1$u.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new codegen_1$u.Name("instancePath"),
    parentData: new codegen_1$u.Name("parentData"),
    parentDataProperty: new codegen_1$u.Name("parentDataProperty"),
    rootData: new codegen_1$u.Name("rootData"), // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new codegen_1$u.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new codegen_1$u.Name("vErrors"), // null or array of validation errors
    errors: new codegen_1$u.Name("errors"), // counter of validation errors
    this: new codegen_1$u.Name("this"),
    // "globals"
    self: new codegen_1$u.Name("self"),
    scope: new codegen_1$u.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1$u.Name("json"),
    jsonPos: new codegen_1$u.Name("jsonPos"),
    jsonLen: new codegen_1$u.Name("jsonLen"),
    jsonPart: new codegen_1$u.Name("jsonPart"),
};
names$1.default = names;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
	const codegen_1 = codegen;
	const util_1 = util;
	const names_1 = names$1;
	exports.keywordError = {
	    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
	};
	exports.keyword$DataError = {
	    message: ({ keyword, schemaType }) => schemaType
	        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
	        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
	};
	function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
	        addError(gen, errObj);
	    }
	    else {
	        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
	    }
	}
	exports.reportError = reportError;
	function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
	    const { it } = cxt;
	    const { gen, compositeRule, allErrors } = it;
	    const errObj = errorObjectCode(cxt, error, errorPaths);
	    addError(gen, errObj);
	    if (!(compositeRule || allErrors)) {
	        returnErrors(it, names_1.default.vErrors);
	    }
	}
	exports.reportExtraError = reportExtraError;
	function resetErrorsCount(gen, errsCount) {
	    gen.assign(names_1.default.errors, errsCount);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
	}
	exports.resetErrorsCount = resetErrorsCount;
	function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
	    /* istanbul ignore if */
	    if (errsCount === undefined)
	        throw new Error("ajv implementation error");
	    const err = gen.name("err");
	    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
	        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
	        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
	        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
	        if (it.opts.verbose) {
	            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
	            gen.assign((0, codegen_1._) `${err}.data`, data);
	        }
	    });
	}
	exports.extendErrors = extendErrors;
	function addError(gen, errObj) {
	    const err = gen.const("err", errObj);
	    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
	    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
	}
	function returnErrors(it, errs) {
	    const { gen, validateName, schemaEnv } = it;
	    if (schemaEnv.$async) {
	        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
	        gen.return(false);
	    }
	}
	const E = {
	    keyword: new codegen_1.Name("keyword"),
	    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
	    params: new codegen_1.Name("params"),
	    propertyName: new codegen_1.Name("propertyName"),
	    message: new codegen_1.Name("message"),
	    schema: new codegen_1.Name("schema"),
	    parentSchema: new codegen_1.Name("parentSchema"),
	};
	function errorObjectCode(cxt, error, errorPaths) {
	    const { createErrors } = cxt.it;
	    if (createErrors === false)
	        return (0, codegen_1._) `{}`;
	    return errorObject(cxt, error, errorPaths);
	}
	function errorObject(cxt, error, errorPaths = {}) {
	    const { gen, it } = cxt;
	    const keyValues = [
	        errorInstancePath(it, errorPaths),
	        errorSchemaPath(cxt, errorPaths),
	    ];
	    extraErrorProps(cxt, error, keyValues);
	    return gen.object(...keyValues);
	}
	function errorInstancePath({ errorPath }, { instancePath }) {
	    const instPath = instancePath
	        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
	        : errorPath;
	    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
	}
	function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
	    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
	    if (schemaPath) {
	        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
	    }
	    return [E.schemaPath, schPath];
	}
	function extraErrorProps(cxt, { params, message }, keyValues) {
	    const { keyword, data, schemaValue, it } = cxt;
	    const { opts, propertyName, topSchemaRef, schemaPath } = it;
	    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
	    if (opts.messages) {
	        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
	    }
	    if (opts.verbose) {
	        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
	    }
	    if (propertyName)
	        keyValues.push([E.propertyName, propertyName]);
	}
	
} (errors));

Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors;
const codegen_1$t = codegen;
const names_1$6 = names$1;
const boolError = {
    message: "boolean schema is false",
};
function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
        falseSchemaError(it, false);
    }
    else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1$6.default.data);
    }
    else {
        gen.assign((0, codegen_1$t._) `${validateName}.errors`, null);
        gen.return(true);
    }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
        gen.var(valid, false); // TODO var
        falseSchemaError(it);
    }
    else {
        gen.var(valid, true); // TODO var
    }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    // TODO maybe some other interface should be used for non-keyword validation errors...
    const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
    };
    (0, errors_1$3.reportError)(cxt, boolError, undefined, overrideAllErrors);
}

var dataType = {};

var rules = {};

Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
rules.getRules = getRules;

var applicability = {};

Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
applicability.shouldUseRule = shouldUseRule;

Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const util_1$q = util;
var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    }
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
            types.push("null");
    }
    return types;
}
dataType.getSchemaTypes = getSchemaTypes;
// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        });
    }
    return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
}
function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1$s._) `typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1$s._) `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1$s._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
            .assign(data, (0, codegen_1$s._) `${data}[0]`)
            .assign(dataType, (0, codegen_1$s._) `typeof ${data}`)
            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1$s._) `${coerced} !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1$s._) `${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf((0, codegen_1$s._) `${dataType} == "number" || ${dataType} == "boolean"`)
                    .assign(coerced, (0, codegen_1$s._) `"" + ${data}`)
                    .elseIf((0, codegen_1$s._) `${data} === null`)
                    .assign(coerced, (0, codegen_1$s._) `""`);
                return;
            case "number":
                gen
                    .elseIf((0, codegen_1$s._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                    .assign(coerced, (0, codegen_1$s._) `+${data}`);
                return;
            case "integer":
                gen
                    .elseIf((0, codegen_1$s._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                    .assign(coerced, (0, codegen_1$s._) `+${data}`);
                return;
            case "boolean":
                gen
                    .elseIf((0, codegen_1$s._) `${data} === "false" || ${data} === 0 || ${data} === null`)
                    .assign(coerced, false)
                    .elseIf((0, codegen_1$s._) `${data} === "true" || ${data} === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf((0, codegen_1$s._) `${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf((0, codegen_1$s._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                    .assign(coerced, (0, codegen_1$s._) `[${data}]`);
        }
    }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    // TODO use gen.property
    gen.if((0, codegen_1$s._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1$s._) `${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1$s.operators.EQ : codegen_1$s.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return (0, codegen_1$s._) `${data} ${EQ} null`;
        case "array":
            cond = (0, codegen_1$s._) `Array.isArray(${data})`;
            break;
        case "object":
            cond = (0, codegen_1$s._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
        case "integer":
            cond = numCond((0, codegen_1$s._) `!(${data} % 1) && !isNaN(${data})`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return (0, codegen_1$s._) `typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1$s.not)(cond);
    function numCond(_cond = codegen_1$s.nil) {
        return (0, codegen_1$s.and)((0, codegen_1$s._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$s._) `isFinite(${data})` : codegen_1$s.nil);
    }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1$q.toHash)(dataTypes);
    if (types.array && types.object) {
        const notObj = (0, codegen_1$s._) `typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1$s._) `!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
    }
    else {
        cond = codegen_1$s.nil;
    }
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = (0, codegen_1$s.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1$s._) `{type: ${schema}}` : (0, codegen_1$s._) `{type: ${schemaValue}}`,
};
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1$q.schemaRefOrVal)(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
    };
}

var defaults = {};

Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$p = util;
function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = (0, codegen_1$r._) `${data}${(0, codegen_1$r.getProperty)(prop)}`;
    if (compositeRule) {
        (0, util_1$p.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = (0, codegen_1$r._) `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = (0, codegen_1$r._) `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, (0, codegen_1$r._) `${childData} = ${(0, codegen_1$r.stringify)(defaultValue)}`);
}

var keyword = {};

var code = {};

Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$o = util;
const names_1$5 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1$q._) `${prop}` }, true);
        cxt.error();
    });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1$q.or)(...properties.map((prop) => (0, codegen_1$q.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$q._) `${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1$q._) `Object.prototype.hasOwnProperty`,
    });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return (0, codegen_1$q._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1$q._) `${data}${(0, codegen_1$q.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1$q._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1$q._) `${data}${(0, codegen_1$q.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1$q.or)(cond, (0, codegen_1$q.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$o.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1$q._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1$5.default.instancePath, (0, codegen_1$q.strConcat)(names_1$5.default.instancePath, errorPath)],
        [names_1$5.default.parentData, it.parentData],
        [names_1$5.default.parentDataProperty, it.parentDataProperty],
        [names_1$5.default.rootData, names_1$5.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
    const args = (0, codegen_1$q._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1$q.nil ? (0, codegen_1$q._) `${func}.call(${context}, ${args})` : (0, codegen_1$q._) `${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$q._) `new RegExp`;
function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1$q._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`,
    });
}
code.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1$q._) `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: util_1$o.Type.Num,
            }, valid);
            gen.if((0, codegen_1$q.not)(valid), notValid);
        });
    }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1$o.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, (0, codegen_1$q._) `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if((0, codegen_1$q.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;

Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1$p.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        }
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        }
    }
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1$p._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1$p._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$p._) `${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
    }
    function validateSync() {
        const validateErrs = (0, codegen_1$p._) `${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1$p.nil);
        return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1$p._) `await ` : codegen_1$p.nil) {
        const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, (0, codegen_1$p._) `${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
        var _a;
        gen.if((0, codegen_1$p.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1$p._) `${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1$p._) `Array.isArray(${errs})`, () => {
        gen
            .assign(names_1$4.default.vErrors, (0, codegen_1$p._) `${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`)
            .assign(names_1$4.default.errors, (0, codegen_1$p._) `${names_1$4.default.vErrors}.length`);
        (0, errors_1$1.extendErrors)(cxt);
    }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$p.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
                self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        }
    }
}
keyword.validateKeywordUsage = validateKeywordUsage;

var subschema = {};

Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$n = util;
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1$o._) `${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1$o._) `${it.schemaPath}${(0, codegen_1$o.getProperty)(keyword)}${(0, codegen_1$o.getProperty)(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1$n.escapeFragment)(schemaProp)}`,
            };
    }
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        };
    }
    throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1$o._) `${it.data}${(0, codegen_1$o.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1$o.str) `${errorPath}${(0, util_1$n.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1$o._) `${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
        const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    }
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
}
subschema.extendSubschemaMode = extendSubschemaMode;

var resolve$2 = {};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var jsonSchemaTraverse = {exports: {}};

var traverse$1 = jsonSchemaTraverse.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || (opts.allKeys && !(key in traverse$1.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;

Object.defineProperty(resolve$2, "__esModule", { value: true });
resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
const util_1$m = util;
const equal$3 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
resolve$2.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1$m.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
}
resolve$2.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
}
resolve$2._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$2.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
}
resolve$2.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const _resolve = this.opts.uriResolver.resolve;
            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal$3(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
resolve$2.getSchemaRefs = getSchemaRefs;

Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$2;
const util_1$l = util;
const errors_1 = errors;
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1$n._) `${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1$n._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, (0, codegen_1$n._) `${names_1$3.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
}
function destructureValCxt(opts) {
    return (0, codegen_1$n._) `{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts.dynamicRef ? (0, codegen_1$n._) `, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
    gen.if(names_1$3.default.valCxt, () => {
        gen.var(names_1$3.default.instancePath, (0, codegen_1$n._) `${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
        gen.var(names_1$3.default.parentData, (0, codegen_1$n._) `${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
        gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._) `${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
        gen.var(names_1$3.default.rootData, (0, codegen_1$n._) `${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
        if (opts.dynamicRef)
            gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._) `${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
    }, () => {
        gen.var(names_1$3.default.instancePath, (0, codegen_1$n._) `""`);
        gen.var(names_1$3.default.parentData, (0, codegen_1$n._) `undefined`);
        gen.var(names_1$3.default.parentDataProperty, (0, codegen_1$n._) `undefined`);
        gen.var(names_1$3.default.rootData, names_1$3.default.data);
        if (opts.dynamicRef)
            gen.var(names_1$3.default.dynamicAnchors, (0, codegen_1$n._) `{}`);
    });
}
function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1$3.default.vErrors, null);
        gen.let(names_1$3.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1$n._) `${validateName}.evaluated`);
    gen.if((0, codegen_1$n._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$n._) `${it.evaluated}.props`, (0, codegen_1$n._) `undefined`));
    gen.if((0, codegen_1$n._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$n._) `${it.evaluated}.items`, (0, codegen_1$n._) `undefined`));
}
function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$n._) `/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
}
function schemaCxtHasRules({ schema, self }) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1$3.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, (0, codegen_1$n._) `${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
    (0, util_1$l.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1$1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1$l.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
}
function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
        (0, util_1$l.checkStrictMode)(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
        it.baseId = (0, resolve_1$2.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
}
function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code((0, codegen_1$n._) `${names_1$3.default.self}.logger.log(${msg})`);
    }
    else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1$n.str) `${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1$n._) `${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
}
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if((0, codegen_1$n._) `${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw((0, codegen_1$n._) `new ${ValidationError}(${names_1$3.default.vErrors})`));
    }
    else {
        gen.assign((0, codegen_1$n._) `${validateName}.errors`, names_1$3.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return((0, codegen_1$n._) `${names_1$3.default.errors} === 0`);
    }
}
function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1$n.Name)
        gen.assign((0, codegen_1$n._) `${evaluated}.props`, props);
    if (items instanceof codegen_1$n.Name)
        gen.assign((0, codegen_1$n._) `${evaluated}.items`, items);
}
function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self } = it;
    const { RULES } = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$l.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
        if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if((0, codegen_1$n._) `${names_1$3.default.errors} === ${errsCount || 0}`);
    }
}
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults }, } = it;
    if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
    });
    narrowSchemaTypes(it, types);
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
            ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
            ts.push("integer");
    }
    it.dataTypes = ts;
}
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1$l.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
    constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1$l.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
        }
    }
    result(condition, successAction, failAction) {
        this.failResult((0, codegen_1$n.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
    }
    pass(condition, failAction) {
        this.failResult((0, codegen_1$n.not)(condition), undefined, failAction);
    }
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    }
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1$n._) `${schemaCode} !== undefined && (${(0, codegen_1$n.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
        if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
        }
        this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    }
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1$n.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        });
    }
    check$data(valid = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1$n.or)((0, codegen_1$n._) `${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1$n.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1$n.nil)
                gen.assign(valid, false);
        }
        gen.else();
    }
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1$n.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1$n.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return (0, codegen_1$n._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1$n.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return (0, codegen_1$n._) `!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1$n.nil;
        }
    }
    subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
        subschemaCode(nextContext, valid);
        return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1$l.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1$l.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    }
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
            return true;
        }
    }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
    }
    else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1$3.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1$3.default.rootData;
    }
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = (0, codegen_1$n._) `${data}${(0, codegen_1$n.getProperty)((0, util_1$l.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1$n._) `${expr} && ${data}`;
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
}
validate.getData = getData;

var validation_error = {};

Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
validation_error.default = ValidationError;

var ref_error = {};

Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$2;
class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
    }
}
ref_error.default = MissingRefError;

var compile = {};

Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$2;
const util_1$k = util;
const validate_1$1 = validate;
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
compile.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1$m._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$2.default.data,
        parentData: names_1$2.default.parentData,
        parentDataProperty: names_1$2.default.parentDataProperty,
        dataNames: [names_1$2.default.data],
        dataPathArr: [codegen_1$m.nil], // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1$m.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$m.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$m._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1$m.Name ? undefined : props,
                items: items instanceof codegen_1$m.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1$m.Name,
                dynamicItems: items instanceof codegen_1$m.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1$m.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve$1.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve$1(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1$k.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1$k.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}

const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
	"$data"
];
const properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
const additionalProperties$1 = false;
const require$$9 = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

var uri$1 = {};

var fastUri$1 = {exports: {}};

const HEX$1 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

var scopedChars = {
  HEX: HEX$1
};

const { HEX } = scopedChars;

function normalizeIPv4$1 (host) {
  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }
  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
  const [address] = matches;
  if (address) {
    return { host: stripLeadingZeros(address, '.'), isIPV4: true }
  } else {
    return { host, isIPV4: false }
  }
}

/**
 * @param {string[]} input
 * @param {boolean} [keepZero=false]
 * @returns {string|undefined}
 */
function stringArrayToHexStripped (input, keepZero = false) {
  let acc = '';
  let strip = true;
  for (const c of input) {
    if (HEX[c] === undefined) return undefined
    if (c !== '0' && strip === true) strip = false;
    if (!strip) acc += c;
  }
  if (keepZero && acc.length === 0) acc = '0';
  return acc
}

function getIPV6 (input) {
  let tokenCount = 0;
  const output = { error: false, address: '', zone: '' };
  const address = [];
  const buffer = [];
  let isZone = false;
  let endipv6Encountered = false;
  let endIpv6 = false;

  function consume () {
    if (buffer.length) {
      if (isZone === false) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== undefined) {
          address.push(hex);
        } else {
          output.error = true;
          return false
        }
      }
      buffer.length = 0;
    }
    return true
  }

  for (let i = 0; i < input.length; i++) {
    const cursor = input[i];
    if (cursor === '[' || cursor === ']') { continue }
    if (cursor === ':') {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume()) { break }
      tokenCount++;
      address.push(':');
      if (tokenCount > 7) {
        // not valid
        output.error = true;
        break
      }
      if (i - 1 >= 0 && input[i - 1] === ':') {
        endipv6Encountered = true;
      }
      continue
    } else if (cursor === '%') {
      if (!consume()) { break }
      // switch to zone detection
      isZone = true;
    } else {
      buffer.push(cursor);
      continue
    }
  }
  if (buffer.length) {
    if (isZone) {
      output.zone = buffer.join('');
    } else if (endIpv6) {
      address.push(buffer.join(''));
    } else {
      address.push(stringArrayToHexStripped(buffer));
    }
  }
  output.address = address.join('');
  return output
}

function normalizeIPv6$1 (host, opts = {}) {
  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
  const ipv6 = getIPV6(host);

  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += '%' + ipv6.zone;
      escapedHost += '%25' + ipv6.zone;
    }
    return { host: newHost, escapedHost, isIPV6: true }
  } else {
    return { host, isIPV6: false }
  }
}

function stripLeadingZeros (str, token) {
  let out = '';
  let skip = true;
  const l = str.length;
  for (let i = 0; i < l; i++) {
    const c = str[i];
    if (c === '0' && skip) {
      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {
        out += c;
        skip = false;
      }
    } else {
      if (c === token) {
        skip = true;
      } else {
        skip = false;
      }
      out += c;
    }
  }
  return out
}

function findToken (str, token) {
  let ind = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token) ind++;
  }
  return ind
}

const RDS1 = /^\.\.?\//u;
const RDS2 = /^\/\.(?:\/|$)/u;
const RDS3 = /^\/\.\.(?:\/|$)/u;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;

function removeDotSegments$1 (input) {
  const output = [];

  while (input.length) {
    if (input.match(RDS1)) {
      input = input.replace(RDS1, '');
    } else if (input.match(RDS2)) {
      input = input.replace(RDS2, '/');
    } else if (input.match(RDS3)) {
      input = input.replace(RDS3, '/');
      output.pop();
    } else if (input === '.' || input === '..') {
      input = '';
    } else {
      const im = input.match(RDS5);
      if (im) {
        const s = im[0];
        input = input.slice(s.length);
        output.push(s);
      } else {
        throw new Error('Unexpected dot segment condition')
      }
    }
  }
  return output.join('')
}

function normalizeComponentEncoding$1 (components, esc) {
  const func = esc !== true ? escape : unescape;
  if (components.scheme !== undefined) {
    components.scheme = func(components.scheme);
  }
  if (components.userinfo !== undefined) {
    components.userinfo = func(components.userinfo);
  }
  if (components.host !== undefined) {
    components.host = func(components.host);
  }
  if (components.path !== undefined) {
    components.path = func(components.path);
  }
  if (components.query !== undefined) {
    components.query = func(components.query);
  }
  if (components.fragment !== undefined) {
    components.fragment = func(components.fragment);
  }
  return components
}

function recomposeAuthority$1 (components, options) {
  const uriTokens = [];

  if (components.userinfo !== undefined) {
    uriTokens.push(components.userinfo);
    uriTokens.push('@');
  }

  if (components.host !== undefined) {
    let host = unescape(components.host);
    const ipV4res = normalizeIPv4$1(host);

    if (ipV4res.isIPV4) {
      host = ipV4res.host;
    } else {
      const ipV6res = normalizeIPv6$1(ipV4res.host, { isIPV4: false });
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = components.host;
      }
    }
    uriTokens.push(host);
  }

  if (typeof components.port === 'number' || typeof components.port === 'string') {
    uriTokens.push(':');
    uriTokens.push(String(components.port));
  }

  return uriTokens.length ? uriTokens.join('') : undefined
}
var utils = {
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  normalizeIPv4: normalizeIPv4$1,
  normalizeIPv6: normalizeIPv6$1,
  stringArrayToHexStripped
};

const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

function isSecure (wsComponents) {
  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'
}

function httpParse (components) {
  if (!components.host) {
    components.error = components.error || 'HTTP URIs must have a host.';
  }

  return components
}

function httpSerialize (components) {
  const secure = String(components.scheme).toLowerCase() === 'https';

  // normalize the default port
  if (components.port === (secure ? 443 : 80) || components.port === '') {
    components.port = undefined;
  }

  // normalize the empty path
  if (!components.path) {
    components.path = '/';
  }

  // NOTE: We do not parse query strings for HTTP URIs
  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
  // and not the HTTP spec.

  return components
}

function wsParse (wsComponents) {
// indicate if the secure flag is set
  wsComponents.secure = isSecure(wsComponents);

  // construct resouce name
  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
  wsComponents.path = undefined;
  wsComponents.query = undefined;

  return wsComponents
}

function wsSerialize (wsComponents) {
// normalize the default port
  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {
    wsComponents.port = undefined;
  }

  // ensure scheme matches secure flag
  if (typeof wsComponents.secure === 'boolean') {
    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws');
    wsComponents.secure = undefined;
  }

  // reconstruct path from resource name
  if (wsComponents.resourceName) {
    const [path, query] = wsComponents.resourceName.split('?');
    wsComponents.path = (path && path !== '/' ? path : undefined);
    wsComponents.query = query;
    wsComponents.resourceName = undefined;
  }

  // forbid fragment component
  wsComponents.fragment = undefined;

  return wsComponents
}

function urnParse (urnComponents, options) {
  if (!urnComponents.path) {
    urnComponents.error = 'URN can not be parsed';
    return urnComponents
  }
  const matches = urnComponents.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponents.scheme || 'urn';
    urnComponents.nid = matches[1].toLowerCase();
    urnComponents.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
    const schemeHandler = SCHEMES$1[urnScheme];
    urnComponents.path = undefined;

    if (schemeHandler) {
      urnComponents = schemeHandler.parse(urnComponents, options);
    }
  } else {
    urnComponents.error = urnComponents.error || 'URN can not be parsed.';
  }

  return urnComponents
}

function urnSerialize (urnComponents, options) {
  const scheme = options.scheme || urnComponents.scheme || 'urn';
  const nid = urnComponents.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = SCHEMES$1[urnScheme];

  if (schemeHandler) {
    urnComponents = schemeHandler.serialize(urnComponents, options);
  }

  const uriComponents = urnComponents;
  const nss = urnComponents.nss;
  uriComponents.path = `${nid || options.nid}:${nss}`;

  options.skipEscape = true;
  return uriComponents
}

function urnuuidParse (urnComponents, options) {
  const uuidComponents = urnComponents;
  uuidComponents.uuid = uuidComponents.nss;
  uuidComponents.nss = undefined;

  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
    uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
  }

  return uuidComponents
}

function urnuuidSerialize (uuidComponents) {
  const urnComponents = uuidComponents;
  // normalize UUID
  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
  return urnComponents
}

const http = {
  scheme: 'http',
  domainHost: true,
  parse: httpParse,
  serialize: httpSerialize
};

const https = {
  scheme: 'https',
  domainHost: http.domainHost,
  parse: httpParse,
  serialize: httpSerialize
};

const ws = {
  scheme: 'ws',
  domainHost: true,
  parse: wsParse,
  serialize: wsSerialize
};

const wss = {
  scheme: 'wss',
  domainHost: ws.domainHost,
  parse: ws.parse,
  serialize: ws.serialize
};

const urn = {
  scheme: 'urn',
  parse: urnParse,
  serialize: urnSerialize,
  skipNormalize: true
};

const urnuuid = {
  scheme: 'urn:uuid',
  parse: urnuuidParse,
  serialize: urnuuidSerialize,
  skipNormalize: true
};

const SCHEMES$1 = {
  http,
  https,
  ws,
  wss,
  urn,
  'urn:uuid': urnuuid
};

var schemes = SCHEMES$1;

const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = utils;
const SCHEMES = schemes;

function normalize$1 (uri, options) {
  if (typeof uri === 'string') {
    uri = serialize(parse(uri, options), options);
  } else if (typeof uri === 'object') {
    uri = parse(serialize(uri, options), options);
  }
  return uri
}

function resolve (baseURI, relativeURI, options) {
  const schemelessOptions = Object.assign({ scheme: 'null' }, options);
  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
  return serialize(resolved, { ...schemelessOptions, skipEscape: true })
}

function resolveComponents (base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse(serialize(base, options), options); // normalize base components
    relative = parse(serialize(relative, options), options); // normalize relative components
  }
  options = options || {};

  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    // target.authority = relative.authority;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || '');
    target.query = relative.query;
  } else {
    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
      // target.authority = relative.authority;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || '');
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== undefined) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path.charAt(0) === '/') {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
            target.path = '/' + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      // target.authority = base.authority;
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }

  target.fragment = relative.fragment;

  return target
}

function equal$2 (uriA, uriB, options) {
  if (typeof uriA === 'string') {
    uriA = unescape(uriA);
    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === 'object') {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }

  if (typeof uriB === 'string') {
    uriB = unescape(uriB);
    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === 'object') {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }

  return uriA.toLowerCase() === uriB.toLowerCase()
}

function serialize (cmpts, opts) {
  const components = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ''
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];

  // find scheme handler
  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];

  // perform scheme specific serialization
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

  if (components.path !== undefined) {
    if (!options.skipEscape) {
      components.path = escape(components.path);

      if (components.scheme !== undefined) {
        components.path = components.path.split('%3A').join(':');
      }
    } else {
      components.path = unescape(components.path);
    }
  }

  if (options.reference !== 'suffix' && components.scheme) {
    uriTokens.push(components.scheme, ':');
  }

  const authority = recomposeAuthority(components, options);
  if (authority !== undefined) {
    if (options.reference !== 'suffix') {
      uriTokens.push('//');
    }

    uriTokens.push(authority);

    if (components.path && components.path.charAt(0) !== '/') {
      uriTokens.push('/');
    }
  }
  if (components.path !== undefined) {
    let s = components.path;

    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s);
    }

    if (authority === undefined) {
      s = s.replace(/^\/\//u, '/%2F'); // don't allow the path to start with "//"
    }

    uriTokens.push(s);
  }

  if (components.query !== undefined) {
    uriTokens.push('?', components.query);
  }

  if (components.fragment !== undefined) {
    uriTokens.push('#', components.fragment);
  }
  return uriTokens.join('')
}

const hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));

function nonSimpleDomain (value) {
  let code = 0;
  for (let i = 0, len = value.length; i < len; ++i) {
    code = value.charCodeAt(i);
    if (code > 126 || hexLookUp[code]) {
      return true
    }
  }
  return false
}

const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

function parse (uri, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: undefined,
    userinfo: undefined,
    host: '',
    port: undefined,
    path: '',
    query: undefined,
    fragment: undefined
  };
  const gotEncoding = uri.indexOf('%') !== -1;
  let isIP = false;
  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri;

  const matches = uri.match(URI_PARSE);

  if (matches) {
    // store each component
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || '';
    parsed.query = matches[7];
    parsed.fragment = matches[8];

    // fix port number
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = normalizeIPv4(parsed.host);
      if (ipv4result.isIPV4 === false) {
        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        parsed.host = ipv4result.host;
        isIP = true;
      }
    }
    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {
      parsed.reference = 'same-document';
    } else if (parsed.scheme === undefined) {
      parsed.reference = 'relative';
    } else if (parsed.fragment === undefined) {
      parsed.reference = 'absolute';
    } else {
      parsed.reference = 'uri';
    }

    // check for reference errors
    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
    }

    // find scheme handler
    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()];

    // check if scheme can't handle IRIs
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      // if host component is a domain name
      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
        // convert Unicode IDN -> ASCII IDN
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
        }
      }
      // convert IRI -> URI
    }

    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
      if (gotEncoding && parsed.scheme !== undefined) {
        parsed.scheme = unescape(parsed.scheme);
      }
      if (gotEncoding && parsed.host !== undefined) {
        parsed.host = unescape(parsed.host);
      }
      if (parsed.path !== undefined && parsed.path.length) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment !== undefined && parsed.fragment.length) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }

    // perform scheme specific parsing
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || 'URI can not be parsed.';
  }
  return parsed
}

const fastUri = {
  SCHEMES,
  normalize: normalize$1,
  resolve,
  resolveComponents,
  equal: equal$2,
  serialize,
  parse
};

fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;

var fastUriExports = fastUri$1.exports;

Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1 = validate;
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = codegen;
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	const validation_error_1 = validation_error;
	const ref_error_1 = ref_error;
	const rules_1 = rules;
	const compile_1 = compile;
	const codegen_2 = codegen;
	const resolve_1 = resolve$2;
	const dataType_1 = dataType;
	const util_1 = util;
	const $dataRefSchema = require$$9;
	const uri_1 = uri$1;
	const defaultRegExp = (str, flags) => new RegExp(str, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
	const EXT_SCOPE_NAMES = new Set([
	    "validate",
	    "serialize",
	    "parse",
	    "wrapper",
	    "root",
	    "schema",
	    "keyword",
	    "pattern",
	    "formats",
	    "validate$data",
	    "func",
	    "obj",
	    "Error",
	]);
	const removedOptions = {
	    errorDataPath: "",
	    format: "`validateFormats: false` can be used instead.",
	    nullable: '"nullable" keyword is supported by default.',
	    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
	    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
	    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
	    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
	    sourceCode: "Use option `code: {source: true}`",
	    strictDefaults: "It is default now, see option `strict`.",
	    strictKeywords: "It is default now, see option `strict`.",
	    uniqueItems: '"uniqueItems" keyword is always validated.',
	    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
	    cache: "Map is used as cache, schema object as key.",
	    serialize: "Map is used as cache, schema object as key.",
	    ajvErrors: "It is default now.",
	};
	const deprecatedOptions = {
	    ignoreKeywordsWithRef: "",
	    jsPropertySyntax: "",
	    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
	};
	const MAX_EXPRESSION = 200;
	// eslint-disable-next-line complexity
	function requiredOptions(o) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
	    const s = o.strict;
	    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
	    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
	    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
	    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
	    return {
	        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
	        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
	        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
	        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
	        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
	        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
	        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
	        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
	        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
	        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
	        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
	        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
	        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
	        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
	        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
	        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
	        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
	        uriResolver: uriResolver,
	    };
	}
	class Ajv {
	    constructor(opts = {}) {
	        this.schemas = {};
	        this.refs = {};
	        this.formats = {};
	        this._compilations = new Set();
	        this._loading = {};
	        this._cache = new Map();
	        opts = this.opts = { ...opts, ...requiredOptions(opts) };
	        const { es5, lines } = this.opts.code;
	        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
	        this.logger = getLogger(opts.logger);
	        const formatOpt = opts.validateFormats;
	        opts.validateFormats = false;
	        this.RULES = (0, rules_1.getRules)();
	        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
	        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
	        this._metaOpts = getMetaSchemaOptions.call(this);
	        if (opts.formats)
	            addInitialFormats.call(this);
	        this._addVocabularies();
	        this._addDefaultMetaSchema();
	        if (opts.keywords)
	            addInitialKeywords.call(this, opts.keywords);
	        if (typeof opts.meta == "object")
	            this.addMetaSchema(opts.meta);
	        addInitialSchemas.call(this);
	        opts.validateFormats = formatOpt;
	    }
	    _addVocabularies() {
	        this.addKeyword("$async");
	    }
	    _addDefaultMetaSchema() {
	        const { $data, meta, schemaId } = this.opts;
	        let _dataRefSchema = $dataRefSchema;
	        if (schemaId === "id") {
	            _dataRefSchema = { ...$dataRefSchema };
	            _dataRefSchema.id = _dataRefSchema.$id;
	            delete _dataRefSchema.$id;
	        }
	        if (meta && $data)
	            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
	    }
	    defaultMeta() {
	        const { meta, schemaId } = this.opts;
	        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
	    }
	    validate(schemaKeyRef, // key, ref or schema object
	    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	    data // to be validated
	    ) {
	        let v;
	        if (typeof schemaKeyRef == "string") {
	            v = this.getSchema(schemaKeyRef);
	            if (!v)
	                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
	        }
	        else {
	            v = this.compile(schemaKeyRef);
	        }
	        const valid = v(data);
	        if (!("$async" in v))
	            this.errors = v.errors;
	        return valid;
	    }
	    compile(schema, _meta) {
	        const sch = this._addSchema(schema, _meta);
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    compileAsync(schema, meta) {
	        if (typeof this.opts.loadSchema != "function") {
	            throw new Error("options.loadSchema should be a function");
	        }
	        const { loadSchema } = this.opts;
	        return runCompileAsync.call(this, schema, meta);
	        async function runCompileAsync(_schema, _meta) {
	            await loadMetaSchema.call(this, _schema.$schema);
	            const sch = this._addSchema(_schema, _meta);
	            return sch.validate || _compileAsync.call(this, sch);
	        }
	        async function loadMetaSchema($ref) {
	            if ($ref && !this.getSchema($ref)) {
	                await runCompileAsync.call(this, { $ref }, true);
	            }
	        }
	        async function _compileAsync(sch) {
	            try {
	                return this._compileSchemaEnv(sch);
	            }
	            catch (e) {
	                if (!(e instanceof ref_error_1.default))
	                    throw e;
	                checkLoaded.call(this, e);
	                await loadMissingSchema.call(this, e.missingSchema);
	                return _compileAsync.call(this, sch);
	            }
	        }
	        function checkLoaded({ missingSchema: ref, missingRef }) {
	            if (this.refs[ref]) {
	                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
	            }
	        }
	        async function loadMissingSchema(ref) {
	            const _schema = await _loadSchema.call(this, ref);
	            if (!this.refs[ref])
	                await loadMetaSchema.call(this, _schema.$schema);
	            if (!this.refs[ref])
	                this.addSchema(_schema, ref, meta);
	        }
	        async function _loadSchema(ref) {
	            const p = this._loading[ref];
	            if (p)
	                return p;
	            try {
	                return await (this._loading[ref] = loadSchema(ref));
	            }
	            finally {
	                delete this._loading[ref];
	            }
	        }
	    }
	    // Adds schema to the instance
	    addSchema(schema, // If array is passed, `key` will be ignored
	    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
	    ) {
	        if (Array.isArray(schema)) {
	            for (const sch of schema)
	                this.addSchema(sch, undefined, _meta, _validateSchema);
	            return this;
	        }
	        let id;
	        if (typeof schema === "object") {
	            const { schemaId } = this.opts;
	            id = schema[schemaId];
	            if (id !== undefined && typeof id != "string") {
	                throw new Error(`schema ${schemaId} must be string`);
	            }
	        }
	        key = (0, resolve_1.normalizeId)(key || id);
	        this._checkUnique(key);
	        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
	        return this;
	    }
	    // Add schema that will be used to validate other schemas
	    // options in META_IGNORE_OPTIONS are alway set to false
	    addMetaSchema(schema, key, // schema key
	    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
	    ) {
	        this.addSchema(schema, key, true, _validateSchema);
	        return this;
	    }
	    //  Validate schema against its meta-schema
	    validateSchema(schema, throwOrLogError) {
	        if (typeof schema == "boolean")
	            return true;
	        let $schema;
	        $schema = schema.$schema;
	        if ($schema !== undefined && typeof $schema != "string") {
	            throw new Error("$schema must be a string");
	        }
	        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
	        if (!$schema) {
	            this.logger.warn("meta-schema not available");
	            this.errors = null;
	            return true;
	        }
	        const valid = this.validate($schema, schema);
	        if (!valid && throwOrLogError) {
	            const message = "schema is invalid: " + this.errorsText();
	            if (this.opts.validateSchema === "log")
	                this.logger.error(message);
	            else
	                throw new Error(message);
	        }
	        return valid;
	    }
	    // Get compiled schema by `key` or `ref`.
	    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
	    getSchema(keyRef) {
	        let sch;
	        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
	            keyRef = sch;
	        if (sch === undefined) {
	            const { schemaId } = this.opts;
	            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
	            sch = compile_1.resolveSchema.call(this, root, keyRef);
	            if (!sch)
	                return;
	            this.refs[keyRef] = sch;
	        }
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    // Remove cached schema(s).
	    // If no parameter is passed all schemas but meta-schemas are removed.
	    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	    removeSchema(schemaKeyRef) {
	        if (schemaKeyRef instanceof RegExp) {
	            this._removeAllSchemas(this.schemas, schemaKeyRef);
	            this._removeAllSchemas(this.refs, schemaKeyRef);
	            return this;
	        }
	        switch (typeof schemaKeyRef) {
	            case "undefined":
	                this._removeAllSchemas(this.schemas);
	                this._removeAllSchemas(this.refs);
	                this._cache.clear();
	                return this;
	            case "string": {
	                const sch = getSchEnv.call(this, schemaKeyRef);
	                if (typeof sch == "object")
	                    this._cache.delete(sch.schema);
	                delete this.schemas[schemaKeyRef];
	                delete this.refs[schemaKeyRef];
	                return this;
	            }
	            case "object": {
	                const cacheKey = schemaKeyRef;
	                this._cache.delete(cacheKey);
	                let id = schemaKeyRef[this.opts.schemaId];
	                if (id) {
	                    id = (0, resolve_1.normalizeId)(id);
	                    delete this.schemas[id];
	                    delete this.refs[id];
	                }
	                return this;
	            }
	            default:
	                throw new Error("ajv.removeSchema: invalid parameter");
	        }
	    }
	    // add "vocabulary" - a collection of keywords
	    addVocabulary(definitions) {
	        for (const def of definitions)
	            this.addKeyword(def);
	        return this;
	    }
	    addKeyword(kwdOrDef, def // deprecated
	    ) {
	        let keyword;
	        if (typeof kwdOrDef == "string") {
	            keyword = kwdOrDef;
	            if (typeof def == "object") {
	                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
	                def.keyword = keyword;
	            }
	        }
	        else if (typeof kwdOrDef == "object" && def === undefined) {
	            def = kwdOrDef;
	            keyword = def.keyword;
	            if (Array.isArray(keyword) && !keyword.length) {
	                throw new Error("addKeywords: keyword must be string or non-empty array");
	            }
	        }
	        else {
	            throw new Error("invalid addKeywords parameters");
	        }
	        checkKeyword.call(this, keyword, def);
	        if (!def) {
	            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
	            return this;
	        }
	        keywordMetaschema.call(this, def);
	        const definition = {
	            ...def,
	            type: (0, dataType_1.getJSONTypes)(def.type),
	            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
	        };
	        (0, util_1.eachItem)(keyword, definition.type.length === 0
	            ? (k) => addRule.call(this, k, definition)
	            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
	        return this;
	    }
	    getKeyword(keyword) {
	        const rule = this.RULES.all[keyword];
	        return typeof rule == "object" ? rule.definition : !!rule;
	    }
	    // Remove keyword
	    removeKeyword(keyword) {
	        // TODO return type should be Ajv
	        const { RULES } = this;
	        delete RULES.keywords[keyword];
	        delete RULES.all[keyword];
	        for (const group of RULES.rules) {
	            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
	            if (i >= 0)
	                group.rules.splice(i, 1);
	        }
	        return this;
	    }
	    // Add format
	    addFormat(name, format) {
	        if (typeof format == "string")
	            format = new RegExp(format);
	        this.formats[name] = format;
	        return this;
	    }
	    errorsText(errors = this.errors, // optional array of validation errors
	    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
	    ) {
	        if (!errors || errors.length === 0)
	            return "No errors";
	        return errors
	            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
	            .reduce((text, msg) => text + separator + msg);
	    }
	    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
	        const rules = this.RULES.all;
	        metaSchema = JSON.parse(JSON.stringify(metaSchema));
	        for (const jsonPointer of keywordsJsonPointers) {
	            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
	            let keywords = metaSchema;
	            for (const seg of segments)
	                keywords = keywords[seg];
	            for (const key in rules) {
	                const rule = rules[key];
	                if (typeof rule != "object")
	                    continue;
	                const { $data } = rule.definition;
	                const schema = keywords[key];
	                if ($data && schema)
	                    keywords[key] = schemaOrData(schema);
	            }
	        }
	        return metaSchema;
	    }
	    _removeAllSchemas(schemas, regex) {
	        for (const keyRef in schemas) {
	            const sch = schemas[keyRef];
	            if (!regex || regex.test(keyRef)) {
	                if (typeof sch == "string") {
	                    delete schemas[keyRef];
	                }
	                else if (sch && !sch.meta) {
	                    this._cache.delete(sch.schema);
	                    delete schemas[keyRef];
	                }
	            }
	        }
	    }
	    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
	        let id;
	        const { schemaId } = this.opts;
	        if (typeof schema == "object") {
	            id = schema[schemaId];
	        }
	        else {
	            if (this.opts.jtd)
	                throw new Error("schema must be object");
	            else if (typeof schema != "boolean")
	                throw new Error("schema must be object or boolean");
	        }
	        let sch = this._cache.get(schema);
	        if (sch !== undefined)
	            return sch;
	        baseId = (0, resolve_1.normalizeId)(id || baseId);
	        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
	        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
	        this._cache.set(sch.schema, sch);
	        if (addSchema && !baseId.startsWith("#")) {
	            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
	            if (baseId)
	                this._checkUnique(baseId);
	            this.refs[baseId] = sch;
	        }
	        if (validateSchema)
	            this.validateSchema(schema, true);
	        return sch;
	    }
	    _checkUnique(id) {
	        if (this.schemas[id] || this.refs[id]) {
	            throw new Error(`schema with key or id "${id}" already exists`);
	        }
	    }
	    _compileSchemaEnv(sch) {
	        if (sch.meta)
	            this._compileMetaSchema(sch);
	        else
	            compile_1.compileSchema.call(this, sch);
	        /* istanbul ignore if */
	        if (!sch.validate)
	            throw new Error("ajv implementation error");
	        return sch.validate;
	    }
	    _compileMetaSchema(sch) {
	        const currentOpts = this.opts;
	        this.opts = this._metaOpts;
	        try {
	            compile_1.compileSchema.call(this, sch);
	        }
	        finally {
	            this.opts = currentOpts;
	        }
	    }
	}
	Ajv.ValidationError = validation_error_1.default;
	Ajv.MissingRefError = ref_error_1.default;
	exports.default = Ajv;
	function checkOptions(checkOpts, options, msg, log = "error") {
	    for (const key in checkOpts) {
	        const opt = key;
	        if (opt in options)
	            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
	    }
	}
	function getSchEnv(keyRef) {
	    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
	    return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
	    const optsSchemas = this.opts.schemas;
	    if (!optsSchemas)
	        return;
	    if (Array.isArray(optsSchemas))
	        this.addSchema(optsSchemas);
	    else
	        for (const key in optsSchemas)
	            this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
	    for (const name in this.opts.formats) {
	        const format = this.opts.formats[name];
	        if (format)
	            this.addFormat(name, format);
	    }
	}
	function addInitialKeywords(defs) {
	    if (Array.isArray(defs)) {
	        this.addVocabulary(defs);
	        return;
	    }
	    this.logger.warn("keywords option as map is deprecated, pass array");
	    for (const keyword in defs) {
	        const def = defs[keyword];
	        if (!def.keyword)
	            def.keyword = keyword;
	        this.addKeyword(def);
	    }
	}
	function getMetaSchemaOptions() {
	    const metaOpts = { ...this.opts };
	    for (const opt of META_IGNORE_OPTIONS)
	        delete metaOpts[opt];
	    return metaOpts;
	}
	const noLogs = { log() { }, warn() { }, error() { } };
	function getLogger(logger) {
	    if (logger === false)
	        return noLogs;
	    if (logger === undefined)
	        return console;
	    if (logger.log && logger.warn && logger.error)
	        return logger;
	    throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def) {
	    const { RULES } = this;
	    (0, util_1.eachItem)(keyword, (kwd) => {
	        if (RULES.keywords[kwd])
	            throw new Error(`Keyword ${kwd} is already defined`);
	        if (!KEYWORD_NAME.test(kwd))
	            throw new Error(`Keyword ${kwd} has invalid name`);
	    });
	    if (!def)
	        return;
	    if (def.$data && !("code" in def || "validate" in def)) {
	        throw new Error('$data keyword must have "code" or "validate" function');
	    }
	}
	function addRule(keyword, definition, dataType) {
	    var _a;
	    const post = definition === null || definition === void 0 ? void 0 : definition.post;
	    if (dataType && post)
	        throw new Error('keyword with "post" flag cannot have "type"');
	    const { RULES } = this;
	    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
	    if (!ruleGroup) {
	        ruleGroup = { type: dataType, rules: [] };
	        RULES.rules.push(ruleGroup);
	    }
	    RULES.keywords[keyword] = true;
	    if (!definition)
	        return;
	    const rule = {
	        keyword,
	        definition: {
	            ...definition,
	            type: (0, dataType_1.getJSONTypes)(definition.type),
	            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
	        },
	    };
	    if (definition.before)
	        addBeforeRule.call(this, ruleGroup, rule, definition.before);
	    else
	        ruleGroup.rules.push(rule);
	    RULES.all[keyword] = rule;
	    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
	    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
	    if (i >= 0) {
	        ruleGroup.rules.splice(i, 0, rule);
	    }
	    else {
	        ruleGroup.rules.push(rule);
	        this.logger.warn(`rule ${before} is not defined`);
	    }
	}
	function keywordMetaschema(def) {
	    let { metaSchema } = def;
	    if (metaSchema === undefined)
	        return;
	    if (def.$data && this.opts.$data)
	        metaSchema = schemaOrData(metaSchema);
	    def.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = {
	    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
	};
	function schemaOrData(schema) {
	    return { anyOf: [schema, $dataRef] };
	}
	
} (core$2));

var draft7 = {};

var core$1 = {};

var id = {};

Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
id.default = def$s;

var ref = {};

Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1$1 = compile;
const util_1$j = util;
const def$r = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1$1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1$1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1$1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1$l._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$l.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1$l.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1$l._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1$1.default.this : codegen_1$l.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1$l._) `await ${(0, code_1$8.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1$l._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1$8.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1$l._) `${source}.errors`;
        gen.assign(names_1$1.default.vErrors, (0, codegen_1$l._) `${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1$1.default.errors, (0, codegen_1$l._) `${names_1$1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1$j.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1$l._) `${source}.evaluated.props`);
                it.props = util_1$j.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1$j.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1$l._) `${source}.evaluated.items`);
                it.items = util_1$j.mergeEvaluated.items(gen, items, it.items, codegen_1$l.Name);
            }
        }
    }
}
ref.callRef = callRef;
ref.default = def$r;

Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
core$1.default = core;

var validation$1 = {};

var limitNumber = {};

Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error$i = {
    message: ({ keyword, schemaCode }) => (0, codegen_1$k.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1$k._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def$q = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$i,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$k._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
limitNumber.default = def$q;

var multipleOf = {};

Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
    message: ({ schemaCode }) => (0, codegen_1$j.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1$j._) `{multipleOf: ${schemaCode}}`,
};
const def$p = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$h,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1$j._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1$j._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$j._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
multipleOf.default = def$p;

var limitLength = {};

var ucs2length$1 = {};

Object.defineProperty(ucs2length$1, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';

Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$i = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$i.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1$i._) `{limit: ${schemaCode}}`,
};
const def$o = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$g,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1$i._) `${data}.length` : (0, codegen_1$i._) `${(0, util_1$i.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$i._) `${len} ${op} ${schemaCode}`);
    },
};
limitLength.default = def$o;

var pattern = {};

Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
    message: ({ schemaCode }) => (0, codegen_1$h.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$h._) `{pattern: ${schemaCode}}`,
};
const def$n = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$f,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$h._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1$h._) `!${regExp}.test(${data})`);
    },
};
pattern.default = def$n;

var limitProperties = {};

Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$g.str) `must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1$g._) `{limit: ${schemaCode}}`,
};
const def$m = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$e,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
        cxt.fail$data((0, codegen_1$g._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
limitProperties.default = def$m;

var required = {};

Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$h = util;
const error$d = {
    message: ({ params: { missingProperty } }) => (0, codegen_1$f.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1$f._) `{missingProperty: ${missingProperty}}`,
};
const def$l = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$d,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1$h.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1$f.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1$6.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
                (0, code_1$6.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1$f.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1$f.nil);
        }
    },
};
required.default = def$l;

var limitItems = {};

Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$e.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$e._) `{limit: ${schemaCode}}`,
};
const def$k = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$c,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
        cxt.fail$data((0, codegen_1$e._) `${data}.length ${op} ${schemaCode}`);
    },
};
limitItems.default = def$k;

var uniqueItems = {};

var equal$1 = {};

Object.defineProperty(equal$1, "__esModule", { value: true });
// https://github.com/ajv-validator/ajv/issues/889
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;

Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$g = util;
const equal_1$2 = equal$1;
const error$b = {
    message: ({ params: { i, j } }) => (0, codegen_1$d.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1$d._) `{i: ${i}, j: ${j}}`,
};
const def$j = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$b,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$d._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1$d._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1$d._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1$d._) `{}`);
            gen.for((0, codegen_1$d._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1$d._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1$d._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1$d._) `typeof ${item} == "string"`, (0, codegen_1$d._) `${item} += "_"`);
                gen
                    .if((0, codegen_1$d._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1$d._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1$d._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1$g.useFunc)(gen, equal_1$2.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1$d._) `;${i}--;`, () => gen.for((0, codegen_1$d._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$d._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
uniqueItems.default = def$j;

var _const = {};

Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util;
const equal_1$1 = equal$1;
const error$a = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1$c._) `{allowedValue: ${schemaCode}}`,
};
const def$i = {
    keyword: "const",
    $data: true,
    error: error$a,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1$c._) `!${(0, util_1$f.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1$c._) `${schema} !== ${data}`);
        }
    },
};
_const.default = def$i;

var _enum = {};

Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util;
const equal_1 = equal$1;
const error$9 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$b._) `{allowedValues: ${schemaCode}}`,
};
const def$h = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$9,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1$e.useFunc)(gen, equal_1.default)));
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1$b.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$b._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1$b._) `${getEql()}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1$b._) `${data} === ${sch}`;
        }
    },
};
_enum.default = def$h;

Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
validation$1.default = validation;

var applicator = {};

var additionalItems = {};

Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$d = util;
const error$8 = {
    message: ({ params: { len } }) => (0, codegen_1$a.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$a._) `{limit: ${len}}`,
};
const def$g = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$8,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1$d.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1$a._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1$a._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1$d.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1$a._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1$a.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1$d.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1$a.not)(valid), () => gen.break());
        });
    }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;

var prefixItems = {};

var items = {};

Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$c = util;
const code_1$5 = code;
const def$f = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1$c.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1$5.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1$c.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1$9._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1$c.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1$9._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1$c.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
items.validateTuple = validateTuple;
items.default = def$f;

Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items"),
};
prefixItems.default = def$e;

var items2020 = {};

Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$b = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
    message: ({ params: { len } }) => (0, codegen_1$8.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$8._) `{limit: ${len}}`,
};
const def$d = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error$7,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1$b.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1$4.validateArray)(cxt));
    },
};
items2020.default = def$d;

var contains = {};

Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$a = util;
const error$6 = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1$7.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1$7.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1$7._) `{minContains: ${min}}` : (0, codegen_1$7._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def$c = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$6,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1$7._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1$a.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1$a.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1$7._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1$7._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1$7._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1$a.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1$7._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1$7._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1$7._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
contains.default = def$c;

var dependencies = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1 = codegen;
	const util_1 = util;
	const code_1 = code;
	exports.error = {
	    message: ({ params: { property, depsCount, deps } }) => {
	        const property_ies = depsCount === 1 ? "property" : "properties";
	        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
	    },
	    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
	};
	const def = {
	    keyword: "dependencies",
	    type: "object",
	    schemaType: "object",
	    error: exports.error,
	    code(cxt) {
	        const [propDeps, schDeps] = splitDependencies(cxt);
	        validatePropertyDeps(cxt, propDeps);
	        validateSchemaDeps(cxt, schDeps);
	    },
	};
	function splitDependencies({ schema }) {
	    const propertyDeps = {};
	    const schemaDeps = {};
	    for (const key in schema) {
	        if (key === "__proto__")
	            continue;
	        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
	        deps[key] = schema[key];
	    }
	    return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
	    const { gen, data, it } = cxt;
	    if (Object.keys(propertyDeps).length === 0)
	        return;
	    const missing = gen.let("missing");
	    for (const prop in propertyDeps) {
	        const deps = propertyDeps[prop];
	        if (deps.length === 0)
	            continue;
	        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
	        cxt.setParams({
	            property: prop,
	            depsCount: deps.length,
	            deps: deps.join(", "),
	        });
	        if (it.allErrors) {
	            gen.if(hasProperty, () => {
	                for (const depProp of deps) {
	                    (0, code_1.checkReportMissingProp)(cxt, depProp);
	                }
	            });
	        }
	        else {
	            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
	            (0, code_1.reportMissingProp)(cxt, missing);
	            gen.else();
	        }
	    }
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    for (const prop in schemaDeps) {
	        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
	            continue;
	        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
	            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
	            cxt.mergeValidEvaluated(schCxt, valid);
	        }, () => gen.var(valid, true) // TODO var
	        );
	        cxt.ok(valid);
	    }
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def;
	
} (dependencies));

var propertyNames = {};

Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$9 = util;
const error$5 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1$6._) `{propertyName: ${params.propertyName}}`,
};
const def$b = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$5,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1$9.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1$6.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
propertyNames.default = def$b;

var additionalProperties = {};

Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$8 = util;
const error$4 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1$5._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def$a = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$4,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$8.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$5._) `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1$8.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1$5.or)(...props.map((p) => (0, codegen_1$5._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1$5.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1$5.or)(definedProp, ...patProps.map((p) => (0, codegen_1$5._) `${(0, code_1$3.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1$5.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1$5._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1$8.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1$5.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1$5.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1$8.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
additionalProperties.default = def$a;

var properties$1 = {};

Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$7 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$2.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1$7.mergeEvaluated.props(gen, (0, util_1$7.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1$7.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1$2.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
properties$1.default = def$9;

var patternProperties = {};

Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$6 = util;
const util_2 = util;
const def$8 = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1$1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1$6.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1$6.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1$4._) `${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1$4._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1$4.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
patternProperties.default = def$8;

var not = {};

Object.defineProperty(not, "__esModule", { value: true });
const util_1$5 = util;
const def$7 = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1$5.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
not.default = def$7;

var anyOf = {};

Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
anyOf.default = def$6;

var oneOf = {};

Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$4 = util;
const error$3 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1$3._) `{passingSchemas: ${params.passing}}`,
};
const def$5 = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$3,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1$4.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1$3._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1$3._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
                });
            });
        }
    },
};
oneOf.default = def$5;

var allOf = {};

Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$3 = util;
const def$4 = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1$3.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
allOf.default = def$4;

var _if = {};

Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util;
const error$2 = {
    message: ({ params }) => (0, codegen_1$2.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1$2._) `{failingKeyword: ${params.ifClause}}`,
};
const def$3 = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$2,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1$2.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1$2.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1$2._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1$2.alwaysValidSchema)(it, schema);
}
_if.default = def$3;

var thenElse = {};

Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$1 = util;
const def$2 = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1$1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
thenElse.default = def$2;

Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
applicator.default = getApplicator;

var format$2 = {};

var format$1 = {};

Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
    message: ({ schemaCode }) => (0, codegen_1$1.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$1._) `{format: ${schemaCode}}`,
};
const def$1 = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$1,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1$1._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1$1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1$1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1$1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1$1.nil;
                return (0, codegen_1$1._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1$1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1$1._) `${format}(${data})`;
                const validData = (0, codegen_1$1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1$1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1$1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1$1._) `${opts.code.formats}${(0, codegen_1$1.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$1._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1$1._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1$1._) `${fmtRef}(${data})` : (0, codegen_1$1._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
format$1.default = def$1;

Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;

var metadata = {};

Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
metadata.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];

Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
draft7.default = draft7Vocabularies;

var discriminator = {};

var types = {};

Object.defineProperty(types, "__esModule", { value: true });
types.DiscrError = void 0;
var DiscrError;
(function (DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
})(DiscrError || (types.DiscrError = DiscrError = {}));

Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1 = util;
const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    const ref = sch.$ref;
                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
                    if (sch instanceof compile_1.SchemaEnv)
                        sch = sch.schema;
                    if (sch === undefined)
                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
                }
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
discriminator.default = def;

const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
const type = [
	"object",
	"boolean"
];
const properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
const require$$3 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
	const core_1 = core$2;
	const draft7_1 = draft7;
	const discriminator_1 = discriminator;
	const draft7MetaSchema = require$$3;
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	class Ajv extends core_1.default {
	    _addVocabularies() {
	        super._addVocabularies();
	        draft7_1.default.forEach((v) => this.addVocabulary(v));
	        if (this.opts.discriminator)
	            this.addKeyword(discriminator_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        if (!this.opts.meta)
	            return;
	        const metaSchema = this.opts.$data
	            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
	            : draft7MetaSchema;
	        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
	        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	}
	exports.Ajv = Ajv;
	module.exports = exports = Ajv;
	module.exports.Ajv = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = validate;
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = codegen;
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	var validation_error_1 = validation_error;
	Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
	var ref_error_1 = ref_error;
	Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
	
} (ajv, ajv.exports));

var ajvExports = ajv.exports;
const Ajv = /*@__PURE__*/getDefaultExportFromCjs(ajvExports);

class BaseAction {
  actionName = ActionName.Unknown;
  core;
  validate = void 0;
  payloadSchema = void 0;
  obContext;
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async check(payload) {
    if (this.payloadSchema) {
      this.validate = new Ajv({ allowUnionTypes: true }).compile(this.payloadSchema);
    }
    if (this.validate && !this.validate(payload)) {
      const errors = this.validate.errors;
      const errorMessages = errors.map((e) => {
        return `Key: ${e.instancePath.split("/").slice(1).join(".")}, Message: ${e.message}`;
      });
      return {
        valid: false,
        message: errorMessages.join("\n") || "未知错误"
      };
    }
    return {
      valid: true
    };
  }
  async handle(payload) {
    const result = await this.check(payload);
    if (!result.valid) {
      return OB11Response.error(result.message, 400);
    }
    try {
      const resData = await this._handle(payload);
      return OB11Response.ok(resData);
    } catch (e) {
      this.core.context.logger.logError.bind(this.core.context.logger)("发生错误", e);
      return OB11Response.error(e?.toString() || e?.stack?.toString() || "未知错误，可能操作超时", 200);
    }
  }
  async websocketHandle(payload, echo) {
    const result = await this.check(payload);
    if (!result.valid) {
      return OB11Response.error(result.message, 1400, echo);
    }
    try {
      const resData = await this._handle(payload);
      return OB11Response.ok(resData, echo);
    } catch (e) {
      this.core.context.logger.logError.bind(this.core.context.logger)("发生错误", e);
      return OB11Response.error(e.stack?.toString() || e.toString(), 1200, echo);
    }
  }
}

var ContextMode = /* @__PURE__ */ ((ContextMode2) => {
  ContextMode2[ContextMode2["Normal"] = 0] = "Normal";
  ContextMode2[ContextMode2["Private"] = 1] = "Private";
  ContextMode2[ContextMode2["Group"] = 2] = "Group";
  return ContextMode2;
})(ContextMode || {});
function normalize(message, autoEscape = false) {
  return typeof message === "string" ? autoEscape ? [{ type: OB11MessageDataType.text, data: { text: message } }] : decodeCQCode(message) : Array.isArray(message) ? message : [message];
}
async function createContext(core, payload, contextMode) {
  if ((contextMode === 2 /* Group */ || contextMode === 0 /* Normal */) && payload.group_id) {
    return {
      chatType: ChatType.KCHATTYPEGROUP,
      peerUid: payload.group_id.toString()
    };
  }
  if ((contextMode === 1 /* Private */ || contextMode === 0 /* Normal */) && payload.user_id) {
    const Uid = await core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!Uid) throw new Error("无法获取用户信息");
    const isBuddy = await core.apis.FriendApi.isBuddy(Uid);
    if (!isBuddy) {
      const ret = await core.apis.MsgApi.getTempChatInfo(ChatType.KCHATTYPETEMPC2CFROMGROUP, Uid);
      if (ret.tmpChatInfo?.groupCode) {
        return {
          chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
          peerUid: Uid,
          guildId: ""
        };
      }
      if (payload.group_id) {
        return {
          chatType: ChatType.KCHATTYPETEMPC2CFROMGROUP,
          peerUid: Uid,
          guildId: payload.group_id.toString()
        };
      }
      return {
        chatType: ChatType.KCHATTYPEC2C,
        peerUid: Uid,
        guildId: ""
      };
    }
    return {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: Uid,
      guildId: ""
    };
  }
  throw new Error("请指定 group_id 或 user_id");
}
function getSpecialMsgNum(payload, msgType) {
  if (Array.isArray(payload.message)) {
    return payload.message.filter((msg) => msg.type == msgType).length;
  }
  return 0;
}
class SendMsg extends BaseAction {
  actionName = ActionName.SendMsg;
  contextMode = 0 /* Normal */;
  async check(payload) {
    const messages = normalize(payload.message);
    const nodeElementLength = getSpecialMsgNum(payload, OB11MessageDataType.node);
    if (nodeElementLength > 0 && nodeElementLength != messages.length) {
      return {
        valid: false,
        message: "转发消息不能和普通消息混在一起发送,转发需要保证message只有type为node的元素"
      };
    }
    return { valid: true };
  }
  async _handle(payload) {
    this.contextMode = 0 /* Normal */;
    if (payload.message_type === "group") this.contextMode = 2 /* Group */;
    if (payload.message_type === "private") this.contextMode = 1 /* Private */;
    const peer = await createContext(this.core, payload, this.contextMode);
    const messages = normalize(
      payload.message,
      typeof payload.auto_escape === "string" ? payload.auto_escape === "true" : !!payload.auto_escape
    );
    if (getSpecialMsgNum(payload, OB11MessageDataType.node)) {
      const packetMode = this.core.apis.PacketApi.available;
      let returnMsgAndResId;
      try {
        returnMsgAndResId = packetMode ? await this.handleForwardedNodesPacket(peer, messages, payload.source, payload.news, payload.summary, payload.prompt) : await this.handleForwardedNodes(peer, messages);
      } catch (e) {
        throw Error(packetMode ? `发送伪造合并转发消息失败: ${e}` : `发送合并转发消息失败: ${e}`);
      }
      if (!returnMsgAndResId) {
        throw Error("发送合并转发消息失败：returnMsgAndResId 为空！");
      }
      if (returnMsgAndResId.message) {
        const msgShortId = MessageUnique.createUniqueMsgId({
          guildId: "",
          peerUid: peer.peerUid,
          chatType: peer.chatType
        }, returnMsgAndResId.message.msgId);
        return { message_id: msgShortId, res_id: returnMsgAndResId.res_id };
      } else if (returnMsgAndResId.res_id && !returnMsgAndResId.message) {
        throw Error(`发送转发消息（res_id：${returnMsgAndResId.res_id} 失败`);
      }
    }
    const { sendElements, deleteAfterSentFiles } = await this.obContext.apis.MsgApi.createSendElements(messages, peer);
    const returnMsg = await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles);
    return { message_id: returnMsg.id };
  }
  async uploadForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt, parentMeta, dp = 0) {
    const logger = this.core.context.logger;
    const packetMsg = [];
    for (const node of messageNodes) {
      if (dp >= 3) {
        logger.logWarn("转发消息深度超过3层，将停止解析！");
        break;
      }
      if (!node.data.id) {
        const OB11Data = normalize(node.type === OB11MessageDataType.node ? node.data.content : node);
        let sendElements;
        if (getSpecialMsgNum({ message: OB11Data }, OB11MessageDataType.node)) {
          const uploadReturnData = await this.uploadForwardedNodesPacket(msgPeer, OB11Data, node.data.source, node.data.news, node.data.summary, node.data.prompt, {
            user_id: (node.data.user_id || node.data.uin)?.toString() ?? parentMeta?.user_id ?? this.core.selfInfo.uin,
            nickname: (node.data.nickname || node.data.name) ?? parentMeta?.nickname ?? "QQ用户"
          }, dp + 1);
          sendElements = uploadReturnData?.finallySendElements ? [uploadReturnData.finallySendElements] : [];
        } else {
          const sendElementsCreateReturn = await this.obContext.apis.MsgApi.createSendElements(OB11Data, msgPeer);
          sendElements = sendElementsCreateReturn.sendElements;
        }
        const packetMsgElements = {
          senderUin: Number((node.data.user_id || node.data.uin) ?? parentMeta?.user_id) || +this.core.selfInfo.uin,
          senderName: (node.data.nickname || node.data.name) ?? parentMeta?.nickname ?? "QQ用户",
          groupId: msgPeer.chatType === ChatType.KCHATTYPEGROUP ? +msgPeer.peerUid : void 0,
          time: Number(node.data.time) || Date.now(),
          msg: sendElements
        };
        logger.logDebug(`handleForwardedNodesPacket[SendRaw] 开始转换 ${stringifyWithBigInt(packetMsgElements)}`);
        const transformedMsg = this.core.apis.PacketApi.packetSession?.packer.packetConverter.rawMsgWithSendMsgToPacketMsg(packetMsgElements);
        logger.logDebug(`handleForwardedNodesPacket[SendRaw] 转换为 ${stringifyWithBigInt(transformedMsg)}`);
        packetMsg.push(transformedMsg);
      } else if (node.data.id) {
        const id = node.data.id;
        const nodeMsg = MessageUnique.getMsgIdAndPeerByShortId(+id) || MessageUnique.getPeerByMsgId(id);
        if (!nodeMsg) {
          logger.logError.bind(this.core.context.logger)("转发消息失败，未找到消息", id);
          continue;
        }
        const msg = (await this.core.apis.MsgApi.getMsgsByMsgId(nodeMsg.Peer, [nodeMsg.MsgId])).msgList[0];
        logger.logDebug(`handleForwardedNodesPacket[PureRaw] 开始转换 ${stringifyWithBigInt(msg)}`);
        await this.core.apis.FileApi.downloadRawMsgMedia([msg]);
        const transformedMsg = this.core.apis.PacketApi.packetSession?.packer.packetConverter.rawMsgToPacketMsg(msg, msgPeer);
        logger.logDebug(`handleForwardedNodesPacket[PureRaw] 转换为 ${stringifyWithBigInt(transformedMsg)}`);
        packetMsg.push(transformedMsg);
      } else {
        logger.logDebug(`handleForwardedNodesPacket 跳过元素 ${stringifyWithBigInt(node)}`);
      }
    }
    if (packetMsg.length === 0) {
      logger.logWarn("handleForwardedNodesPacket 元素为空！");
      return null;
    }
    const resid = await this.core.apis.PacketApi.sendUploadForwardMsg(packetMsg, msgPeer.chatType === ChatType.KCHATTYPEGROUP ? +msgPeer.peerUid : 0);
    const forwardJson = ForwardMsgBuilder.fromPacketMsg(resid, packetMsg, source, news, summary, prompt);
    return {
      finallySendElements: {
        elementType: ElementType.ARK,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify(forwardJson)
        }
      },
      res_id: resid
    };
  }
  async handleForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt) {
    let returnMsg, res_id;
    const uploadReturnData = await this.uploadForwardedNodesPacket(msgPeer, messageNodes, source, news, summary, prompt);
    res_id = uploadReturnData?.res_id;
    const finallySendElements = uploadReturnData?.finallySendElements;
    if (!finallySendElements) throw Error("转发消息失败，生成节点为空");
    returnMsg = await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(msgPeer, [finallySendElements], [], true).catch((_) => void 0);
    return { message: returnMsg ?? null, res_id };
  }
  async handleForwardedNodes(destPeer, messageNodes) {
    const selfPeer = {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: this.core.selfInfo.uid
    };
    let nodeMsgIds = [];
    const logger = this.core.context.logger;
    for (const messageNode of messageNodes) {
      const nodeId = messageNode.data.id;
      if (nodeId) {
        const nodeMsg = MessageUnique.getMsgIdAndPeerByShortId(parseInt(nodeId)) || MessageUnique.getPeerByMsgId(nodeId);
        if (!nodeMsg) {
          logger.logError.bind(this.core.context.logger)("转发消息失败，未找到消息", nodeId);
          continue;
        }
        nodeMsgIds.push(nodeMsg.MsgId);
      } else {
        try {
          const OB11Data = normalize(messageNode.data.content);
          const isNodeMsg = OB11Data.filter((e) => e.type === OB11MessageDataType.node).length;
          if (isNodeMsg !== 0) {
            if (isNodeMsg !== OB11Data.length) {
              logger.logError.bind(this.core.context.logger)("子消息中包含非node消息 跳过不合法部分");
              continue;
            }
            const nodeMsg = await this.handleForwardedNodes(selfPeer, OB11Data.filter((e) => e.type === OB11MessageDataType.node));
            if (nodeMsg) {
              nodeMsgIds.push(nodeMsg.message.msgId);
              MessageUnique.createUniqueMsgId(selfPeer, nodeMsg.message.msgId);
            }
            continue;
          }
          const { sendElements } = await this.obContext.apis.MsgApi.createSendElements(OB11Data, destPeer);
          const MixElement = sendElements.filter(
            (element) => element.elementType !== ElementType.FILE && element.elementType !== ElementType.VIDEO && element.elementType !== ElementType.ARK
          );
          const SingleElement = sendElements.filter(
            (element) => element.elementType === ElementType.FILE || element.elementType === ElementType.VIDEO || element.elementType === ElementType.ARK
          ).map((e) => [e]);
          const AllElement = [MixElement, ...SingleElement].filter((e) => e !== void 0 && e.length !== 0);
          const MsgNodeList = [];
          for (const sendElementsSplitElement of AllElement) {
            MsgNodeList.push(this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(selfPeer, sendElementsSplitElement, [], true).catch((_) => void 0));
          }
          (await Promise.allSettled(MsgNodeList)).map((result) => {
            if (result.status === "fulfilled" && result.value) {
              nodeMsgIds.push(result.value.msgId);
              MessageUnique.createUniqueMsgId(selfPeer, result.value.msgId);
            }
          });
        } catch (e) {
          logger.logDebug("生成转发消息节点失败", e);
        }
      }
    }
    const nodeMsgArray = [];
    let srcPeer = void 0;
    let needSendSelf = false;
    for (const msgId of nodeMsgIds) {
      const nodeMsgPeer = MessageUnique.getPeerByMsgId(msgId);
      if (!nodeMsgPeer) {
        logger.logError.bind(this.core.context.logger)("转发消息失败，未找到消息", msgId);
        continue;
      }
      const nodeMsg = (await this.core.apis.MsgApi.getMsgsByMsgId(nodeMsgPeer.Peer, [msgId])).msgList[0];
      srcPeer = srcPeer ?? { chatType: nodeMsg.chatType, peerUid: nodeMsg.peerUid };
      if (srcPeer.peerUid !== nodeMsg.peerUid) {
        needSendSelf = true;
      }
      nodeMsgArray.push(nodeMsg);
    }
    nodeMsgIds = nodeMsgArray.map((msg) => msg.msgId);
    let retMsgIds = [];
    if (needSendSelf) {
      for (const [, msg] of nodeMsgArray.entries()) {
        if (msg.peerUid === this.core.selfInfo.uid) {
          retMsgIds.push(msg.msgId);
          continue;
        }
        const ClonedMsg = await this.cloneMsg(msg);
        if (ClonedMsg) retMsgIds.push(ClonedMsg.msgId);
      }
    } else {
      retMsgIds = nodeMsgIds;
    }
    if (retMsgIds.length === 0) throw Error("转发消息失败，生成节点为空");
    try {
      logger.logDebug("开发转发", srcPeer, destPeer, retMsgIds);
      return {
        message: await this.core.apis.MsgApi.multiForwardMsg(srcPeer, destPeer, retMsgIds)
      };
    } catch (e) {
      logger.logError.bind(this.core.context.logger)("forward failed", e);
      return {
        message: null
      };
    }
  }
  async cloneMsg(msg) {
    const selfPeer = {
      chatType: ChatType.KCHATTYPEC2C,
      peerUid: this.core.selfInfo.uid
    };
    const logger = this.core.context.logger;
    const sendElements = [];
    for (const element of msg.elements) {
      sendElements.push(element);
    }
    if (sendElements.length === 0) {
      logger.logDebug("需要clone的消息无法解析，将会忽略掉", msg);
    }
    try {
      return await this.core.apis.MsgApi.sendMsg(selfPeer, sendElements, true);
    } catch (e) {
      logger.logError.bind(this.core.context.logger)(e, "克隆转发消息失败,将忽略本条消息", msg);
    }
  }
}

class OneBotQuickActionApi {
  constructor(obContext, core) {
    this.obContext = obContext;
    this.core = core;
  }
  async handleQuickOperation(eventContext, quickAction) {
    const logger = this.core.context.logger;
    if (eventContext.post_type === "message") {
      await this.handleMsg(eventContext, quickAction).catch(logger.logError.bind(logger));
    }
    if (eventContext.post_type === "request") {
      const friendRequest = eventContext;
      const groupRequest = eventContext;
      if (friendRequest.request_type === "friend") {
        await this.handleFriendRequest(friendRequest, quickAction).catch(logger.logError.bind(logger));
      } else if (groupRequest.request_type === "group") {
        await this.handleGroupRequest(groupRequest, quickAction).catch(logger.logError.bind(logger));
      }
    }
  }
  async handleMsg(msg, quickAction) {
    const reply = quickAction.reply;
    const peerContextMode = msg.message_type == "private" ? ContextMode.Private : ContextMode.Group;
    const peer = await createContext(this.core, {
      message_type: void 0,
      group_id: msg.group_id?.toString(),
      user_id: msg.user_id?.toString()
    }, peerContextMode);
    if (reply) {
      let replyMessage = [];
      if (msg.message_type == "group") {
        replyMessage.push({
          type: "reply",
          data: {
            id: msg.message_id.toString()
          }
        });
        if (quickAction.at_sender) {
          replyMessage.push({
            type: "at",
            data: {
              qq: msg.user_id.toString()
            }
          });
        }
      }
      replyMessage = replyMessage.concat(normalize(reply, quickAction.auto_escape));
      const {
        sendElements,
        deleteAfterSentFiles
      } = await this.obContext.apis.MsgApi.createSendElements(replyMessage, peer);
      this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, sendElements, deleteAfterSentFiles, false).then().catch(this.core.context.logger.logError.bind(this.core.context.logger));
    }
  }
  async handleGroupRequest(request, quickAction) {
    if (!isNull(quickAction.approve)) {
      this.core.apis.GroupApi.handleGroupRequest(
        request.flag,
        quickAction.approve ? GroupRequestOperateTypes.approve : GroupRequestOperateTypes.reject,
        quickAction.reason
      ).catch(this.core.context.logger.logError.bind(this.core.context.logger));
    }
  }
  async handleFriendRequest(request, quickAction) {
    if (!isNull(quickAction.approve)) {
      this.core.apis.FriendApi.handleFriendRequest(request.flag, !!quickAction.approve).then().catch(this.core.context.logger.logError.bind(this.core.context.logger));
    }
  }
}

const SchemaData$_ = {
  type: "object",
  properties: {
    message_id: { type: ["number", "string"] }
  },
  required: ["message_id"]
};
class GetMsg extends BaseAction {
  actionName = ActionName.GetMsg;
  payloadSchema = SchemaData$_;
  async _handle(payload) {
    if (!payload.message_id) {
      throw Error("参数message_id不能为空");
    }
    const MsgShortId = MessageUnique.getShortIdByMsgId(payload.message_id.toString());
    const msgIdWithPeer = MessageUnique.getMsgIdAndPeerByShortId(MsgShortId || parseInt(payload.message_id.toString()));
    if (!msgIdWithPeer) {
      throw new Error("消息不存在");
    }
    const peer = { guildId: "", peerUid: msgIdWithPeer?.Peer.peerUid, chatType: msgIdWithPeer.Peer.chatType };
    const orimsg = this.obContext.recallMsgCache.get(msgIdWithPeer.MsgId);
    let msg;
    if (orimsg) {
      msg = orimsg;
    } else {
      msg = (await this.core.apis.MsgApi.getMsgsByMsgId(peer, [msgIdWithPeer?.MsgId || payload.message_id.toString()])).msgList[0];
    }
    const retMsg = await this.obContext.apis.MsgApi.parseMessage(msg);
    if (!retMsg) throw Error("消息为空");
    try {
      retMsg.message_id = MessageUnique.createUniqueMsgId(peer, msg.msgId);
      retMsg.message_seq = retMsg.message_id;
      retMsg.real_id = retMsg.message_id;
    } catch (e) {
    }
    return retMsg;
  }
}

class GetLoginInfo extends BaseAction {
  actionName = ActionName.GetLoginInfo;
  async _handle(payload) {
    return OB11Entities.selfInfo(this.core.selfInfo);
  }
}

const SchemaData$Z = {
  type: "object",
  properties: {
    no_cache: { type: ["boolean", "string"] }
  }
};
class GetFriendList extends BaseAction {
  actionName = ActionName.GetFriendList;
  payloadSchema = SchemaData$Z;
  async _handle(payload) {
    return OB11Entities.friendsV2(await this.core.apis.FriendApi.getBuddyV2(typeof payload.no_cache === "string" ? payload.no_cache === "true" : !!payload.no_cache));
  }
}

const SchemaData$Y = {
  type: "object",
  properties: {
    no_cache: { type: ["boolean", "string"] }
  }
};
class GetGroupList extends BaseAction {
  actionName = ActionName.GetGroupList;
  payloadSchema = SchemaData$Y;
  async _handle(payload) {
    return OB11Entities.groups(
      await this.core.apis.GroupApi.getGroups(
        typeof payload.no_cache === "string" ? payload.no_cache === "true" : !!payload.no_cache
      )
    );
  }
}

const SchemaData$X = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GetGroupInfo extends BaseAction {
  actionName = ActionName.GetGroupInfo;
  payloadSchema = SchemaData$X;
  async _handle(payload) {
    const group = (await this.core.apis.GroupApi.getGroups()).find((e) => e.groupCode == payload.group_id.toString());
    if (!group) {
      const data = await this.core.apis.GroupApi.searchGroup(payload.group_id.toString());
      if (!data) throw new Error("Group not found");
      return {
        ...data.searchGroupInfo,
        group_id: +payload.group_id,
        group_name: data.searchGroupInfo.groupName,
        member_count: data.searchGroupInfo.memberNum,
        max_member_count: data.searchGroupInfo.maxMemberNum
      };
    }
    return OB11Entities.group(group);
  }
}

const SchemaData$W = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    no_cache: { type: ["boolean", "string"] }
  },
  required: ["group_id", "user_id"]
};
class GetGroupMemberInfo extends BaseAction {
  actionName = ActionName.GetGroupMemberInfo;
  payloadSchema = SchemaData$W;
  parseBoolean(value) {
    return typeof value === "string" ? value === "true" : value;
  }
  async getUid(userId) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(userId.toString());
    if (!uid) throw new Error(`Uin2Uid Error: 用户ID ${userId} 不存在`);
    return uid;
  }
  async _handle(payload) {
    const isNocache = this.parseBoolean(payload.no_cache ?? true);
    const uid = await this.getUid(payload.user_id);
    const [member, info] = await Promise.all([
      this.core.apis.GroupApi.getGroupMemberEx(payload.group_id.toString(), uid, isNocache),
      this.core.apis.UserApi.getUserDetailInfo(uid)
    ]);
    if (!member) throw new Error(`群(${payload.group_id})成员${payload.user_id}不存在`);
    if (info) {
      Object.assign(member, info);
    } else {
      this.core.context.logger.logDebug(`获取群成员详细信息失败, 只能返回基础信息`);
    }
    return OB11Entities.groupMember(payload.group_id.toString(), member);
  }
}

class SendGroupMsg extends SendMsg {
  actionName = ActionName.SendGroupMsg;
  contextMode = ContextMode.Group;
  async check(payload) {
    delete payload.user_id;
    payload.message_type = "group";
    return super.check(payload);
  }
}

class SendPrivateMsg extends SendMsg {
  actionName = ActionName.SendPrivateMsg;
  contextMode = ContextMode.Private;
  async check(payload) {
    payload.message_type = "private";
    return super.check(payload);
  }
}

const SchemaData$V = {
  type: "object",
  properties: {
    message_id: {
      oneOf: [
        { type: "number" },
        { type: "string" }
      ]
    }
  },
  required: ["message_id"]
};
class DeleteMsg extends BaseAction {
  actionName = ActionName.DeleteMsg;
  payloadSchema = SchemaData$V;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(Number(payload.message_id));
    if (msg) {
      await this.core.apis.MsgApi.recallMsg(msg.Peer, msg.MsgId);
    } else {
      throw new Error("Recall failed");
    }
  }
}

const napCatVersion = "3.1.11";

class GetVersionInfo extends BaseAction {
  actionName = ActionName.GetVersionInfo;
  async _handle(payload) {
    return {
      app_name: "NapCat.Onebot",
      protocol_version: "v11",
      app_version: napCatVersion
    };
  }
}

class CanSendRecord extends BaseAction {
  actionName = ActionName.CanSendRecord;
  async _handle(_payload) {
    return {
      yes: true
    };
  }
}

class CanSendImage extends CanSendRecord {
  actionName = ActionName.CanSendImage;
}

class GetStatus extends BaseAction {
  actionName = ActionName.GetStatus;
  async _handle(payload) {
    return {
      online: !!this.core.selfInfo.online,
      good: true,
      stat: {}
    };
  }
}

class GoCQHTTPSendForwardMsg extends SendMsg {
  actionName = ActionName.GoCQHTTP_SendForwardMsg;
  async check(payload) {
    if (payload.messages) payload.message = normalize(payload.messages);
    return super.check(payload);
  }
}
class GoCQHTTPSendPrivateForwardMsg extends GoCQHTTPSendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendPrivateForwardMsg;
}
class GoCQHTTPSendGroupForwardMsg extends GoCQHTTPSendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendGroupForwardMsg;
}

class GoCQHTTPGetStrangerInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetStrangerInfo;
  async _handle(payload) {
    const user_id = payload.user_id.toString();
    const extendData = await this.core.apis.UserApi.getUserDetailInfoByUin(user_id);
    let uid = await this.core.apis.UserApi.getUidByUinV2(user_id);
    if (!uid) uid = extendData.detail.uid;
    const info = await this.core.apis.UserApi.getUserDetailInfo(uid);
    return {
      user_id: parseInt(extendData.detail.uin) ?? 0,
      uid: info.uid ?? uid,
      nickname: extendData.detail.simpleInfo.coreInfo.nick,
      age: extendData.detail.simpleInfo.baseInfo.age ?? info.age,
      qid: extendData.detail.simpleInfo.baseInfo.qid,
      qqLevel: calcQQLevel(extendData.detail.commonExt?.qqLevel ?? info.qqLevel),
      sex: OB11Entities.sex(extendData.detail.simpleInfo.baseInfo.sex) ?? OB11UserSex.unknown,
      long_nick: extendData.detail.simpleInfo.baseInfo.longNick ?? info.longNick,
      reg_time: extendData.detail.commonExt.regTime ?? info.regTime,
      is_vip: extendData.detail.simpleInfo.vasInfo?.svipFlag,
      is_years_vip: extendData.detail.simpleInfo.vasInfo?.yearVipFlag,
      vip_level: extendData.detail.simpleInfo.vasInfo?.vipLevel,
      remark: extendData.detail.simpleInfo.coreInfo.remark ?? info.remark,
      status: extendData.detail.simpleInfo.status?.status ?? info.status,
      login_days: 0
      //失效
    };
  }
}

const SchemaData$U = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] },
    times: { type: ["number", "string"] }
  },
  required: ["user_id", "times"]
};
class SendLike extends BaseAction {
  actionName = ActionName.SendLike;
  payloadSchema = SchemaData$U;
  async _handle(payload) {
    const qq = payload.user_id.toString();
    const uid = await this.core.apis.UserApi.getUidByUinV2(qq) || "";
    const result = await this.core.apis.UserApi.like(uid, parseInt(payload.times?.toString()) || 1);
    if (result.result !== 0) {
      throw `点赞失败 ${result.errMsg}`;
    }
    return null;
  }
}

const SchemaData$T = {
  type: "object",
  properties: {
    flag: { type: "string" },
    approve: { type: ["string", "boolean"] },
    reason: { type: "string", nullable: true }
  },
  required: ["flag"]
};
class SetGroupAddRequest extends BaseAction {
  actionName = ActionName.SetGroupAddRequest;
  payloadSchema = SchemaData$T;
  async _handle(payload) {
    const flag = payload.flag.toString();
    const approve = payload.approve?.toString() !== "false";
    await this.core.apis.GroupApi.handleGroupRequest(
      flag,
      approve ? GroupRequestOperateTypes.approve : GroupRequestOperateTypes.reject,
      payload.reason ?? " "
    );
    return null;
  }
}

const SchemaData$S = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    is_dismiss: { type: ["boolean", "string"] }
  },
  required: ["group_id"]
};
class SetGroupLeave extends BaseAction {
  actionName = ActionName.SetGroupLeave;
  payloadSchema = SchemaData$S;
  async _handle(payload) {
    await this.core.apis.GroupApi.quitGroup(payload.group_id.toString());
  }
}

class GetGuildList extends BaseAction {
  actionName = ActionName.GetGuildList;
  async _handle(payload) {
    return null;
  }
}

const SchemaData$R = {
  type: "object",
  properties: {
    flag: { type: "string" },
    approve: { type: ["string", "boolean"] },
    remark: { type: "string" }
  },
  required: ["flag"]
};
class SetFriendAddRequest extends BaseAction {
  actionName = ActionName.SetFriendAddRequest;
  payloadSchema = SchemaData$R;
  async _handle(payload) {
    const approve = payload.approve?.toString() !== "false";
    await this.core.apis.FriendApi.handleFriendRequest(payload.flag, approve);
    if (payload.remark) {
      const data = payload.flag.split("|");
      if (data.length < 2) {
        throw new Error("Invalid flag");
      }
      const friendUid = data[0];
      await this.core.apis.FriendApi.setBuddyRemark(friendUid, payload.remark);
    }
    return null;
  }
}

const SchemaData$Q = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    enable: { type: ["boolean", "string"] }
  },
  required: ["group_id"]
};
class SetGroupWholeBan extends BaseAction {
  actionName = ActionName.SetGroupWholeBan;
  payloadSchema = SchemaData$Q;
  async _handle(payload) {
    const enable = payload.enable?.toString() !== "false";
    await this.core.apis.GroupApi.banGroup(payload.group_id.toString(), enable);
    return null;
  }
}

const SchemaData$P = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    group_name: { type: "string" }
  },
  required: ["group_id", "group_name"]
};
class SetGroupName extends BaseAction {
  actionName = ActionName.SetGroupName;
  payloadSchema = SchemaData$P;
  async _handle(payload) {
    await this.core.apis.GroupApi.setGroupName(payload.group_id.toString(), payload.group_name);
    return null;
  }
}

const SchemaData$O = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    duration: { type: ["number", "string"] }
  },
  required: ["group_id", "user_id", "duration"]
};
class SetGroupBan extends BaseAction {
  actionName = ActionName.SetGroupBan;
  payloadSchema = SchemaData$O;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("uid error");
    await this.core.apis.GroupApi.banMember(
      payload.group_id.toString(),
      [{ uid, timeStamp: parseInt(payload.duration.toString()) }]
    );
    return null;
  }
}

const SchemaData$N = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    reject_add_request: { type: ["boolean", "string"] }
  },
  required: ["group_id", "user_id"]
};
class SetGroupKick extends BaseAction {
  actionName = ActionName.SetGroupKick;
  payloadSchema = SchemaData$N;
  async _handle(payload) {
    const rejectReq = payload.reject_add_request?.toString() == "true";
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("get Uid Error");
    await this.core.apis.GroupApi.kickMember(payload.group_id.toString(), [uid], rejectReq);
    return null;
  }
}

const SchemaData$M = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    enable: { type: ["boolean", "string"] }
  },
  required: ["group_id", "user_id"]
};
class SetGroupAdmin extends BaseAction {
  actionName = ActionName.SetGroupAdmin;
  payloadSchema = SchemaData$M;
  async _handle(payload) {
    const enable = typeof payload.enable === "string" ? payload.enable === "true" : !!payload.enable;
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("get Uid Error");
    await this.core.apis.GroupApi.setMemberRole(payload.group_id.toString(), uid, enable ? GroupMemberRole.admin : GroupMemberRole.normal);
    return null;
  }
}

const SchemaData$L = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    card: { type: "string" }
  },
  required: ["group_id", "user_id", "card"]
};
class SetGroupCard extends BaseAction {
  actionName = ActionName.SetGroupCard;
  payloadSchema = SchemaData$L;
  async _handle(payload) {
    const member = await this.core.apis.GroupApi.getGroupMember(payload.group_id.toString(), payload.user_id.toString());
    if (member) await this.core.apis.GroupApi.setMemberCard(payload.group_id.toString(), member.uid, payload.card || "");
    return null;
  }
}

const GetFileBase_PayloadSchema = {
  type: "object",
  properties: {
    file: { type: "string" },
    file_id: { type: "string" }
  },
  oneOf: [
    { required: ["file"] },
    { required: ["file_id"] }
  ]
};
class GetFileBase extends BaseAction {
  payloadSchema = GetFileBase_PayloadSchema;
  async _handle(payload) {
    payload.file ||= payload.file_id || "";
    const contextMsgFile = FileNapCatOneBotUUID.decode(payload.file);
    if (contextMsgFile) {
      const { peer, msgId, elementId } = contextMsgFile;
      const downloadPath = await this.core.apis.FileApi.downloadMedia(msgId, peer.chatType, peer.peerUid, elementId, "", "");
      const rawMessage = (await this.core.apis.MsgApi.getMsgsByMsgId(peer, [msgId]))?.msgList.find((msg) => msg.msgId === msgId);
      const mixElement = rawMessage?.elements.find((e) => e.elementId === elementId);
      const mixElementInner = mixElement?.videoElement ?? mixElement?.fileElement ?? mixElement?.pttElement ?? mixElement?.picElement;
      if (!mixElementInner) throw new Error("element not found");
      const fileSize = mixElementInner.fileSize?.toString() ?? "";
      const fileName = mixElementInner.fileName ?? "";
      let url = "";
      if (mixElement?.picElement && rawMessage) {
        const tempData = await this.obContext.apis.MsgApi.rawToOb11Converters.picElement?.(mixElement?.picElement, rawMessage, mixElement);
        url = tempData?.data.url ?? "";
      }
      if (mixElement?.videoElement && rawMessage) {
        const tempData = await this.obContext.apis.MsgApi.rawToOb11Converters.videoElement?.(mixElement?.videoElement, rawMessage, mixElement);
        url = tempData?.data.url ?? "";
      }
      const res = {
        file: downloadPath,
        url: url !== "" ? url : downloadPath,
        file_size: fileSize,
        file_name: fileName
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    const contextModelIdFile = FileNapCatOneBotUUID.decodeModelId(payload.file);
    if (contextModelIdFile) {
      const { peer, modelId } = contextModelIdFile;
      const downloadPath = await this.core.apis.FileApi.downloadFileForModelId(peer, modelId, "");
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: "",
        file_name: ""
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    const searchResult = await this.core.apis.FileApi.searchForFile([payload.file]);
    if (searchResult) {
      const downloadPath = await this.core.apis.FileApi.downloadFileById(searchResult.id, parseInt(searchResult.fileSize));
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: searchResult.fileSize.toString(),
        file_name: searchResult.fileName
      };
      if (this.obContext.configLoader.configData.enableLocalFile2Url && downloadPath) {
        try {
          res.base64 = await fsPromise.readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error("文件下载失败. " + e);
        }
      }
      return res;
    }
    throw new Error("file not found");
  }
}
class GetFile extends GetFileBase {
  actionName = ActionName.GetFile;
}

class GetImage extends GetFileBase {
  actionName = ActionName.GetImage;
}

const FFMPEG_PATH = process.env.FFMPEG_PATH || "ffmpeg";
class GetRecord extends GetFileBase {
  actionName = ActionName.GetRecord;
  async _handle(payload) {
    const res = await super._handle(payload);
    if (payload.out_format && typeof payload.out_format === "string") {
      const inputFile = res.file;
      if (!inputFile) throw new Error("file not found");
      const pcmFile = `${inputFile}.pcm`;
      const outputFile = `${inputFile}.${payload.out_format}`;
      try {
        await promises.access(inputFile);
        await this.decodeFile(inputFile, pcmFile);
        await this.convertFile(pcmFile, outputFile, payload.out_format);
        const base64Data = await promises.readFile(outputFile, { encoding: "base64" });
        res.file = outputFile;
        res.url = outputFile;
        res.base64 = base64Data;
      } catch (error) {
        console.error("Error processing file:", error);
        throw error;
      }
    }
    return res;
  }
  async decodeFile(inputFile, outputFile) {
    try {
      const inputData = await promises.readFile(inputFile);
      const decodedData = await decode(inputData, 24e3);
      await promises.writeFile(outputFile, Buffer.from(decodedData.data));
    } catch (error) {
      console.error("Error decoding file:", error);
      throw error;
    }
  }
  convertFile(inputFile, outputFile, format) {
    return new Promise((resolve, reject) => {
      const ffmpeg = spawn(FFMPEG_PATH, ["-f", "s16le", "-ar", "24000", "-ac", "1", "-i", inputFile, outputFile]);
      ffmpeg.on("close", (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`ffmpeg process exited with code ${code}`));
        }
      });
      ffmpeg.on("error", (error) => {
        reject(error);
      });
    });
  }
}

const SchemaData$K = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] },
    group_id: { type: ["number", "string"] }
  }
};
class MarkMsgAsRead extends BaseAction {
  async getPeer(payload) {
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw `私聊${payload.user_id}不存在`;
      }
      const isBuddy = await this.core.apis.FriendApi.isBuddy(peerUid);
      return { chatType: isBuddy ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid };
    }
    if (!payload.group_id) {
      throw new Error("缺少参数 group_id 或 user_id");
    }
    return { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
  }
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.setMsgRead(await this.getPeer(payload));
    if (ret.result != 0) {
      throw new Error("设置已读失败," + ret.errMsg);
    }
    return null;
  }
}
class MarkPrivateMsgAsRead extends MarkMsgAsRead {
  payloadSchema = SchemaData$K;
  actionName = ActionName.MarkPrivateMsgAsRead;
}
class MarkGroupMsgAsRead extends MarkMsgAsRead {
  payloadSchema = SchemaData$K;
  actionName = ActionName.MarkGroupMsgAsRead;
}
class GoCQHTTPMarkMsgAsRead extends MarkMsgAsRead {
  actionName = ActionName.GoCQHTTP_MarkMsgAsRead;
}
class MarkAllMsgAsRead extends BaseAction {
  actionName = ActionName._MarkAllMsgAsRead;
  async _handle() {
    await this.core.apis.MsgApi.markAllMsgAsRead();
    return null;
  }
}

const SchemaData$J = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    file: { type: "string" },
    name: { type: "string" },
    folder: { type: "string" },
    folder_id: { type: "string" }
    //临时扩展
  },
  required: ["group_id", "file", "name"]
};
class GoCQHTTPUploadGroupFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_UploadGroupFile;
  payloadSchema = SchemaData$J;
  async _handle(payload) {
    let file = payload.file;
    if (fs__default.existsSync(file)) {
      file = `file://${file}`;
    }
    const downloadResult = await uri2local(this.core.NapCatTempPath, file);
    const peer = {
      chatType: ChatType.KCHATTYPEGROUP,
      peerUid: payload.group_id.toString()
    };
    if (!downloadResult.success) {
      throw new Error(downloadResult.errMsg);
    }
    const msgContext = {
      peer,
      deleteAfterSentFiles: []
    };
    const sendFileEle = await this.core.apis.FileApi.createValidSendFileElement(msgContext, downloadResult.path, payload.name, payload.folder ?? payload.folder_id);
    await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(peer, [sendFileEle], [], true);
    return null;
  }
}

class SetAvatar extends BaseAction {
  actionName = ActionName.SetQQAvatar;
  // 用不着复杂检测
  async check(payload) {
    if (!payload.file || typeof payload.file != "string") {
      return {
        valid: false,
        message: "file字段不能为空或者类型错误"
      };
    }
    return {
      valid: true
    };
  }
  async _handle(payload) {
    const { path, success } = await uri2local(this.core.NapCatTempPath, payload.file);
    if (!success) {
      throw `头像${payload.file}设置失败,file字段可能格式不正确`;
    }
    if (path) {
      await checkFileReceived(path, 5e3);
      const ret = await this.core.apis.UserApi.setQQAvatar(path);
      fs$3.unlink(path, () => {
      });
      if (!ret) {
        throw `头像${payload.file}设置失败,api无返回`;
      }
      if (ret["result"] == 1004022) {
        throw `头像${payload.file}设置失败，文件可能不是图片格式`;
      } else if (ret["result"] != 0) {
        throw `头像${payload.file}设置失败,未知的错误,${ret["result"]}:${ret["errMsg"]}`;
      }
    } else {
      fs$3.unlink(path, () => {
      });
      throw `头像${payload.file}设置失败,无法获取头像,文件可能不存在`;
    }
    return null;
  }
}

const SchemaData$I = {
  type: "object",
  properties: {
    thread_count: { type: ["number", "string"] },
    url: { type: "string" },
    base64: { type: "string" },
    name: { type: "string" },
    headers: {
      type: ["string", "array"],
      items: {
        type: "string"
      }
    }
  }
};
class GoCQHTTPDownloadFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_DownloadFile;
  payloadSchema = SchemaData$I;
  async _handle(payload) {
    const isRandomName = !payload.name;
    const name = payload.name || randomUUID();
    const filePath = join(this.core.NapCatTempPath, name);
    if (payload.base64) {
      fs__default.writeFileSync(filePath, payload.base64, "base64");
    } else if (payload.url) {
      const headers = this.getHeaders(payload.headers);
      const buffer = await httpDownload({ url: payload.url, headers });
      fs__default.writeFileSync(filePath, Buffer.from(buffer), "binary");
    } else {
      throw new Error("不存在任何文件, 无法下载");
    }
    if (fs__default.existsSync(filePath)) {
      if (isRandomName) {
        const md5 = await calculateFileMD5(filePath);
        const newPath = join(this.core.NapCatTempPath, md5);
        fs__default.renameSync(filePath, newPath);
        return { file: newPath };
      }
      return { file: filePath };
    } else {
      throw new Error("文件写入失败, 检查权限");
    }
  }
  getHeaders(headersIn) {
    const headers = {};
    if (typeof headersIn == "string") {
      headersIn = headersIn.split("[\\r\\n]");
    }
    if (Array.isArray(headersIn)) {
      for (const headerItem of headersIn) {
        const spilt = headerItem.indexOf("=");
        if (spilt < 0) {
          headers[headerItem] = "";
        } else {
          const key = headerItem.substring(0, spilt);
          headers[key] = headerItem.substring(spilt + 1);
        }
      }
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/octet-stream";
    }
    return headers;
  }
}

const SchemaData$H = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    message_seq: { type: ["number", "string"] },
    count: { type: ["number", "string"] },
    reverseOrder: { type: ["boolean", "string"] }
  },
  required: ["group_id"]
};
class GoCQHTTPGetGroupMsgHistory extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupMsgHistory;
  payloadSchema = SchemaData$H;
  async _handle(payload) {
    const isReverseOrder = typeof payload.reverseOrder === "string" ? payload.reverseOrder === "true" : !!payload.reverseOrder;
    const MsgCount = +(payload.count ?? 20);
    const peer = { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
    const hasMessageSeq = !payload.message_seq ? !!payload.message_seq : !(payload.message_seq?.toString() === "" || payload.message_seq?.toString() === "0");
    const startMsgId = hasMessageSeq ? MessageUnique.getMsgIdAndPeerByShortId(+payload.message_seq)?.MsgId ?? payload.message_seq.toString() : "0";
    const msgList = hasMessageSeq ? (await this.core.apis.MsgApi.getMsgHistory(peer, startMsgId, MsgCount)).msgList : (await this.core.apis.MsgApi.getAioFirstViewLatestMsgs(peer, MsgCount)).msgList;
    if (msgList.length === 0) throw `消息${payload.message_seq}不存在`;
    if (isReverseOrder) msgList.reverse();
    await Promise.all(msgList.map(async (msg) => {
      msg.id = MessageUnique.createUniqueMsgId({ guildId: "", chatType: msg.chatType, peerUid: msg.peerUid }, msg.msgId);
    }));
    const ob11MsgList = (await Promise.all(
      msgList.map((msg) => this.obContext.apis.MsgApi.parseMessage(msg))
    )).filter((msg) => msg !== void 0);
    return { "messages": ob11MsgList };
  }
}

const SchemaData$G = {
  type: "object",
  properties: {
    message_id: { type: "string" },
    id: { type: "string" }
  }
};
class GoCQHTTPGetForwardMsgAction extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetForwardMsg;
  payloadSchema = SchemaData$G;
  createTemplateNode(message) {
    return {
      type: OB11MessageDataType.node,
      data: {
        user_id: message.user_id,
        nickname: message.sender.nickname,
        message: [],
        content: []
      }
    };
  }
  async parseForward(messages) {
    const retMsg = [];
    for (const message of messages) {
      const templateNode = this.createTemplateNode(message);
      for (const msgdata of message.message) {
        if (msgdata.type === OB11MessageDataType.forward) {
          const newNode = this.createTemplateNode(message);
          newNode.data.message = await this.parseForward(msgdata.data.content);
          templateNode.data.message.push(newNode);
        } else {
          templateNode.data.message.push(msgdata);
        }
      }
      retMsg.push(templateNode);
    }
    return retMsg;
  }
  async _handle(payload) {
    const msgId = payload.message_id || payload.id;
    if (!msgId) {
      throw new Error("message_id is required");
    }
    const rootMsgId = MessageUnique.getShortIdByMsgId(msgId);
    const rootMsg = MessageUnique.getMsgIdAndPeerByShortId(rootMsgId || parseInt(msgId));
    if (!rootMsg) {
      throw new Error("msg not found");
    }
    const data = await this.core.apis.MsgApi.getMsgsByMsgId(rootMsg.Peer, [rootMsg.MsgId]);
    if (!data || data.result !== 0) {
      throw new Error("找不到相关的聊天记录" + data?.errMsg);
    }
    const singleMsg = data.msgList[0];
    const resMsg = await this.obContext.apis.MsgApi.parseMessage(singleMsg, "array");
    if (!resMsg) {
      throw new Error("找不到相关的聊天记录");
    }
    const realmsg = (await this.parseForward([resMsg]))[0].data.message[0].data.message;
    return { message: realmsg };
  }
}

const SchemaData$F = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] },
    message_seq: { type: ["number", "string"] },
    count: { type: ["number", "string"] },
    reverseOrder: { type: ["boolean", "string"] }
  },
  required: ["user_id"]
};
class GetFriendMsgHistory extends BaseAction {
  actionName = ActionName.GetFriendMsgHistory;
  payloadSchema = SchemaData$F;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    const MsgCount = +(payload.count ?? 20);
    const isReverseOrder = typeof payload.reverseOrder === "string" ? payload.reverseOrder === "true" : !!payload.reverseOrder;
    if (!uid) throw `记录${payload.user_id}不存在`;
    const friend = await this.core.apis.FriendApi.isBuddy(uid);
    const peer = { chatType: friend ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid: uid };
    const hasMessageSeq = !payload.message_seq ? !!payload.message_seq : !(payload.message_seq?.toString() === "" || payload.message_seq?.toString() === "0");
    const startMsgId = hasMessageSeq ? MessageUnique.getMsgIdAndPeerByShortId(+payload.message_seq)?.MsgId ?? payload.message_seq.toString() : "0";
    const msgList = hasMessageSeq ? (await this.core.apis.MsgApi.getMsgHistory(peer, startMsgId, MsgCount)).msgList : (await this.core.apis.MsgApi.getAioFirstViewLatestMsgs(peer, MsgCount)).msgList;
    if (msgList.length === 0) throw `消息${payload.message_seq}不存在`;
    if (isReverseOrder) msgList.reverse();
    await Promise.all(msgList.map(async (msg) => {
      msg.id = MessageUnique.createUniqueMsgId({ guildId: "", chatType: msg.chatType, peerUid: msg.peerUid }, msg.msgId);
    }));
    const ob11MsgList = (await Promise.all(
      msgList.map((msg) => this.obContext.apis.MsgApi.parseMessage(msg))
    )).filter((msg) => msg !== void 0);
    return { "messages": ob11MsgList };
  }
}

const SchemaData$E = {
  type: "object",
  properties: {
    domain: { type: "string" }
  },
  required: ["domain"]
};
class GetCookies extends BaseAction {
  actionName = ActionName.GetCookies;
  payloadSchema = SchemaData$E;
  async _handle(payload) {
    const cookiesObject = await this.core.apis.UserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key, value]) => `${key}=${value}`).join("; ");
    const bkn = cookiesObject?.skey ? this.core.apis.WebApi.getBknFromCookie(cookiesObject) : "";
    return { cookies, bkn };
  }
}

const SchemaData$D = {
  type: "object",
  properties: {
    message_id: { type: ["string", "number"] },
    emoji_id: { type: ["string", "number"] }
  },
  required: ["message_id", "emoji_id"]
};
class SetMsgEmojiLike extends BaseAction {
  actionName = ActionName.SetMsgEmojiLike;
  payloadSchema = SchemaData$D;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(parseInt(payload.message_id.toString()));
    if (!msg) {
      throw new Error("msg not found");
    }
    if (!payload.emoji_id) {
      throw new Error("emojiId not found");
    }
    const msgData = (await this.core.apis.MsgApi.getMsgsByMsgId(msg.Peer, [msg.MsgId])).msgList;
    if (!msgData || msgData.length == 0 || !msgData[0].msgSeq) {
      throw new Error("find msg by msgid error");
    }
    return await this.core.apis.MsgApi.setEmojiLike(msg.Peer, msgData[0].msgSeq, payload.emoji_id.toString(), true);
  }
}

class GetRobotUinRange extends BaseAction {
  actionName = ActionName.GetRobotUinRange;
  async _handle(payload) {
    return await this.core.apis.UserApi.getRobotUinRange();
  }
}

const SchemaData$C = {
  type: "object",
  properties: {
    status: { type: ["number", "string"] },
    ext_status: { type: ["number", "string"] },
    battery_status: { type: ["number", "string"] }
  },
  required: ["status", "ext_status", "battery_status"]
};
class SetOnlineStatus extends BaseAction {
  actionName = ActionName.SetOnlineStatus;
  payloadSchema = SchemaData$C;
  async _handle(payload) {
    const ret = await this.core.apis.UserApi.setSelfOnlineStatus(
      parseInt(payload.status.toString()),
      parseInt(payload.ext_status.toString()),
      parseInt(payload.battery_status.toString())
    );
    if (ret.result !== 0) {
      throw new Error("设置在线状态失败");
    }
    return null;
  }
}

const SchemaData$B = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GetGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupNotice;
  payloadSchema = SchemaData$B;
  async _handle(payload) {
    const group = payload.group_id.toString();
    const ret = await this.core.apis.WebApi.getGroupNotice(group);
    if (!ret) {
      throw new Error("获取公告失败");
    }
    const retNotices = new Array();
    for (const key in ret.feeds) {
      const retApiNotice = ret.feeds[key];
      const retNotice = {
        notice_id: retApiNotice.fid,
        sender_id: retApiNotice.u,
        publish_time: retApiNotice.pubt,
        message: {
          text: retApiNotice.msg.text,
          image: retApiNotice.msg.pics?.map((pic) => {
            return { id: pic.id, height: pic.h, width: pic.w };
          }) || []
        }
      };
      retNotices.push(retNotice);
    }
    return retNotices;
  }
}

const SchemaData$A = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GetGroupEssence extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetEssenceMsg;
  payloadSchema = SchemaData$A;
  async msgSeqToMsgId(peer, msgSeq, msgRandom) {
    const replyMsgList = (await this.core.apis.MsgApi.getMsgsBySeqAndCount(peer, msgSeq, 1, true, true)).msgList.find((msg) => msg.msgSeq === msgSeq && msg.msgRandom === msgRandom);
    if (!replyMsgList) {
      return void 0;
    }
    return {
      id: MessageUnique.createUniqueMsgId(peer, replyMsgList.msgId),
      msg: replyMsgList
    };
  }
  async _handle(payload) {
    const msglist = (await this.core.apis.WebApi.getGroupEssenceMsgAll(payload.group_id.toString())).flatMap((e) => e.data.msg_list);
    if (!msglist) {
      throw new Error("获取失败");
    }
    return await Promise.all(msglist.map(async (msg) => {
      const msgOriginData = await this.msgSeqToMsgId({
        chatType: ChatType.KCHATTYPEGROUP,
        peerUid: payload.group_id.toString()
      }, msg.msg_seq.toString(), msg.msg_random.toString());
      if (msgOriginData) {
        const { id: message_id, msg: rawMessage } = msgOriginData;
        return {
          msg_seq: msg.msg_seq,
          msg_random: msg.msg_random,
          sender_id: +msg.sender_uin,
          sender_nick: msg.sender_nick,
          operator_id: +msg.add_digest_uin,
          operator_nick: msg.add_digest_nick,
          message_id,
          operator_time: msg.add_digest_time,
          content: (await this.obContext.apis.MsgApi.parseMessage(rawMessage))?.message
        };
      }
      const msgTempData = JSON.stringify({
        msg_seq: msg.msg_seq.toString(),
        msg_random: msg.msg_random.toString(),
        group_id: payload.group_id.toString()
      });
      const hash = crypto__default.createHash("md5").update(msgTempData).digest();
      hash[0] &= 127;
      const shortId = hash.readInt32BE(0);
      this.core.apis.GroupApi.essenceLRU.set(shortId, msgTempData);
      return {
        msg_seq: msg.msg_seq,
        msg_random: msg.msg_random,
        sender_id: +msg.sender_uin,
        sender_nick: msg.sender_nick,
        operator_id: +msg.add_digest_uin,
        operator_nick: msg.add_digest_nick,
        message_id: shortId,
        operator_time: msg.add_digest_time,
        content: msg.msg_content.map((msg2) => {
          if (msg2.msg_type === 1) {
            return {
              type: "text",
              data: {
                text: msg2?.text
              }
            };
          } else if (msg2.msg_type === 3) {
            return {
              type: "image",
              data: {
                url: msg2?.image_url
              }
            };
          }
          return void 0;
        }).filter((e) => e !== void 0)
      };
    }));
  }
}

const SchemaData$z = {
  type: "object",
  properties: {
    message_id: { type: ["number", "string"] },
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] }
  },
  required: ["message_id"]
};
class ForwardSingleMsg extends BaseAction {
  async getTargetPeer(payload) {
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw new Error(`无法找到私聊对象${payload.user_id}`);
      }
      return { chatType: ChatType.KCHATTYPEC2C, peerUid };
    }
    return { chatType: ChatType.KCHATTYPEGROUP, peerUid: payload.group_id.toString() };
  }
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(parseInt(payload.message_id.toString()));
    if (!msg) {
      throw new Error(`无法找到消息${payload.message_id}`);
    }
    const peer = await this.getTargetPeer(payload);
    const ret = await this.core.apis.MsgApi.forwardMsg(
      msg.Peer,
      peer,
      [msg.MsgId]
    );
    if (ret.result !== 0) {
      throw new Error(`转发消息失败 ${ret.errMsg}`);
    }
    return null;
  }
}
class ForwardFriendSingleMsg extends ForwardSingleMsg {
  payloadSchema = SchemaData$z;
  actionName = ActionName.ForwardFriendSingleMsg;
}
class ForwardGroupSingleMsg extends ForwardSingleMsg {
  payloadSchema = SchemaData$z;
  actionName = ActionName.ForwardGroupSingleMsg;
}

class GetFriendWithCategory extends BaseAction {
  actionName = ActionName.GetFriendsWithCategory;
  async _handle(payload) {
    return (await this.core.apis.FriendApi.getBuddyV2ExWithCate(true)).map((category) => ({
      ...category,
      buddyList: OB11Entities.friendsV2(category.buddyList)
    }));
  }
}

class SendGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_SendGroupNotice;
  async _handle(payload) {
    let UploadImage = void 0;
    if (payload.image) {
      const {
        path,
        success
      } = await uri2local(this.core.NapCatTempPath, payload.image);
      if (!success) {
        throw `群公告${payload.image}设置失败,image字段可能格式不正确`;
      }
      if (!path) {
        throw `群公告${payload.image}设置失败,获取资源失败`;
      }
      await checkFileReceived(path, 5e3);
      const ImageUploadResult = await this.core.apis.GroupApi.uploadGroupBulletinPic(payload.group_id.toString(), path);
      if (ImageUploadResult.errCode != 0) {
        throw `群公告${payload.image}设置失败,图片上传失败`;
      }
      unlink(path, () => {
      });
      UploadImage = ImageUploadResult.picInfo;
    }
    const noticeType = +(payload.type ?? 1);
    const noticePinned = +(payload.pinned ?? 0);
    const noticeShowEditCard = +(payload.is_show_edit_card ?? 0);
    const noticeTipWindowType = +(payload.tip_window_type ?? 0);
    const noticeConfirmRequired = +(payload.confirm_required ?? 1);
    const publishGroupBulletinResult = await this.core.apis.WebApi.setGroupNotice(
      payload.group_id.toString(),
      payload.content,
      noticePinned,
      noticeType,
      noticeShowEditCard,
      noticeTipWindowType,
      noticeConfirmRequired,
      UploadImage?.id,
      UploadImage?.width,
      UploadImage?.height
    );
    if (!publishGroupBulletinResult || publishGroupBulletinResult.ec != 0) {
      throw new Error(`设置群公告失败,错误信息:${publishGroupBulletinResult?.em}`);
    }
    return null;
  }
}

const SchemaData$y = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    type: { enum: [WebHonorType.ALL, WebHonorType.EMOTION, WebHonorType.LEGEND, WebHonorType.PERFORMER, WebHonorType.STRONG_NEWBIE, WebHonorType.TALKATIVE] }
  },
  required: ["group_id"]
};
class GetGroupHonorInfo extends BaseAction {
  actionName = ActionName.GetGroupHonorInfo;
  payloadSchema = SchemaData$y;
  async _handle(payload) {
    if (!payload.type) {
      payload.type = WebHonorType.ALL;
    }
    return await this.core.apis.WebApi.getGroupHonorInfo(payload.group_id.toString(), payload.type);
  }
}

class GoCQHTTPHandleQuickAction extends BaseAction {
  actionName = ActionName.GoCQHTTP_HandleQuickAction;
  async _handle(payload) {
    this.obContext.apis.QuickActionApi.handleQuickOperation(payload.context, payload.operation).catch(this.core.context.logger.logError.bind(this.core.context.logger));
    return null;
  }
}

class GetGroupIgnoredNotifies extends BaseAction {
  actionName = ActionName.GetGroupIgnoredNotifies;
  async _handle(payload) {
    const ignoredNotifies = await this.core.apis.GroupApi.getSingleScreenNotifies(true, 10);
    const retData = {
      join_requests: await Promise.all(
        ignoredNotifies.filter((notify) => notify.type === 7).map(async (SSNotify) => ({
          request_id: SSNotify.seq,
          requester_uin: await this.core.apis.UserApi.getUinByUidV2(SSNotify.user1?.uid),
          requester_nick: SSNotify.user1?.nickName,
          group_id: SSNotify.group?.groupCode,
          group_name: SSNotify.group?.groupName,
          checked: SSNotify.status !== GroupNotifyMsgStatus.KUNHANDLE,
          actor: await this.core.apis.UserApi.getUinByUidV2(SSNotify.user2?.uid) || 0
        }))
      )
    };
    return retData;
  }
}

class GetOnlineClient extends BaseAction {
  actionName = ActionName.GetOnlineClient;
  async _handle(payload) {
    this.core.apis.SystemApi.getOnlineDev();
    await sleep(500);
    return [];
  }
}

const SchemaData$x = {
  type: "object",
  properties: {
    image: { type: "string" }
  },
  required: ["image"]
};
class OCRImage extends BaseAction {
  actionName = ActionName.OCRImage;
  payloadSchema = SchemaData$x;
  async _handle(payload) {
    const { path, success } = await uri2local(this.core.NapCatTempPath, payload.image);
    if (!success) {
      throw `OCR ${payload.image}失败,image字段可能格式不正确`;
    }
    if (path) {
      await checkFileReceived(path, 5e3);
      const ret = await this.core.apis.SystemApi.ocrImage(path);
      fs__default.unlink(path, () => {
      });
      if (!ret) {
        throw `OCR ${payload.file}失败`;
      }
      return ret.result;
    }
    fs__default.unlink(path, () => {
    });
    throw `OCR ${payload.file}失败,文件可能不存在`;
  }
}
class IOCRImage extends OCRImage {
  actionName = ActionName.IOCRImage;
}

const SchemaData$w = {
  type: "object",
  properties: {
    words: {
      type: "array",
      items: { type: "string" }
    }
  },
  required: ["words"]
};
class TranslateEnWordToZn extends BaseAction {
  actionName = ActionName.TranslateEnWordToZn;
  payloadSchema = SchemaData$w;
  async _handle(payload) {
    const ret = await this.core.apis.SystemApi.translateEnWordToZn(payload.words);
    if (ret.result !== 0) {
      throw new Error("翻译失败");
    }
    return ret.words;
  }
}

const SchemaData$v = {
  type: "object",
  properties: {
    nickname: { type: "string" },
    personal_note: { type: "string" },
    sex: { type: ["number", "string"] }
    //传Sex值？建议传0
  },
  required: ["nickname"]
};
class SetQQProfile extends BaseAction {
  actionName = ActionName.SetQQProfile;
  payloadSchema = SchemaData$v;
  async _handle(payload) {
    const self = this.core.selfInfo;
    const OldProfile = await this.core.apis.UserApi.getUserDetailInfo(self.uid);
    return await this.core.apis.UserApi.modifySelfProfile({
      nick: payload.nickname,
      longNick: (payload?.personal_note ?? OldProfile?.longNick) || "",
      sex: parseInt(payload?.sex ? payload?.sex.toString() : OldProfile?.sex.toString()),
      birthday: {
        birthday_year: OldProfile?.birthday_year.toString(),
        birthday_month: OldProfile?.birthday_month.toString(),
        birthday_day: OldProfile?.birthday_day.toString()
      },
      location: void 0
    });
  }
}

const SchemaData$u = {
  type: "object",
  properties: {
    user_id: { type: "string" },
    group_id: { type: "string" },
    phoneNumber: { type: "string" }
  }
};
class SharePeer extends BaseAction {
  actionName = ActionName.SharePeer;
  payloadSchema = SchemaData$u;
  async _handle(payload) {
    if (payload.group_id) {
      return await this.core.apis.GroupApi.getGroupRecommendContactArkJson(payload.group_id);
    } else if (payload.user_id) {
      return await this.core.apis.UserApi.getBuddyRecommendContactArkJson(payload.user_id, payload.phoneNumber || "");
    }
  }
}
const SchemaDataGroupEx = {
  type: "object",
  properties: {
    group_id: { type: "string" }
  },
  required: ["group_id"]
};
class ShareGroupEx extends BaseAction {
  actionName = ActionName.ShareGroupEx;
  payloadSchema = SchemaDataGroupEx;
  async _handle(payload) {
    return await this.core.apis.GroupApi.getArkJsonGroupShare(payload.group_id);
  }
}

const SchemaData$t = {
  type: "object",
  properties: {
    rawData: { type: "string" },
    brief: { type: "string" }
  },
  required: ["brief", "rawData"]
};
class CreateCollection extends BaseAction {
  actionName = ActionName.CreateCollection;
  payloadSchema = SchemaData$t;
  async _handle(payload) {
    return await this.core.apis.CollectionApi.createCollection(
      this.core.selfInfo.uin,
      this.core.selfInfo.uid,
      this.core.selfInfo.nick,
      payload.brief,
      payload.rawData
    );
  }
}

const SchemaData$s = {
  type: "object",
  properties: {
    longNick: { type: "string" }
  },
  required: ["longNick"]
};
class SetLongNick extends BaseAction {
  actionName = ActionName.SetLongNick;
  payloadSchema = SchemaData$s;
  async _handle(payload) {
    return await this.core.apis.UserApi.setLongNick(payload.longNick);
  }
}

const SchemaData$r = {
  type: "object",
  properties: {
    message_id: { type: ["number", "string"] }
  },
  required: ["message_id"]
};
class DelEssenceMsg extends BaseAction {
  actionName = ActionName.DelEssenceMsg;
  payloadSchema = SchemaData$r;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(+payload.message_id);
    if (!msg) {
      const data = this.core.apis.GroupApi.essenceLRU.getValue(+payload.message_id);
      if (!data) throw new Error("消息不存在");
      const { msg_seq, msg_random, group_id } = JSON.parse(data);
      return await this.core.apis.GroupApi.removeGroupEssenceBySeq(group_id, msg_seq, msg_random);
    }
    return await this.core.apis.GroupApi.removeGroupEssence(
      msg.Peer.peerUid,
      msg.MsgId
    );
  }
}

const SchemaData$q = {
  type: "object",
  properties: {
    message_id: { type: ["number", "string"] }
  },
  required: ["message_id"]
};
class SetEssenceMsg extends BaseAction {
  actionName = ActionName.SetEssenceMsg;
  payloadSchema = SchemaData$q;
  async _handle(payload) {
    const msg = MessageUnique.getMsgIdAndPeerByShortId(parseInt(payload.message_id.toString()));
    if (!msg) {
      throw new Error("msg not found");
    }
    return await this.core.apis.GroupApi.addGroupEssence(
      msg.Peer.peerUid,
      msg.MsgId
    );
  }
}

const SchemaData$p = {
  type: "object",
  properties: {
    count: { type: ["number", "string"] }
  }
};
class GetRecentContact extends BaseAction {
  actionName = ActionName.GetRecentContact;
  payloadSchema = SchemaData$p;
  async _handle(payload) {
    const ret = await this.core.apis.UserApi.getRecentContactListSnapShot(+(payload.count || 10));
    return await Promise.all(ret.info.changedList.map(async (t) => {
      const FastMsg = await this.core.apis.MsgApi.getMsgsByMsgId({ chatType: t.chatType, peerUid: t.peerUid }, [t.msgId]);
      if (FastMsg.msgList.length > 0) {
        const lastestMsg = await this.obContext.apis.MsgApi.parseMessage(FastMsg.msgList[0]);
        return {
          lastestMsg,
          peerUin: t.peerUin,
          remark: t.remark,
          msgTime: t.msgTime,
          chatType: t.chatType,
          msgId: t.msgId,
          sendNickName: t.sendNickName,
          sendMemberName: t.sendMemberName,
          peerName: t.peerName
        };
      }
      return {
        peerUin: t.peerUin,
        remark: t.remark,
        msgTime: t.msgTime,
        chatType: t.chatType,
        msgId: t.msgId,
        sendNickName: t.sendNickName,
        sendMemberName: t.sendMemberName,
        peerName: t.peerName
      };
    }));
  }
}

class GetProfileLike extends BaseAction {
  actionName = ActionName.GetProfileLike;
  async _handle(payload) {
    const ret = await this.core.apis.UserApi.getProfileLike(this.core.selfInfo.uid);
    const listdata = ret.info.userLikeInfos[0].favoriteInfo.userInfos;
    for (let i = 0; i < listdata.length; i++) {
      listdata[i].uin = parseInt(await this.core.apis.UserApi.getUinByUidV2(listdata[i].uid) || "");
    }
    return listdata;
  }
}

class SetGroupPortrait extends BaseAction {
  actionName = ActionName.SetGroupPortrait;
  // 用不着复杂检测
  async check(payload) {
    if (!payload.file || typeof payload.file != "string" || !payload.group_id || typeof payload.group_id != "number") {
      return {
        valid: false,
        message: "file和group_id字段不能为空或者类型错误"
      };
    }
    return {
      valid: true
    };
  }
  async _handle(payload) {
    const { path, success } = await uri2local(this.core.NapCatTempPath, payload.file);
    if (!success) {
      throw `头像${payload.file}设置失败,file字段可能格式不正确`;
    }
    if (path) {
      await checkFileReceived(path, 5e3);
      const ret = await this.core.apis.GroupApi.setGroupAvatar(payload.group_id.toString(), path);
      fs$3.unlink(path, () => {
      });
      if (!ret) {
        throw `头像${payload.file}设置失败,api无返回`;
      }
      if (ret["result"] == 1004022) {
        throw `头像${payload.file}设置失败，文件可能不是图片格式或权限不足`;
      } else if (ret["result"] != 0) {
        throw `头像${payload.file}设置失败,未知的错误,${ret["result"]}:${ret["errMsg"]}`;
      }
      return ret;
    } else {
      fs$3.unlink(path, () => {
      });
      throw `头像${payload.file}设置失败,无法获取头像,文件可能不存在`;
    }
  }
}

const SchemaData$o = {
  type: "object",
  properties: {
    count: { type: ["number", "string"] }
  }
};
class FetchCustomFace extends BaseAction {
  actionName = ActionName.FetchCustomFace;
  payloadSchema = SchemaData$o;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.fetchFavEmojiList(+(payload.count ?? 48));
    return ret.emojiInfoList.map((e) => e.url);
  }
}

const SchemaData$n = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] },
    file: { type: "string" },
    name: { type: "string" }
  },
  required: ["user_id", "file", "name"]
};
class GoCQHTTPUploadPrivateFile extends BaseAction {
  actionName = ActionName.GOCQHTTP_UploadPrivateFile;
  payloadSchema = SchemaData$n;
  async getPeer(payload) {
    if (payload.user_id) {
      const peerUid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
      if (!peerUid) {
        throw `私聊${payload.user_id}不存在`;
      }
      const isBuddy = await this.core.apis.FriendApi.isBuddy(peerUid);
      return { chatType: isBuddy ? ChatType.KCHATTYPEC2C : ChatType.KCHATTYPETEMPC2CFROMGROUP, peerUid };
    }
    throw new Error("缺少参数 user_id");
  }
  async _handle(payload) {
    let file = payload.file;
    if (fs__default.existsSync(file)) {
      file = `file://${file}`;
    }
    const downloadResult = await uri2local(this.core.NapCatTempPath, file);
    if (!downloadResult.success) {
      throw new Error(downloadResult.errMsg);
    }
    const msgContext = {
      peer: await createContext(this.core, {
        user_id: payload.user_id.toString(),
        group_id: void 0
      }, ContextMode.Private),
      deleteAfterSentFiles: []
    };
    const sendFileEle = await this.core.apis.FileApi.createValidSendFileElement(msgContext, downloadResult.path, payload.name);
    await this.obContext.apis.MsgApi.sendMsgWithOb11UniqueId(await this.getPeer(payload), [sendFileEle], [], true);
    return null;
  }
}

const SchemaData$m = {
  type: "object",
  properties: {
    user_id: { type: "string" },
    group_id: { type: "string" },
    emojiId: { type: "string" },
    emojiType: { type: "string" },
    message_id: { type: ["string", "number"] },
    count: { type: ["string", "number"] }
  },
  required: ["emojiId", "emojiType", "message_id"]
};
class FetchEmojiLike extends BaseAction {
  actionName = ActionName.FetchEmojiLike;
  payloadSchema = SchemaData$m;
  async _handle(payload) {
    const msgIdPeer = MessageUnique.getMsgIdAndPeerByShortId(parseInt(payload.message_id.toString()));
    if (!msgIdPeer) throw new Error("消息不存在");
    const msg = (await this.core.apis.MsgApi.getMsgsByMsgId(msgIdPeer.Peer, [msgIdPeer.MsgId])).msgList[0];
    return await this.core.apis.MsgApi.getMsgEmojiLikesList(msgIdPeer.Peer, msg.msgSeq, payload.emojiId, payload.emojiType, +(payload.count ?? 20));
  }
}

class FetchUserProfileLike extends BaseAction {
  actionName = ActionName.FetchUserProfileLike;
  async _handle(payload) {
    if (!payload.qq) throw new Error("qq is required");
    return await this.core.apis.UserApi.getUidByUinV2(payload.qq.toString());
  }
}

class GetGuildProfile extends BaseAction {
  actionName = ActionName.GetGuildProfile;
  async _handle(payload) {
    return null;
  }
}

class SetInputStatus extends BaseAction {
  actionName = ActionName.SetInputStatus;
  async _handle(payload) {
    let peer;
    if (payload.group_id) {
      peer = {
        chatType: ChatType.KCHATTYPEGROUP,
        peerUid: payload.group_id
      };
    } else if (payload.user_id) {
      const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id);
      if (!uid) throw new Error("uid is empty");
      peer = {
        chatType: ChatType.KCHATTYPEC2C,
        peerUid: uid
      };
    } else {
      throw new Error("请指定 group_id 或 user_id");
    }
    return await this.core.apis.MsgApi.sendShowInputStatusReq(peer, parseInt(payload.eventType));
  }
}

class GetCSRF extends BaseAction {
  actionName = ActionName.GetCSRF;
  async _handle(payload) {
    const sKey = await this.core.apis.UserApi.getSKey();
    if (!sKey) {
      throw new Error("SKey is undefined");
    }
    return {
      token: +this.core.apis.WebApi.getBknFromSKey(sKey)
    };
  }
}

const SchemaData$l = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    notice_id: { type: "string" }
  },
  required: ["group_id", "notice_id"]
};
class DelGroupNotice extends BaseAction {
  actionName = ActionName.DelGroupNotice;
  payloadSchema = SchemaData$l;
  async _handle(payload) {
    const group = payload.group_id.toString();
    const noticeId = payload.notice_id;
    return await this.core.apis.GroupApi.deleteGroupBulletin(group, noticeId);
  }
}

const SchemaData$k = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GetGroupInfoEx extends BaseAction {
  actionName = ActionName.GetGroupInfoEx;
  payloadSchema = SchemaData$k;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.getGroupExtFE0Info([payload.group_id.toString()])).result.groupExtInfos.get(payload.group_id.toString());
  }
}

const SchemaData$j = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] },
    file_id: { type: "string" }
  },
  required: ["group_id", "file_id"]
};
class DeleteGroupFile extends BaseAction {
  actionName = ActionName.GOCQHTTP_DeleteGroupFile;
  payloadSchema = SchemaData$j;
  async _handle(payload) {
    const data = FileNapCatOneBotUUID.decodeModelId(payload.file_id);
    if (!data) throw new Error("Invalid file_id");
    return await this.core.apis.GroupApi.DelGroupFile(payload.group_id.toString(), [data.fileId]);
  }
}

const SchemaData$i = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] },
    folder_name: { type: "string" }
  },
  required: ["group_id", "folder_name"]
};
class CreateGroupFileFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_CreateGroupFileFolder;
  payloadSchema = SchemaData$i;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.CreatGroupFileFolder(payload.group_id.toString(), payload.folder_name)).resultWithGroupItem;
  }
}

const SchemaData$h = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] },
    folder_id: { type: "string" },
    folder: { type: "string" }
  },
  required: ["group_id"]
};
class DeleteGroupFileFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteGroupFileFolder;
  payloadSchema = SchemaData$h;
  async _handle(payload) {
    return (await this.core.apis.GroupApi.DelGroupFileFolder(
      payload.group_id.toString(),
      payload.folder ?? payload.folder_id ?? ""
    )).groupFileCommonResult;
  }
}

const SchemaData$g = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] }
  },
  required: ["group_id"]
};
class GetGroupFileSystemInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileSystemInfo;
  payloadSchema = SchemaData$g;
  async _handle(payload) {
    return {
      file_count: (await this.core.apis.GroupApi.getGroupFileCount([payload.group_id.toString()])).groupFileCounts[0],
      limit_count: 1e4,
      used_space: 0,
      total_space: 10 * 1024 * 1024 * 1024
    };
  }
}

const SchemaData$f = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] },
    file_count: { type: ["string", "number"] }
  },
  required: ["group_id"]
};
class GetGroupRootFiles extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupRootFiles;
  payloadSchema = SchemaData$f;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.getGroupFileList(payload.group_id.toString(), {
      sortType: 1,
      fileCount: +(payload.file_count ?? 50),
      startIndex: 0,
      sortOrder: 2,
      showOnlinedocFolder: 0
    }).catch(() => []);
    return {
      files: ret.filter((item) => item.fileInfo).map((item) => OB11Entities.file(item.peerId, item.fileInfo)),
      folders: ret.filter((item) => item.folderInfo).map((item) => OB11Entities.folder(item.peerId, item.folderInfo))
    };
  }
}

const SchemaData$e = {
  type: "object",
  properties: {
    group_id: { type: ["string", "number"] },
    folder_id: { type: "string" },
    folder: { type: "string" },
    file_count: { type: ["string", "number"] }
  },
  required: ["group_id"]
};
class GetGroupFilesByFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFilesByFolder;
  payloadSchema = SchemaData$e;
  async _handle(payload) {
    const ret = await this.core.apis.MsgApi.getGroupFileList(payload.group_id.toString(), {
      sortType: 1,
      fileCount: +(payload.file_count ?? 50),
      startIndex: 0,
      sortOrder: 2,
      showOnlinedocFolder: 0,
      folderId: payload.folder ?? payload.folder_id ?? ""
    }).catch(() => []);
    return {
      files: ret.filter((item) => item.fileInfo).map((item) => OB11Entities.file(item.peerId, item.fileInfo)),
      folders: []
    };
  }
}

class GetGroupSystemMsg extends BaseAction {
  actionName = ActionName.GetGroupSystemMsg;
  async _handle(payload) {
    const NTQQUserApi = this.core.apis.UserApi;
    const NTQQGroupApi = this.core.apis.GroupApi;
    const SingleScreenNotifies = await NTQQGroupApi.getSingleScreenNotifies(false, 10);
    const retData = { InvitedRequest: [], join_requests: [] };
    for (const SSNotify of SingleScreenNotifies) {
      if (SSNotify.type == 1) {
        retData.InvitedRequest.push({
          request_id: SSNotify.seq,
          invitor_uin: await NTQQUserApi.getUinByUidV2(SSNotify.user1?.uid),
          invitor_nick: SSNotify.user1?.nickName,
          group_id: SSNotify.group?.groupCode,
          group_name: SSNotify.group?.groupName,
          checked: SSNotify.status === GroupNotifyMsgStatus.KUNHANDLE ? false : true,
          actor: await NTQQUserApi.getUinByUidV2(SSNotify.user2?.uid) || 0
        });
      } else if (SSNotify.type == 7) {
        retData.join_requests.push({
          request_id: SSNotify.seq,
          requester_uin: await NTQQUserApi.getUinByUidV2(SSNotify.user1?.uid),
          requester_nick: SSNotify.user1?.nickName,
          group_id: SSNotify.group?.groupCode,
          group_name: SSNotify.group?.groupName,
          checked: SSNotify.status === GroupNotifyMsgStatus.KUNHANDLE ? false : true,
          actor: await NTQQUserApi.getUinByUidV2(SSNotify.user2?.uid) || 0
        });
      }
    }
    return retData;
  }
}

class GetPacketStatusDepends extends BaseAction {
  actionName = ActionName.GetPacketStatus;
  async check(payload) {
    if (!this.core.apis.PacketApi.available) {
      return {
        valid: false,
        message: "packetServer不可用，请参照文档 https://napneko.github.io/config/advanced 检查packetServer状态或进行配置！"
      };
    }
    return await super.check(payload);
  }
}
class GetPacketStatus extends GetPacketStatusDepends {
  async _handle(payload) {
    return null;
  }
}

const SchemaData$d = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] }
  },
  required: ["group_id", "user_id"]
};
class GroupPoke extends GetPacketStatusDepends {
  actionName = ActionName.GroupPoke;
  payloadSchema = SchemaData$d;
  async _handle(payload) {
    await this.core.apis.PacketApi.sendPokePacket(+payload.user_id, +payload.group_id);
  }
}

const SchemaData$c = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] }
  },
  required: ["user_id"]
};
class GetUserStatus extends GetPacketStatusDepends {
  actionName = ActionName.GetUserStatus;
  payloadSchema = SchemaData$c;
  async _handle(payload) {
    return await this.core.apis.PacketApi.sendStatusPacket(+payload.user_id);
  }
}

class GetRkey extends GetPacketStatusDepends {
  actionName = ActionName.GetRkey;
  async _handle() {
    return await this.core.apis.PacketApi.sendRkeyPacket();
  }
}

const SchemaData$b = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    user_id: { type: ["number", "string"] },
    special_title: { type: "string" }
  },
  required: ["group_id", "user_id", "special_title"]
};
class SetSpecialTittle extends GetPacketStatusDepends {
  actionName = ActionName.SetSpecialTittle;
  payloadSchema = SchemaData$b;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.user_id.toString());
    if (!uid) throw new Error("User not found");
    await this.core.apis.PacketApi.sendSetSpecialTittlePacket(payload.group_id.toString(), uid, payload.special_title);
  }
}

const SchemaData$a = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GetGroupShutList extends BaseAction {
  actionName = ActionName.GetGroupShutList;
  payloadSchema = SchemaData$a;
  async _handle(payload) {
    return await this.core.apis.GroupApi.getGroupShutUpMemberList(payload.group_id.toString());
  }
}

const SchemaData$9 = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    no_cache: { type: ["boolean", "string"] }
  },
  required: ["group_id"]
};
class GetGroupMemberList extends BaseAction {
  actionName = ActionName.GetGroupMemberList;
  payloadSchema = SchemaData$9;
  async _handle(payload) {
    const groupIdStr = payload.group_id.toString();
    const noCache = payload.no_cache ? this.stringToBoolean(payload.no_cache) : false;
    const memberCache = this.core.apis.GroupApi.groupMemberCache;
    let groupMembers;
    if (noCache) {
      groupMembers = await this.core.apis.GroupApi.getGroupMembersV2(groupIdStr);
    } else {
      groupMembers = memberCache.get(groupIdStr) ?? await this.core.apis.GroupApi.getGroupMembersV2(groupIdStr);
    }
    const memberPromises = Array.from(groupMembers.values()).map(
      (item) => OB11Entities.groupMember(groupIdStr, item)
    );
    const _groupMembers = await Promise.all(memberPromises);
    const MemberMap = new Map(_groupMembers.map((member) => [member.user_id, member]));
    return Array.from(MemberMap.values());
  }
  stringToBoolean(str) {
    return typeof str === "boolean" ? str : str.toLowerCase() === "true";
  }
}

const SchemaData$8 = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] },
    file_id: { type: ["string"] }
  },
  required: ["group_id", "file_id"]
};
class GetGroupFileUrl extends GetPacketStatusDepends {
  actionName = ActionName.GOCQHTTP_GetGroupFileUrl;
  payloadSchema = SchemaData$8;
  async _handle(payload) {
    const contextMsgFile = FileNapCatOneBotUUID.decode(payload.file_id) || FileNapCatOneBotUUID.decodeModelId(payload.file_id);
    if (contextMsgFile?.fileUUID) {
      return {
        url: await this.core.apis.PacketApi.sendGroupFileDownloadReq(+payload.group_id, contextMsgFile.fileUUID)
      };
    }
    throw new Error("real fileUUID not found!");
  }
}

const SchemaData$7 = {
  type: "object",
  properties: {
    user_id: { type: ["number", "string"] }
  },
  required: ["user_id"]
};
class FriendPoke extends GetPacketStatusDepends {
  actionName = ActionName.FriendPoke;
  payloadSchema = SchemaData$7;
  async _handle(payload) {
    await this.core.apis.PacketApi.sendPokePacket(+payload.user_id);
  }
}

const SchemaData$6 = {
  type: "object",
  properties: {
    domain: { type: "string" }
  },
  required: ["domain"]
};
class GetCredentials extends BaseAction {
  actionName = ActionName.GetCredentials;
  payloadSchema = SchemaData$6;
  async _handle(payload) {
    const cookiesObject = await this.core.apis.UserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key, value]) => `${key}=${value}`).join("; ");
    const bkn = cookiesObject?.skey ? this.core.apis.WebApi.getBknFromCookie(cookiesObject) : "";
    return { cookies, token: +bkn };
  }
}

const SchemaData$5 = {
  type: "object",
  properties: {
    group_id: { type: "string" }
  },
  required: ["group_id"]
};
class SetGroupSign extends BaseAction {
  actionName = ActionName.SetGroupSign;
  payloadSchema = SchemaData$5;
  async _handle(payload) {
    return await this.core.apis.PacketApi.sendGroupSignPacket(payload.group_id);
  }
}

const SchemaData$4 = {
  type: "object",
  properties: {
    group_id: { type: ["number", "string"] }
  },
  required: ["group_id"]
};
class GoCQHTTPGetGroupAtAllRemain extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupAtAllRemain;
  payloadSchema = SchemaData$4;
  async _handle(payload) {
    const ret = await this.core.apis.GroupApi.getGroupRemainAtTimes(payload.group_id.toString());
    if (!ret.atInfo || ret.result !== 0) {
      throw new Error("atInfo not found");
    }
    const data = {
      can_at_all: ret.atInfo.canAtAll,
      remain_at_all_count_for_group: ret.atInfo.RemainAtAllCountForGroup,
      remain_at_all_count_for_uin: ret.atInfo.RemainAtAllCountForUin
    };
    return data;
  }
}

const SchemaData$3 = {
  type: "object",
  properties: {
    url: { type: "string" }
  },
  required: ["url"]
};
class GoCQHTTPCheckUrlSafely extends BaseAction {
  actionName = ActionName.GoCQHTTP_CheckUrlSafely;
  payloadSchema = SchemaData$3;
  async _handle(payload) {
    return { level: 1 };
  }
}

const SchemaData$2 = {
  type: "object",
  properties: {
    model: { type: "string" }
  }
};
class GoCQHTTPGetModelShow extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetModelShow;
  payloadSchema = SchemaData$2;
  async _handle(payload) {
    if (!payload.model) {
      payload.model = "napcat";
    }
    return [{
      variants: {
        model_show: "napcat",
        need_pay: false
      }
    }];
  }
}

const SchemaData$1 = {
  type: "object",
  properties: {}
};
class GoCQHTTPSetModelShow extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetModelShow;
  payloadSchema = SchemaData$1;
  async _handle(payload) {
    return null;
  }
}

const SchemaData = {
  type: "object",
  properties: {
    friend_id: { type: ["string", "number"] },
    temp_block: { type: "boolean" },
    temp_both_del: { type: "boolean" }
  },
  required: ["friend_id"]
};
class GoCQHTTPDeleteFriend extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteFriend;
  payloadSchema = SchemaData;
  async _handle(payload) {
    const uid = await this.core.apis.UserApi.getUidByUinV2(payload.friend_id.toString());
    if (!uid) {
      return {
        valid: false,
        message: "好友不存在"
      };
    }
    const isBuddy = await this.core.apis.FriendApi.isBuddy(uid);
    if (!isBuddy) {
      return {
        valid: false,
        message: "不是好友"
      };
    }
    return await this.core.apis.FriendApi.delBuudy(uid, payload.temp_block, payload.temp_both_del);
  }
}

function createActionMap(obContext, core) {
  const actionHandlers = [
    new GetGroupInfoEx(obContext, core),
    new FetchEmojiLike(obContext, core),
    new GetFile(obContext, core),
    new SetQQProfile(obContext, core),
    new ShareGroupEx(obContext, core),
    new SharePeer(obContext, core),
    new CreateCollection(obContext, core),
    new SetLongNick(obContext, core),
    new ForwardFriendSingleMsg(obContext, core),
    new ForwardGroupSingleMsg(obContext, core),
    new MarkGroupMsgAsRead(obContext, core),
    new MarkPrivateMsgAsRead(obContext, core),
    new SetAvatar(obContext, core),
    new TranslateEnWordToZn(obContext, core),
    new GetGroupRootFiles(obContext, core),
    new SetGroupSign(obContext, core),
    // onebot11
    new SendLike(obContext, core),
    new GetMsg(obContext, core),
    new GetLoginInfo(obContext, core),
    new GetFriendList(obContext, core),
    new GetGroupList(obContext, core),
    new GetGroupInfo(obContext, core),
    new GetGroupMemberList(obContext, core),
    new GetGroupMemberInfo(obContext, core),
    new SendGroupMsg(obContext, core),
    new SendPrivateMsg(obContext, core),
    new SendMsg(obContext, core),
    new DeleteMsg(obContext, core),
    new SetGroupAddRequest(obContext, core),
    new SetFriendAddRequest(obContext, core),
    new SetGroupLeave(obContext, core),
    new GetVersionInfo(obContext, core),
    new CanSendRecord(obContext, core),
    new CanSendImage(obContext, core),
    new GetStatus(obContext, core),
    new SetGroupWholeBan(obContext, core),
    new SetGroupBan(obContext, core),
    new SetGroupKick(obContext, core),
    new SetGroupAdmin(obContext, core),
    new SetGroupName(obContext, core),
    new SetGroupCard(obContext, core),
    new GetImage(obContext, core),
    new GetRecord(obContext, core),
    new SetMsgEmojiLike(obContext, core),
    new GetCookies(obContext, core),
    new SetOnlineStatus(obContext, core),
    new GetRobotUinRange(obContext, core),
    new GetFriendWithCategory(obContext, core),
    //以下为go-cqhttp api
    new GoCQHTTPDeleteFriend(obContext, core),
    new GoCQHTTPCheckUrlSafely(obContext, core),
    new GetOnlineClient(obContext, core),
    new OCRImage(obContext, core),
    new IOCRImage(obContext, core),
    new GetGroupHonorInfo(obContext, core),
    new SendGroupNotice(obContext, core),
    new GetGroupNotice(obContext, core),
    new GetGroupEssence(obContext, core),
    new GoCQHTTPGetGroupAtAllRemain(obContext, core),
    new GoCQHTTPSendForwardMsg(obContext, core),
    new GoCQHTTPSendGroupForwardMsg(obContext, core),
    new GoCQHTTPSendPrivateForwardMsg(obContext, core),
    new GoCQHTTPGetStrangerInfo(obContext, core),
    new GoCQHTTPDownloadFile(obContext, core),
    new GetGuildList(obContext, core),
    new GoCQHTTPMarkMsgAsRead(obContext, core),
    new GoCQHTTPUploadGroupFile(obContext, core),
    new GoCQHTTPGetGroupMsgHistory(obContext, core),
    new GoCQHTTPGetForwardMsgAction(obContext, core),
    new GetFriendMsgHistory(obContext, core),
    new GoCQHTTPHandleQuickAction(obContext, core),
    new GetGroupIgnoredNotifies(obContext, core),
    new DelEssenceMsg(obContext, core),
    new SetEssenceMsg(obContext, core),
    new GetRecentContact(obContext, core),
    new MarkAllMsgAsRead(obContext, core),
    new GetProfileLike(obContext, core),
    new SetGroupPortrait(obContext, core),
    new FetchCustomFace(obContext, core),
    new GoCQHTTPUploadPrivateFile(obContext, core),
    new GetGuildProfile(obContext, core),
    new GoCQHTTPGetModelShow(obContext, core),
    new GoCQHTTPSetModelShow(obContext, core),
    new GoCQHTTPCheckUrlSafely(obContext, core),
    new SetInputStatus(obContext, core),
    new GetCSRF(obContext, core),
    new GetCredentials(obContext, core),
    new DelGroupNotice(obContext, core),
    new DeleteGroupFile(obContext, core),
    new CreateGroupFileFolder(obContext, core),
    new DeleteGroupFileFolder(obContext, core),
    new GetGroupFileSystemInfo(obContext, core),
    new GetGroupFilesByFolder(obContext, core),
    new GetGroupSystemMsg(obContext, core),
    new FetchUserProfileLike(obContext, core),
    new GetPacketStatus(obContext, core),
    new GroupPoke(obContext, core),
    new FriendPoke(obContext, core),
    new GetUserStatus(obContext, core),
    new GetRkey(obContext, core),
    new SetSpecialTittle(obContext, core),
    // new UploadForwardMsg(obContext, core),
    new GetGroupShutList(obContext, core),
    new GetGroupFileUrl(obContext, core)
  ];
  const actionMap = /* @__PURE__ */ new Map();
  for (const action of actionHandlers) {
    actionMap.set(action.actionName, action);
    actionMap.set(action.actionName + "_async", action);
    actionMap.set(action.actionName + "_rate_limited", action);
  }
  return actionMap;
}

const LoginRuntime = {
  LoginCurrentTime: Date.now(),
  LoginCurrentRate: 0,
  QQLoginStatus: false,
  //已实现 但太傻了 得去那边注册个回调刷新
  QQQRCodeURL: "",
  QQLoginUin: "",
  NapCatHelper: {
    onOB11ConfigChanged: async () => {
      return;
    },
    onQuickLoginRequested: async () => {
      return { result: false, message: "" };
    },
    QQLoginList: []
  }
};
const WebUiDataRuntime = {
  checkLoginRate: async function(RateLimit) {
    LoginRuntime.LoginCurrentRate++;
    if (Date.now() - LoginRuntime.LoginCurrentTime > 1e3 * 60) {
      LoginRuntime.LoginCurrentRate = 0;
      LoginRuntime.LoginCurrentTime = Date.now();
      return true;
    }
    return LoginRuntime.LoginCurrentRate <= RateLimit;
  },
  getQQLoginStatus: async function() {
    return LoginRuntime.QQLoginStatus;
  },
  setQQLoginStatus: async function(status) {
    LoginRuntime.QQLoginStatus = status;
  },
  setQQLoginQrcodeURL: async function(url) {
    LoginRuntime.QQQRCodeURL = url;
  },
  getQQLoginQrcodeURL: async function() {
    return LoginRuntime.QQQRCodeURL;
  },
  setQQLoginUin: async function(uin) {
    LoginRuntime.QQLoginUin = uin;
  },
  getQQLoginUin: async function() {
    return LoginRuntime.QQLoginUin;
  },
  getQQQuickLoginList: async function() {
    return LoginRuntime.NapCatHelper.QQLoginList;
  },
  setQQQuickLoginList: async function(list) {
    LoginRuntime.NapCatHelper.QQLoginList = list;
  },
  setQuickLoginCall(func) {
    LoginRuntime.NapCatHelper.onQuickLoginRequested = func;
  },
  requestQuickLogin: async function(uin) {
    return await LoginRuntime.NapCatHelper.onQuickLoginRequested(uin);
  },
  setOnOB11ConfigChanged: async function(func) {
    LoginRuntime.NapCatHelper.onOB11ConfigChanged = func;
  },
  setOB11Config: async function(ob11) {
    await LoginRuntime.NapCatHelper.onOB11ConfigChanged(ob11);
  }
};

class OB11InputStatusEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "input_status";
  status_text = "对方正在输入...";
  event_type = 1;
  user_id = 0;
  group_id = 0;
  constructor(core, user_id, eventType, status_text) {
    super(core);
    this.user_id = user_id;
    this.event_type = eventType;
    this.status_text = status_text;
  }
}

class OB11FriendRequestEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "friend";
  user_id;
  comment;
  flag;
  constructor(core, user_id, comment, flag) {
    super(core);
    this.user_id = user_id;
    this.comment = comment;
    this.flag = flag;
  }
}

class OB11GroupAdminNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_admin";
  sub_type;
  // "set" | "unset"
  constructor(core, group_id, user_id, sub_type) {
    super(core, group_id, user_id);
    this.sub_type = sub_type;
  }
}

class OB11GroupRequestEvent extends OB11GroupNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "group";
  user_id;
  comment;
  flag;
  sub_type;
  constructor(core, groupId, userId, sub_type, comment, flag) {
    super(core, groupId, userId);
    this.user_id = userId;
    this.sub_type = sub_type;
    this.comment = comment;
    this.flag = flag;
  }
}

class OB11FriendRecallNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_recall";
  user_id;
  message_id;
  constructor(core, userId, messageId) {
    super(core);
    this.user_id = userId;
    this.message_id = messageId;
  }
}

class OB11GroupRecallNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_recall";
  operator_id;
  message_id;
  constructor(core, groupId, userId, operatorId, messageId) {
    super(core, groupId, userId);
    this.group_id = groupId;
    this.user_id = userId;
    this.operator_id = operatorId;
    this.message_id = messageId;
  }
}

class NodeIKernelRecentContactListener {
  onDeletedContactsNotify(...args) {
  }
  onRecentContactNotification(msgList, arg0, arg1) {
  }
  onMsgUnreadCountUpdate(...args) {
  }
  onGuildDisplayRecentContactListChanged(...args) {
  }
  onRecentContactListChanged(...args) {
  }
  onRecentContactListChangedVer2(...args) {
  }
}

class Native {
  platform;
  supportedPlatforms = [""];
  MoeHooExport = { exports: {} };
  recallHookEnabled = false;
  inited = true;
  constructor(nodePath, platform = process.platform) {
    this.platform = platform;
    try {
      if (!this.supportedPlatforms.includes(this.platform)) {
        throw new Error(`Platform ${this.platform} is not supported`);
      }
      const nativeNode = path$2.join(nodePath, "./native/MoeHoo.win32.node");
      if (fs__default.existsSync(nativeNode)) {
        dlopen(this.MoeHooExport, nativeNode, constants.dlopen.RTLD_LAZY);
      }
    } catch (error) {
      this.inited = false;
    }
  }
  isSetReCallEnabled() {
    return this.recallHookEnabled && this.inited;
  }
  registerRecallCallback(callback) {
    try {
      if (!this.inited) throw new Error("Native Not Init");
      if (this.MoeHooExport.exports?.registMsgPush) {
        this.MoeHooExport.exports.registMsgPush(callback);
        this.recallHookEnabled = true;
      }
    } catch (error) {
      this.recallHookEnabled = false;
    }
  }
}

const BodyInner = new MessageType("BodyInner", [
  { no: 1, name: "msgType", kind: "scalar", T: ScalarType.UINT32, opt: true },
  { no: 2, name: "subType", kind: "scalar", T: ScalarType.UINT32, opt: true }
]);
const NoifyData = new MessageType("NoifyData", [
  { no: 1, name: "skip", kind: "scalar", T: ScalarType.BYTES, opt: true },
  { no: 2, name: "innerData", kind: "scalar", T: ScalarType.BYTES, opt: true }
]);
const MsgHead = new MessageType("MsgHead", [
  { no: 2, name: "bodyInner", kind: "message", T: () => BodyInner, opt: true },
  { no: 3, name: "noifyData", kind: "message", T: () => NoifyData, opt: true }
]);
const Message = new MessageType("Message", [
  { no: 1, name: "msgHead", kind: "message", T: () => MsgHead }
]);
const SubDetail = new MessageType("SubDetail", [
  {
    no: 1,
    name: "msgSeq",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 2,
    name: "msgTime",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  {
    no: 6,
    name: "senderUid",
    kind: "scalar",
    T: ScalarType.STRING
    /* string */
  }
]);
const RecallDetails = new MessageType("RecallDetails", [
  {
    no: 1,
    name: "operatorUid",
    kind: "scalar",
    T: ScalarType.STRING
    /* string */
  },
  { no: 3, name: "subDetail", kind: "message", T: () => SubDetail }
]);
const RecallGroup = new MessageType("RecallGroup", [
  {
    no: 1,
    name: "type",
    kind: "scalar",
    T: ScalarType.INT32
    /* int32 */
  },
  {
    no: 4,
    name: "peerUid",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  },
  { no: 11, name: "recallDetails", kind: "message", T: () => RecallDetails },
  {
    no: 37,
    name: "grayTipsSeq",
    kind: "scalar",
    T: ScalarType.UINT32
    /* uint32 */
  }
]);
function decodeMessage(buffer) {
  const reader = new BinaryReader(buffer);
  return Message.internalBinaryRead(reader, reader.len, { readUnknownField: true, readerFactory: () => new BinaryReader(buffer) });
}
function decodeRecallGroup(buffer) {
  const reader = new BinaryReader(buffer);
  return RecallGroup.internalBinaryRead(reader, reader.len, { readUnknownField: true, readerFactory: () => new BinaryReader(buffer) });
}

class NapCatOneBot11Adapter {
  core;
  context;
  configLoader;
  apis;
  networkManager;
  actions;
  nativeCore;
  bootTime = Date.now() / 1e3;
  recallMsgCache = new LRUCache(100);
  constructor(core, context, pathWrapper) {
    this.core = core;
    this.context = context;
    this.configLoader = new OB11ConfigLoader(core, pathWrapper.configPath);
    this.apis = {
      GroupApi: new OneBotGroupApi(this, core),
      UserApi: new OneBotUserApi(this, core),
      FriendApi: new OneBotFriendApi(this, core),
      MsgApi: new OneBotMsgApi(this, core),
      QuickActionApi: new OneBotQuickActionApi(this, core)
    };
    this.actions = createActionMap(this, core);
    this.networkManager = new OB11NetworkManager();
    this.registerNative(core, context).catch((e) => this.context.logger.logWarn.bind(this.context.logger)("初始化Native失败", e)).then();
    this.InitOneBot().catch((e) => this.context.logger.logError.bind(this.context.logger)("初始化OneBot失败", e));
  }
  async registerNative(core, context) {
    try {
      this.nativeCore = new Native(context.pathWrapper.binaryPath);
      if (!this.nativeCore.inited) throw new Error("Native Not Init");
      this.nativeCore.registerRecallCallback(async (hex) => {
        try {
          const data = decodeMessage(Buffer.from(hex, "hex"));
          const bodyInner = data.msgHead?.bodyInner;
          if (bodyInner && bodyInner.msgType == 732 && bodyInner.subType == 17) {
            const RecallData = Buffer.from(data.msgHead.noifyData.innerData);
            const uid = RecallData.readUint32BE();
            const buffer = Buffer.from(RecallData.toString("hex").slice(14), "hex");
            const seq = decodeRecallGroup(buffer).recallDetails.subDetail.msgSeq;
            const peer = { chatType: ChatType.KCHATTYPEGROUP, peerUid: uid.toString() };
            context.logger.log("[Native] 群消息撤回 Peer: " + uid.toString() + " / MsgSeq:" + seq);
            const msgs = await core.apis.MsgApi.queryMsgsWithFilterExWithSeq(peer, seq.toString());
            this.recallMsgCache.put(msgs.msgList[0].msgId, msgs.msgList[0]);
          }
        } catch (error) {
          context.logger.logWarn("[Native] Error:", error.message, " HEX:", hex);
        }
      });
    } catch (error) {
      context.logger.logWarn("[Native] Error:", error.message);
      return;
    }
  }
  async InitOneBot() {
    const selfInfo = this.core.selfInfo;
    const ob11Config = this.configLoader.configData;
    const serviceInfo = `
    HTTP服务 ${ob11Config.http.enable ? "已启动" : "未启动"}, ${ob11Config.http.host}:${ob11Config.http.port}
    HTTP上报服务 ${ob11Config.http.enablePost ? "已启动" : "未启动"}, 上报地址: ${ob11Config.http.postUrls}
    WebSocket服务 ${ob11Config.ws.enable ? "已启动" : "未启动"}, ${ob11Config.ws.host}:${ob11Config.ws.port}
    WebSocket反向服务 ${ob11Config.reverseWs.enable ? "已启动" : "未启动"}, 反向地址: ${ob11Config.reverseWs.urls}`;
    this.core.apis.UserApi.getUserDetailInfo(selfInfo.uid).then((user) => {
      selfInfo.nick = user.nick;
      this.context.logger.setLogSelfInfo(selfInfo);
    }).catch(this.context.logger.logError.bind(this.context.logger));
    this.context.logger.log(`[Notice] [OneBot11] ${serviceInfo}`);
    if (ob11Config.http.enable) {
      this.networkManager.registerAdapter(new OB11PassiveHttpAdapter(
        ob11Config.http.port,
        ob11Config.token,
        this.core,
        this.actions
      ));
    }
    if (ob11Config.http.enablePost) {
      ob11Config.http.postUrls.forEach((url) => {
        this.networkManager.registerAdapter(new OB11ActiveHttpAdapter(
          url,
          ob11Config.http.secret,
          this.core,
          this
        ));
      });
    }
    if (ob11Config.ws.enable) {
      const OBPassiveWebSocketAdapter = new OB11PassiveWebSocketAdapter(
        ob11Config.ws.host,
        ob11Config.ws.port,
        ob11Config.heartInterval,
        ob11Config.token,
        this.core,
        this.actions
      );
      this.networkManager.registerAdapter(OBPassiveWebSocketAdapter);
    }
    if (ob11Config.reverseWs.enable) {
      ob11Config.reverseWs.urls.forEach((url) => {
        this.networkManager.registerAdapter(new OB11ActiveWebSocketAdapter(
          url,
          5e3,
          ob11Config.heartInterval,
          ob11Config.token,
          this.core,
          this.actions
        ));
      });
    }
    await this.networkManager.openAllAdapters();
    this.initMsgListener();
    this.initBuddyListener();
    this.initGroupListener();
    await WebUiDataRuntime.setQQLoginUin(selfInfo.uin.toString());
    await WebUiDataRuntime.setQQLoginStatus(true);
    await WebUiDataRuntime.setOnOB11ConfigChanged(async (newConfig) => {
      const prev = this.configLoader.configData;
      this.configLoader.save(newConfig);
      this.context.logger.log(`OneBot11 配置更改：${JSON.stringify(prev)} -> ${JSON.stringify(newConfig)}`);
      await this.reloadNetwork(prev, newConfig);
    });
  }
  initRecentContactListener() {
    const recentContactListener = new NodeIKernelRecentContactListener();
    recentContactListener.onRecentContactNotification = function(msgList) {
      msgList.forEach((msg) => {
        if (msg.chatType == ChatType.KCHATTYPEGROUP) ;
      });
    };
  }
  async reloadNetwork(prev, now) {
    const serviceInfo = `
    HTTP服务 ${now.http.enable ? "已启动" : "未启动"}, ${now.http.host}:${now.http.port}
    HTTP上报服务 ${now.http.enablePost ? "已启动" : "未启动"}, 上报地址: ${now.http.postUrls}
    WebSocket服务 ${now.ws.enable ? "已启动" : "未启动"}, ${now.ws.host}:${now.ws.port}
    WebSocket反向服务 ${now.reverseWs.enable ? "已启动" : "未启动"}, 反向地址: ${now.reverseWs.urls}`;
    this.context.logger.log(`[Notice] [OneBot11] 热重载 ${serviceInfo}`);
    if (prev.http.enable !== now.http.enable) {
      if (now.http.enable) {
        await this.networkManager.registerAdapterAndOpen(new OB11PassiveHttpAdapter(
          now.http.port,
          now.token,
          this.core,
          this.actions
        ));
      } else {
        await this.networkManager.closeAdapterByPredicate((adapter) => adapter instanceof OB11PassiveHttpAdapter);
      }
    }
    if (prev.http.enablePost !== now.http.enablePost) {
      if (now.http.enablePost) {
        now.http.postUrls.forEach((url) => {
          this.networkManager.registerAdapterAndOpen(new OB11ActiveHttpAdapter(
            url,
            now.http.secret,
            this.core,
            this
          ));
        });
      } else {
        await this.networkManager.closeAdapterByPredicate((adapter) => adapter instanceof OB11ActiveHttpAdapter);
      }
    } else {
      if (now.http.enablePost) {
        const { added, removed } = this.findDifference(prev.http.postUrls, now.http.postUrls);
        await this.networkManager.closeAdapterByPredicate(
          (adapter) => adapter instanceof OB11ActiveHttpAdapter && removed.includes(adapter.url)
        );
        for (const url of added) {
          await this.networkManager.registerAdapterAndOpen(new OB11ActiveHttpAdapter(
            url,
            now.http.secret,
            this.core,
            this
          ));
        }
      }
    }
    if (prev.ws.enable !== now.ws.enable) {
      if (now.ws.enable) {
        await this.networkManager.registerAdapterAndOpen(new OB11PassiveWebSocketAdapter(
          now.ws.host,
          now.ws.port,
          now.heartInterval,
          now.token,
          this.core,
          this.actions
        ));
      } else {
        await this.networkManager.closeAdapterByPredicate(
          (adapter) => adapter instanceof OB11PassiveWebSocketAdapter
        );
      }
    }
    if (prev.reverseWs.enable !== now.reverseWs.enable) {
      if (now.reverseWs.enable) {
        now.reverseWs.urls.forEach((url) => {
          this.networkManager.registerAdapterAndOpen(new OB11ActiveWebSocketAdapter(
            url,
            5e3,
            now.heartInterval,
            now.token,
            this.core,
            this.actions
          ));
        });
      } else {
        await this.networkManager.closeAdapterByPredicate(
          (adapter) => adapter instanceof OB11ActiveWebSocketAdapter
        );
      }
    } else {
      if (now.reverseWs.enable) {
        const { added, removed } = this.findDifference(prev.reverseWs.urls, now.reverseWs.urls);
        await this.networkManager.closeAdapterByPredicate(
          (adapter) => adapter instanceof OB11ActiveWebSocketAdapter && removed.includes(adapter.url)
        );
        for (const url of added) {
          await this.networkManager.registerAdapterAndOpen(new OB11ActiveWebSocketAdapter(
            url,
            5e3,
            now.heartInterval,
            now.token,
            this.core,
            this.actions
          ));
        }
      }
    }
  }
  findDifference(prev, now) {
    const added = now.filter((item) => !prev.includes(item));
    const removed = prev.filter((item) => !now.includes(item));
    return { added, removed };
  }
  initMsgListener() {
    const msgListener = new NodeIKernelMsgListener();
    msgListener.onRecvSysMsg = (msg) => {
      this.apis.MsgApi.parseSysMessage(msg).then((event) => {
        if (event) this.networkManager.emitEvent(event);
      }).catch((e) => this.context.logger.logError.bind(this.context.logger)("constructSysMessage error: ", e, "\n Parse Hex:", Buffer.from(msg).toString("hex")));
    };
    msgListener.onInputStatusPush = async (data) => {
      const uin = await this.core.apis.UserApi.getUinByUidV2(data.fromUin);
      this.context.logger.log(`[Notice] [输入状态] ${uin} ${data.statusText}`);
      await this.networkManager.emitEvent(new OB11InputStatusEvent(
        this.core,
        parseInt(uin),
        data.eventType,
        data.statusText
      ));
    };
    msgListener.onRecvMsg = async (msg) => {
      for (const m of msg) {
        if (this.bootTime > parseInt(m.msgTime)) {
          this.context.logger.logDebug(`消息时间${m.msgTime}早于启动时间${this.bootTime}，忽略上报`);
          continue;
        }
        m.id = MessageUnique.createUniqueMsgId(
          {
            chatType: m.chatType,
            peerUid: m.peerUid,
            guildId: ""
          },
          m.msgId
        );
        await this.emitMsg(m).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理消息失败", e));
      }
    };
    const msgIdSend = new LRUCache(100);
    const recallMsgs = new LRUCache(100);
    msgListener.onMsgInfoListUpdate = async (msgList) => {
      this.emitRecallMsg(msgList, recallMsgs).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理消息失败", e));
      for (const msg of msgList.filter((e) => e.senderUin == this.core.selfInfo.uin)) {
        if (msg.sendStatus == SendStatusType.KSEND_STATUS_SUCCESS && !msgIdSend.get(msg.msgId)) {
          msgIdSend.put(msg.msgId, true);
          this.apis.MsgApi.parseMessage(msg).then((ob11Msg) => {
            if (!ob11Msg) return;
            ob11Msg.target_id = parseInt(msg.peerUin);
            if (this.configLoader.configData.reportSelfMessage) {
              msg.id = MessageUnique.createUniqueMsgId({
                chatType: msg.chatType,
                peerUid: msg.peerUid,
                guildId: ""
              }, msg.msgId);
              this.emitMsg(msg);
            }
          });
        }
      }
    };
    this.context.session.getMsgService().addKernelMsgListener(
      proxiedListenerOf(msgListener, this.context.logger)
    );
  }
  initBuddyListener() {
    const buddyListener = new NodeIKernelBuddyListener();
    buddyListener.onBuddyReqChange = async (reqs) => {
      this.core.apis.FriendApi.clearBuddyReqUnreadCnt();
      for (let i = 0; i < reqs.unreadNums; i++) {
        const req = reqs.buddyReqs[i];
        if (!!req.isInitiator || req.isDecide && req.reqType !== BuddyReqType.KMEINITIATORWAITPEERCONFIRM) {
          continue;
        }
        try {
          const requesterUin = await this.core.apis.UserApi.getUinByUidV2(req.friendUid);
          await this.networkManager.emitEvent(new OB11FriendRequestEvent(
            this.core,
            parseInt(requesterUin),
            req.extWords,
            req.friendUid + "|" + req.reqTime
          ));
        } catch (e) {
          this.context.logger.logDebug("获取加好友者QQ号失败", e);
        }
      }
    };
    this.context.session.getBuddyService().addKernelBuddyListener(
      proxiedListenerOf(buddyListener, this.context.logger)
    );
  }
  initGroupListener() {
    const groupListener = new NodeIKernelGroupListener();
    groupListener.onGroupNotifiesUpdated = async (_, notifies) => {
      await this.core.apis.GroupApi.clearGroupNotifiesUnreadCount(false);
      if (![
        GroupNotifyMsgType.SET_ADMIN,
        GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_CANCELED,
        GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_ADMIN
      ].includes(notifies[0]?.type)) {
        for (const notify of notifies) {
          const notifyTime = parseInt(notify.seq) / 1e3 / 1e3;
          if (notifyTime < this.bootTime) {
            continue;
          }
          const flag = notify.group.groupCode + "|" + notify.seq + "|" + notify.type;
          this.context.logger.logDebug("收到群通知", notify);
          if ([
            GroupNotifyMsgType.SET_ADMIN,
            GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_CANCELED,
            GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_ADMIN
          ].includes(notify.type)) {
            const member1 = await this.core.apis.GroupApi.getGroupMember(notify.group.groupCode, notify.user1.uid);
            this.context.logger.logDebug("有管理员变动通知");
            this.context.logger.logDebug("开始获取变动的管理员");
            if (member1) {
              this.context.logger.logDebug("变动管理员获取成功");
              const groupAdminNoticeEvent = new OB11GroupAdminNoticeEvent(
                this.core,
                parseInt(notify.group.groupCode),
                parseInt(member1.uin),
                [
                  GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_CANCELED,
                  GroupNotifyMsgType.CANCEL_ADMIN_NOTIFY_ADMIN
                ].includes(notify.type) ? "unset" : "set"
              );
              this.networkManager.emitEvent(groupAdminNoticeEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理群管理员变动失败", e));
            } else {
              this.context.logger.logDebug("获取群通知的成员信息失败", notify, this.core.apis.GroupApi.getGroup(notify.group.groupCode));
            }
          } else if (notify.type == GroupNotifyMsgType.MEMBER_LEAVE_NOTIFY_ADMIN || notify.type == GroupNotifyMsgType.KICK_MEMBER_NOTIFY_ADMIN) {
            this.context.logger.logDebug("有成员退出通知", notify);
            const member1Uin = await this.core.apis.UserApi.getUinByUidV2(notify.user1.uid);
            let operatorId = member1Uin;
            let subType = "leave";
            if (notify.user2.uid) {
              const member2Uin = await this.core.apis.UserApi.getUinByUidV2(notify.user2.uid);
              if (member2Uin) {
                operatorId = member2Uin;
              }
              subType = "kick";
            }
            const groupDecreaseEvent = new OB11GroupDecreaseEvent(
              this.core,
              parseInt(notify.group.groupCode),
              parseInt(member1Uin),
              parseInt(operatorId),
              subType
            );
            this.networkManager.emitEvent(groupDecreaseEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理群成员退出失败", e));
          } else if ([
            GroupNotifyMsgType.REQUEST_JOIN_NEED_ADMINI_STRATOR_PASS
          ].includes(notify.type) && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug("有加群请求");
            try {
              let requestUin = await this.core.apis.UserApi.getUinByUidV2(notify.user1.uid);
              if (isNaN(parseInt(requestUin))) {
                requestUin = (await this.core.apis.UserApi.getUserDetailInfo(notify.user1.uid)).uin;
              }
              const groupRequestEvent = new OB11GroupRequestEvent(
                this.core,
                parseInt(notify.group.groupCode),
                parseInt(requestUin),
                "add",
                notify.postscript,
                flag
              );
              this.networkManager.emitEvent(groupRequestEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理加群请求失败", e));
            } catch (e) {
              this.context.logger.logError.bind(this.context.logger)("获取加群人QQ号失败 Uid:", notify.user1.uid, e);
            }
          } else if (notify.type == GroupNotifyMsgType.INVITED_BY_MEMBER && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug(`收到邀请我加群通知:${notify}`);
            const groupInviteEvent = new OB11GroupRequestEvent(
              this.core,
              parseInt(notify.group.groupCode),
              parseInt(await this.core.apis.UserApi.getUinByUidV2(notify.user2.uid)),
              "invite",
              notify.postscript,
              flag
            );
            this.networkManager.emitEvent(groupInviteEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理邀请本人加群失败", e));
          } else if (notify.type == GroupNotifyMsgType.INVITED_NEED_ADMINI_STRATOR_PASS && notify.status == GroupNotifyMsgStatus.KUNHANDLE) {
            this.context.logger.logDebug(`收到群员邀请加群通知:${notify}`);
            const groupInviteEvent = new OB11GroupRequestEvent(
              this.core,
              parseInt(notify.group.groupCode),
              parseInt(await this.core.apis.UserApi.getUinByUidV2(notify.user1.uid)),
              "add",
              notify.postscript,
              flag
            );
            this.networkManager.emitEvent(groupInviteEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理邀请本人加群失败", e));
          }
        }
      }
    };
    groupListener.onMemberInfoChange = async (groupCode, dataSource, members) => {
      if (dataSource === DataSource.LOCAL) {
        const existMembers = this.core.apis.GroupApi.groupMemberCache.get(groupCode);
        if (!existMembers) return;
        members.forEach((member) => {
          const existMember = existMembers.get(member.uid);
          if (!existMember?.isChangeRole) return;
          this.context.logger.logDebug("变动管理员获取成功");
          const groupAdminNoticeEvent = new OB11GroupAdminNoticeEvent(
            this.core,
            parseInt(groupCode),
            parseInt(member.uin),
            member.role === GroupMemberRole.admin ? "set" : "unset"
          );
          this.networkManager.emitEvent(groupAdminNoticeEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理群管理员变动失败", e));
          existMember.isChangeRole = false;
          this.context.logger.logDebug.bind(this.context.logger)("群管理员变动处理完毕");
        });
      }
    };
    this.context.session.getGroupService().addKernelGroupListener(
      proxiedListenerOf(groupListener, this.context.logger)
    );
  }
  async emitMsg(message) {
    const { debug, reportSelfMessage, messagePostFormat } = this.configLoader.configData;
    this.context.logger.logDebug("收到新消息 RawMessage", message);
    this.apis.MsgApi.parseMessage(message, messagePostFormat).then((ob11Msg) => {
      if (!ob11Msg) return;
      this.context.logger.logDebug("转化为 OB11Message", ob11Msg);
      if (debug) {
        ob11Msg.raw = message;
      } else {
        if (ob11Msg.message.length === 0) {
          return;
        }
      }
      const isSelfMsg = ob11Msg.user_id.toString() == this.core.selfInfo.uin;
      if (isSelfMsg && !reportSelfMessage) {
        return;
      }
      if (isSelfMsg) {
        ob11Msg.target_id = parseInt(message.peerUin);
      }
      this.networkManager.emitEvent(ob11Msg);
    }).catch((e) => this.context.logger.logError.bind(this.context.logger)("constructMessage error: ", e));
    this.apis.GroupApi.parseGroupEvent(message).then((groupEvent) => {
      if (groupEvent) {
        this.networkManager.emitEvent(groupEvent);
      }
    }).catch((e) => this.context.logger.logError.bind(this.context.logger)("constructGroupEvent error: ", e));
    this.apis.MsgApi.parsePrivateMsgEvent(message).then((privateEvent) => {
      if (privateEvent) {
        this.networkManager.emitEvent(privateEvent);
      }
    }).catch((e) => this.context.logger.logError.bind(this.context.logger)("constructPrivateEvent error: ", e));
  }
  async emitRecallMsg(msgList, cache) {
    for (const message of msgList) {
      const peer = { chatType: message.chatType, peerUid: message.peerUid, guildId: "" };
      if (message.recallTime != "0" && !cache.get(message.msgId)) {
        cache.put(message.msgId, true);
        let oriMessageId = MessageUnique.getShortIdByMsgId(message.msgId);
        if (!oriMessageId) {
          oriMessageId = MessageUnique.createUniqueMsgId(peer, message.msgId);
        }
        if (message.chatType == ChatType.KCHATTYPEC2C) {
          const friendRecallEvent = new OB11FriendRecallNoticeEvent(
            this.core,
            parseInt(message.senderUin),
            oriMessageId
          );
          this.networkManager.emitEvent(friendRecallEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理好友消息撤回失败", e));
        } else if (message.chatType == ChatType.KCHATTYPEGROUP) {
          let operatorId = message.senderUin;
          for (const element of message.elements) {
            const operatorUid = element.grayTipElement?.revokeElement.operatorUid;
            if (!operatorUid) return;
            const operator = await this.core.apis.GroupApi.getGroupMember(message.peerUin, operatorUid);
            operatorId = operator?.uin || message.senderUin;
          }
          const groupRecallEvent = new OB11GroupRecallNoticeEvent(
            this.core,
            parseInt(message.peerUin),
            parseInt(message.senderUin),
            parseInt(operatorId),
            oriMessageId
          );
          this.networkManager.emitEvent(groupRecallEvent).catch((e) => this.context.logger.logError.bind(this.context.logger)("处理群消息撤回失败", e));
        }
      }
    }
  }
}

class AuthHelper {
  static secretKey = Math.random().toString(36).slice(2);
  /**
   * 签名凭证方法。
   * @param token 待签名的凭证字符串。
   * @returns 签名后的凭证对象。
   */
  static async signCredential(token) {
    const innerJson = {
      CreatedTime: Date.now(),
      TokenEncoded: token
    };
    const jsonString = JSON.stringify(innerJson);
    const hmac = crypto__default.createHmac("sha256", AuthHelper.secretKey).update(jsonString, "utf8").digest("hex");
    return { Data: innerJson, Hmac: hmac };
  }
  /**
   * 检查凭证是否被篡改的方法。
   * @param credentialJson 凭证的JSON对象。
   * @returns 布尔值，表示凭证是否有效。
   */
  static async checkCredential(credentialJson) {
    try {
      const jsonString = JSON.stringify(credentialJson.Data);
      const calculatedHmac = crypto__default.createHmac("sha256", AuthHelper.secretKey).update(jsonString, "utf8").digest("hex");
      return calculatedHmac === credentialJson.Hmac;
    } catch (error) {
      return false;
    }
  }
  /**
   * 验证凭证在1小时内有效且token与原始token相同。
   * @param token 待验证的原始token。
   * @param credentialJson 已签名的凭证JSON对象。
   * @returns 布尔值，表示凭证是否有效且token匹配。
   */
  static async validateCredentialWithinOneHour(token, credentialJson) {
    const isValid = await AuthHelper.checkCredential(credentialJson);
    if (!isValid) {
      return false;
    }
    const currentTime = Date.now() / 1e3;
    const createdTime = credentialJson.Data.CreatedTime;
    const timeDifference = currentTime - createdTime;
    return timeDifference <= 3600 && credentialJson.Data.TokenEncoded === token;
  }
}

const isEmpty$2 = (data) => data === void 0 || data === null || data === "";
const QQGetQRcodeHandler = async (req, res) => {
  if (await WebUiDataRuntime.getQQLoginStatus()) {
    res.send({
      code: -1,
      message: "QQ Is Logined"
    });
    return;
  }
  const qrcodeUrl = await WebUiDataRuntime.getQQLoginQrcodeURL();
  if (isEmpty$2(qrcodeUrl)) {
    res.send({
      code: -1,
      message: "QRCode Get Error"
    });
    return;
  }
  res.send({
    code: 0,
    message: "success",
    data: {
      qrcode: qrcodeUrl
    }
  });
  return;
};
const QQCheckLoginStatusHandler = async (req, res) => {
  res.send({
    code: 0,
    message: "success",
    data: {
      isLogin: await WebUiDataRuntime.getQQLoginStatus()
    }
  });
};
const QQSetQuickLoginHandler = async (req, res) => {
  const { uin } = req.body;
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (isLogin) {
    res.send({
      code: -1,
      message: "QQ Is Logined"
    });
    return;
  }
  if (isEmpty$2(uin)) {
    res.send({
      code: -1,
      message: "uin is empty"
    });
    return;
  }
  const { result, message } = await WebUiDataRuntime.requestQuickLogin(uin);
  if (!result) {
    res.send({
      code: -1,
      message
    });
    return;
  }
  res.send({
    code: 0,
    message: "success"
  });
};
const QQGetQuickLoginListHandler = async (req, res) => {
  const quickLoginList = await WebUiDataRuntime.getQQQuickLoginList();
  res.send({
    code: 0,
    data: quickLoginList
  });
};

const router$3 = Router();
router$3.all("/GetQuickLoginList", QQGetQuickLoginListHandler);
router$3.post("/CheckLoginStatus", QQCheckLoginStatusHandler);
router$3.post("/GetQQLoginQrcode", QQGetQRcodeHandler);
router$3.post("/SetQuickLogin", QQSetQuickLoginHandler);

const isEmpty$1 = (data) => data === void 0 || data === null || data === "";
const LoginHandler = async (req, res) => {
  const WebUiConfigData = await WebUiConfig.GetWebUIConfig();
  const { token } = req.body;
  if (isEmpty$1(token)) {
    res.json({
      code: -1,
      message: "token is empty"
    });
    return;
  }
  if (!await WebUiDataRuntime.checkLoginRate(WebUiConfigData.loginRate)) {
    res.json({
      code: -1,
      message: "login rate limit"
    });
    return;
  }
  if (WebUiConfigData.token !== token) {
    res.json({
      code: -1,
      message: "token is invalid"
    });
    return;
  }
  const signCredential = Buffer.from(JSON.stringify(await AuthHelper.signCredential(WebUiConfigData.token))).toString("base64");
  res.json({
    code: 0,
    message: "success",
    data: {
      "Credential": signCredential
    }
  });
  return;
};
const LogoutHandler = (req, res) => {
  res.json({
    code: 0,
    message: "success"
  });
  return;
};
const checkHandler = async (req, res) => {
  const WebUiConfigData = await WebUiConfig.GetWebUIConfig();
  const authorization = req.headers.authorization;
  try {
    const CredentialBase64 = authorization?.split(" ")[1];
    const Credential = JSON.parse(Buffer.from(CredentialBase64, "base64").toString());
    await AuthHelper.validateCredentialWithinOneHour(WebUiConfigData.token, Credential);
    res.json({
      code: 0,
      message: "success"
    });
    return;
  } catch (e) {
    res.json({
      code: -1,
      message: "failed"
    });
  }
  return;
};

const router$2 = Router();
router$2.post("/login", LoginHandler);
router$2.post("/check", checkHandler);
router$2.post("/logout", LogoutHandler);

const isEmpty = (data) => data === void 0 || data === null || data === "";
const OB11GetConfigHandler = async (req, res) => {
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (!isLogin) {
    res.send({
      code: -1,
      message: "Not Login"
    });
    return;
  }
  const uin = await WebUiDataRuntime.getQQLoginUin();
  const configFilePath = resolve$3(webUiPathWrapper.configPath, `./onebot11_${uin}.json`);
  let data;
  try {
    data = JSON.parse(
      existsSync(configFilePath) ? readFileSync(configFilePath).toString() : readFileSync(resolve$3(webUiPathWrapper.configPath, "./onebot11.json")).toString()
    );
  } catch (e) {
    data = {};
    res.send({
      code: -1,
      message: "Config Get Error"
    });
    return;
  }
  res.send({
    code: 0,
    message: "success",
    data
  });
  return;
};
const OB11SetConfigHandler = async (req, res) => {
  const isLogin = await WebUiDataRuntime.getQQLoginStatus();
  if (!isLogin) {
    res.send({
      code: -1,
      message: "Not Login"
    });
    return;
  }
  if (isEmpty(req.body.config)) {
    res.send({
      code: -1,
      message: "config is empty"
    });
    return;
  }
  let SetResult;
  try {
    await WebUiDataRuntime.setOB11Config(JSON.parse(req.body.config));
    SetResult = true;
  } catch (e) {
    SetResult = false;
  }
  if (SetResult) {
    res.send({
      code: 0,
      message: "success"
    });
  } else {
    res.send({
      code: -1,
      message: "Config Set Error"
    });
  }
  return;
};

const router$1 = Router();
router$1.post("/GetConfig", OB11GetConfigHandler);
router$1.post("/SetConfig", OB11SetConfigHandler);

const router = Router();
async function AuthApi(req, res, next) {
  if (req.url == "/auth/login") {
    next();
    return;
  }
  if (req.headers?.authorization) {
    const authorization = req.headers.authorization.split(" ");
    if (authorization.length < 2) {
      res.json({
        code: -1,
        msg: "Unauthorized"
      });
      return;
    }
    const token = authorization[1];
    let Credential;
    try {
      Credential = JSON.parse(Buffer.from(token, "base64").toString("utf-8"));
    } catch (e) {
      res.json({
        code: -1,
        msg: "Unauthorized"
      });
      return;
    }
    const config = await WebUiConfig.GetWebUIConfig();
    const credentialJson = await AuthHelper.validateCredentialWithinOneHour(config.token, Credential);
    if (credentialJson) {
      next();
      return;
    }
    res.json({
      code: -1,
      msg: "Unauthorized"
    });
    return;
  }
  res.json({
    code: -1,
    msg: "Server Error"
  });
  return;
}
router.use(AuthApi);
router.all("/test", (req, res) => {
  res.json({
    code: 0,
    msg: "ok"
  });
});
router.use("/auth", router$2);
router.use("/QQLogin", router$3);
router.use("/OB11Config", router$1);

const MAX_PORT_TRY = 100;
async function tryUseHost(host) {
  return new Promise(async (resolve2, reject) => {
    try {
      const server = net.createServer();
      server.on("listening", () => {
        server.close();
        resolve2(host);
      });
      server.on("error", (err) => {
        if (err.code === "EADDRNOTAVAIL") {
          reject("主机地址验证失败，可能为非本机地址");
        } else {
          reject(`遇到错误: ${err.code}`);
        }
      });
      server.listen(0, host);
    } catch (error) {
      reject(`服务器启动时发生错误: ${error}`);
    }
  });
}
async function tryUsePort(port, host, tryCount = 0) {
  return new Promise(async (resolve2, reject) => {
    try {
      const server = net.createServer();
      server.on("listening", () => {
        server.close();
        resolve2(port);
      });
      server.on("error", (err) => {
        if (err.code === "EADDRINUSE") {
          if (tryCount < MAX_PORT_TRY) {
            resolve2(tryUsePort(port + 1, host, tryCount + 1));
          } else {
            reject(`端口尝试失败，达到最大尝试次数: ${MAX_PORT_TRY}`);
          }
        } else {
          reject(`遇到错误: ${err.code}`);
        }
      });
      server.listen(port, host);
    } catch (error) {
      reject(`服务器启动时发生错误: ${error}`);
    }
  });
}
class WebUiConfigWrapper {
  WebUiConfigData = void 0;
  applyDefaults(obj, defaults) {
    return { ...defaults, ...obj };
  }
  async GetWebUIConfig() {
    if (this.WebUiConfigData) {
      return this.WebUiConfigData;
    }
    const defaultconfig = {
      host: "0.0.0.0",
      port: 6099,
      prefix: "",
      token: "",
      // 默认先填空，空密码无法登录
      loginRate: 3
    };
    try {
      defaultconfig.token = Math.random().toString(36).slice(2);
    } catch (e) {
      console.log("随机密码生成失败", e);
    }
    try {
      const configPath = resolve$3(webUiPathWrapper.configPath, "./webui.json");
      if (!existsSync(configPath)) {
        writeFileSync(configPath, JSON.stringify(defaultconfig, null, 4));
      }
      const fileContent = readFileSync(configPath, "utf-8");
      const parsedConfig = this.applyDefaults(JSON.parse(fileContent), defaultconfig);
      if (!parsedConfig.prefix.startsWith("/")) parsedConfig.prefix = "/" + parsedConfig.prefix;
      if (parsedConfig.prefix.endsWith("/")) parsedConfig.prefix = parsedConfig.prefix.slice(0, -1);
      writeFileSync(configPath, JSON.stringify(parsedConfig, null, 4));
      const [host_err, host] = await tryUseHost(parsedConfig.host).then((data) => [null, data]).catch((err) => [err, null]);
      if (host_err) {
        console.log("host不可用", host_err);
        parsedConfig.port = 0;
      } else {
        parsedConfig.host = host;
        const [port_err, port] = await tryUsePort(parsedConfig.port, parsedConfig.host).then((data) => [null, data]).catch((err) => [err, null]);
        if (port_err) {
          console.log("port不可用", port_err);
          parsedConfig.port = 0;
        } else {
          parsedConfig.port = port;
        }
      }
      this.WebUiConfigData = parsedConfig;
      return this.WebUiConfigData;
    } catch (e) {
      console.log("读取配置文件失败", e);
    }
    return defaultconfig;
  }
}

const app = express();
let WebUiConfig;
let webUiPathWrapper;
async function InitWebUi(logger, pathWrapper) {
  webUiPathWrapper = pathWrapper;
  WebUiConfig = new WebUiConfigWrapper();
  const log = logger.log.bind(logger);
  const config = await WebUiConfig.GetWebUIConfig();
  if (config.port == 0) {
    log("[NapCat] [WebUi] Current WebUi is not run.");
    return;
  }
  app.use(express.json());
  app.all(config.prefix + "/", (_req, res) => {
    res.json({
      msg: "NapCat WebAPI is now running!"
    });
  });
  app.use(config.prefix + "/webui", express.static(pathWrapper.staticPath));
  app.use(config.prefix + "/api", router);
  app.listen(config.port, config.host, async () => {
    log(`[NapCat] [WebUi] Current WebUi is running at http://${config.host}:${config.port}${config.prefix}`);
    log(`[NapCat] [WebUi] Login Token is ${config.token}`);
    log(`[NapCat] [WebUi] WebUi User  Panel Url: http://${config.host}:${config.port}${config.prefix}/webui?token=${config.token}`);
    log(`[NapCat] [WebUi] WebUi Local Panel Url: http://127.0.0.1:${config.port}${config.prefix}/webui?token=${config.token}`);
    RequestUtil.HttpGetJson(
      "https://ip.011102.xyz/",
      "GET",
      {},
      {},
      true,
      true
    ).then((data) => {
      log(`[NapCat] [WebUi] WebUi Publish Panel Url: http://${data.IP.IP}:${config.port}${config.prefix}/webui/?token=${config.token}`);
    }).catch((err) => {
      logger.logError.bind(logger)(`[NapCat] [WebUi] Get Publish Panel Url Error: ${err}`);
    });
  });
}

class NodeIO3MiscListener {
  getOnAmgomDataPiece(...arg) {
  }
}

program.option("-q, --qq [number]", "QQ号").parse(process.argv);
const cmdOptions = program.opts();
async function NCoreInitShell() {
  console.log("NapCat Shell App Loading...");
  const pathWrapper = new NapCatPathWrapper();
  const logger = new LogWrapper(pathWrapper.logsPath);
  const basicInfoWrapper = new QQBasicInfoWrapper({ logger });
  const wrapper = loadQQWrapper(basicInfoWrapper.getFullQQVesion());
  const o3Service = wrapper.NodeIO3MiscService.get();
  o3Service.addO3MiscListener(new NodeIO3MiscListener());
  logger.log(`[NapCat] [Core] NapCat.Core Version: ` + napCatVersion);
  InitWebUi(logger, pathWrapper).then().catch(logger.logError.bind(logger));
  const engine = wrapper.NodeIQQNTWrapperEngine.get();
  const loginService = wrapper.NodeIKernelLoginService.get();
  const session = wrapper.NodeIQQNTWrapperSession.create();
  const [dataPath, dataPathGlobal] = (() => {
    if (os__default.platform() === "darwin") {
      const userPath = os__default.homedir();
      const appDataPath = path$2.resolve(userPath, "./Library/Application Support/QQ");
      return [appDataPath, path$2.join(appDataPath, "global")];
    }
    let dataPath2 = wrapper.NodeQQNTWrapperUtil.getNTUserDataInfoConfig();
    if (!dataPath2) {
      dataPath2 = path$2.resolve(os__default.homedir(), "./.config/QQ");
      fs__default.mkdirSync(dataPath2, { recursive: true });
    }
    const dataPathGlobal2 = path$2.resolve(dataPath2, "./nt_qq/global");
    return [dataPath2, dataPathGlobal2];
  })();
  const platformMapping = {
    win32: PlatformType.KWINDOWS,
    darwin: PlatformType.KMAC,
    linux: PlatformType.KLINUX
  };
  const systemPlatform = platformMapping[os__default.platform()] ?? PlatformType.KWINDOWS;
  if (!basicInfoWrapper.QQVersionAppid || !basicInfoWrapper.QQVersionQua) throw new Error("QQVersionAppid or QQVersionQua  is not defined");
  engine.initWithDeskTopConfig(
    {
      base_path_prefix: "",
      platform_type: systemPlatform,
      app_type: 4,
      app_version: basicInfoWrapper.getFullQQVesion(),
      os_version: systemVersion,
      use_xlog: false,
      qua: basicInfoWrapper.QQVersionQua,
      global_path_config: {
        desktopGlobalPath: dataPathGlobal
      },
      thumb_config: { maxSide: 324, minSide: 48, longLimit: 6, density: 2 }
    },
    new NodeIGlobalAdapter()
  );
  loginService.initConfig({
    machineId: "",
    appid: basicInfoWrapper.QQVersionAppid,
    platVer: systemVersion,
    commonPath: dataPathGlobal,
    clientVer: basicInfoWrapper.getFullQQVesion(),
    hostName: hostname
  });
  let quickLoginUin = cmdOptions.qq;
  const historyLoginList = (await loginService.getLoginList()).LocalLoginInfoList;
  if (quickLoginUin == "true") {
    if (historyLoginList.length > 0) {
      quickLoginUin = historyLoginList[0].uin;
      logger.log(`-q 指令指定使用最近的 QQ ${quickLoginUin} 进行快速登录`);
    } else {
      quickLoginUin = "";
    }
  }
  const dataTimestape = (/* @__PURE__ */ new Date()).getTime().toString();
  o3Service.reportAmgomWeather("login", "a1", [dataTimestape, "0", "0"]);
  const selfInfo = await new Promise((resolve) => {
    const loginListener = new NodeIKernelLoginListener();
    let isLogined = false;
    loginListener.onUserLoggedIn = (userid) => {
      logger.logError.bind(logger)(`当前账号(${userid})已登录,无法重复登录`);
    };
    loginListener.onQRCodeLoginSucceed = async (loginResult) => {
      isLogined = true;
      resolve({
        uid: loginResult.uid,
        uin: loginResult.uin,
        nick: "",
        // 获取不到
        online: true
      });
    };
    loginListener.onQRCodeGetPicture = ({ pngBase64QrcodeData, qrcodeUrl }) => {
      WebUiDataRuntime.setQQLoginQrcodeURL(qrcodeUrl);
      const realBase64 = pngBase64QrcodeData.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(realBase64, "base64");
      logger.logWarn("请扫描下面的二维码，然后在手Q上授权登录：");
      const qrcodePath = path$2.join(pathWrapper.cachePath, "qrcode.png");
      qrcode.generate(qrcodeUrl, { small: true }, (res) => {
        logger.logWarn([
          "\n",
          res,
          "二维码解码URL: " + qrcodeUrl,
          "如果控制台二维码无法扫码，可以复制解码url到二维码生成网站生成二维码再扫码，也可以打开下方的二维码路径图片进行扫码。"
        ].join("\n"));
        fs__default.writeFile(qrcodePath, buffer, {}, () => {
          logger.logWarn("二维码已保存到", qrcodePath);
        });
      });
    };
    loginListener.onQRCodeSessionFailed = (errType, errCode, errMsg) => {
      if (!isLogined) {
        logger.logError.bind(logger)("[Core] [Login] Login Error,ErrCode: ", errCode, " ErrMsg:", errMsg);
        loginService.getQRCodePicture();
      }
    };
    loginListener.onLoginFailed = (args) => {
      logger.logError.bind(logger)("[Core] [Login] Login Error , ErrInfo: ", args);
    };
    loginService.addKernelLoginListener(proxiedListenerOf(loginListener, logger));
    const isConnect = loginService.connect();
    if (!isConnect) {
      logger.logError.bind(logger)("核心登录服务连接失败!");
      return;
    }
    logger.log("核心登录服务连接成功!");
    loginService.getLoginList().then((res) => {
      WebUiDataRuntime.setQQQuickLoginList(res.LocalLoginInfoList.filter((item) => item.isQuickLogin).map((item) => item.uin.toString()));
    });
    if (basicInfoWrapper.QQVersionConfig?.curVersion) {
      loginService.getLoginMiscData("hotUpdateSign").then((res) => {
        if (res.result === 0) {
          loginService.setLoginMiscData("hotUpdateSign", res.value);
        }
      });
      session.getNodeMiscService().writeVersionToRegistry(basicInfoWrapper.QQVersionConfig?.curVersion);
    }
    WebUiDataRuntime.setQuickLoginCall(async (uin) => {
      return await new Promise((resolve2) => {
        if (uin) {
          logger.log.bind(logger)("正在快速登录 ", uin);
          loginService.quickLoginWithUin(uin).then((res) => {
            if (res.loginErrorInfo.errMsg) {
              resolve2({ result: false, message: res.loginErrorInfo.errMsg });
            }
            resolve2({ result: true, message: "" });
          }).catch((e) => {
            logger.logError.bind(logger)(e);
            resolve2({ result: false, message: "快速登录发生错误" });
          });
        } else {
          resolve2({ result: false, message: "快速登录失败" });
        }
      });
    });
    if (quickLoginUin) {
      if (historyLoginList.some((u) => u.uin === quickLoginUin)) {
        logger.log("正在快速登录 ", quickLoginUin);
        setTimeout(() => {
          loginService.quickLoginWithUin(quickLoginUin).then((result) => {
            if (result.loginErrorInfo.errMsg) {
              logger.logError.bind(logger)("快速登录错误：", result.loginErrorInfo.errMsg);
              if (!isLogined) loginService.getQRCodePicture();
            }
          }).catch();
        }, 1e3);
      } else {
        logger.logError.bind(logger)("快速登录失败，未找到该 QQ 历史登录记录，将使用二维码登录方式");
        if (!isLogined) loginService.getQRCodePicture();
      }
    } else {
      logger.log("没有 -q 指令指定快速登录，将使用二维码登录方式");
      if (historyLoginList.length > 0) {
        logger.log(`可用于快速登录的 QQ：
${historyLoginList.map((u, index) => `${index + 1}. ${u.uin} ${u.nickName}`).join("\n")}`);
      }
      loginService.getQRCodePicture();
    }
  });
  const amgomDataPiece = "eb1fd6ac257461580dc7438eb099f23aae04ca679f4d88f53072dc56e3bb1129";
  o3Service.setAmgomDataPiece(basicInfoWrapper.QQVersionAppid, new Uint8Array(Buffer.from(amgomDataPiece, "hex")));
  let guid = loginService.getMachineGuid();
  guid = guid.slice(0, 8) + "-" + guid.slice(8, 12) + "-" + guid.slice(12, 16) + "-" + guid.slice(16, 20) + "-" + guid.slice(20);
  o3Service.reportAmgomWeather("login", "a6", [dataTimestape, "184", "329"]);
  await new Promise(async (resolve, reject) => {
    const sessionConfig = await genSessionConfig(
      guid,
      basicInfoWrapper.QQVersionAppid,
      basicInfoWrapper.getFullQQVesion(),
      selfInfo.uin,
      selfInfo.uid,
      dataPath
    );
    const sessionListener = new NodeIKernelSessionListener();
    sessionListener.onSessionInitComplete = (r) => {
      if (r === 0) {
        resolve();
      } else {
        reject(r);
      }
    };
    session.init(
      sessionConfig,
      new NodeIDependsAdapter(),
      new NodeIDispatcherAdapter(),
      sessionListener
    );
    try {
      session.startNT(0);
    } catch (_) {
      try {
        session.startNT();
      } catch (e) {
        reject("init failed " + e);
      }
    }
  });
  const accountDataPath = path$2.resolve(dataPath, "./NapCat/data");
  fs__default.mkdirSync(dataPath, { recursive: true });
  logger.logDebug("本账号数据/缓存目录：", accountDataPath);
  new NapCatShell(
    wrapper,
    session,
    logger,
    loginService,
    selfInfo,
    basicInfoWrapper,
    pathWrapper
  );
}
class NapCatShell {
  core;
  context;
  constructor(wrapper, session, logger, loginService, selfInfo, basicInfoWrapper, pathWrapper) {
    this.context = {
      workingEnv: NapCatCoreWorkingEnv.Shell,
      wrapper,
      session,
      logger,
      loginService,
      basicInfoWrapper,
      pathWrapper
    };
    this.core = new NapCatCore(this.context, selfInfo);
    new NapCatOneBot11Adapter(this.core, this.context, pathWrapper);
  }
}
NCoreInitShell();

export { NCoreInitShell, NapCatShell };
